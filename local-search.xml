<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>03-網路七層模型與 AWS 基礎網路設置筆記</title>
    <link href="/network/20241030/1730109598/"/>
    <url>/network/20241030/1730109598/</url>
    
    <content type="html"><![CDATA[<h2 id="網路七層模型概述與-AWS-應用"><a href="#網路七層模型概述與-AWS-應用" class="headerlink" title="網路七層模型概述與 AWS 應用"></a>網路七層模型概述與 AWS 應用</h2><p><img src="/images/aws/03-network-layers-aws.webp" alt="網路七層與 AWS"></p><p>網路七層模型（OSI 模型）是描述網路通信的標準模型，分為七個層級。這些層級在雲端架構（如 AWS）中有不同的應用與實現方式。以下為各層功能及其在 AWS 環境中的相關服務：</p><ul><li><strong>物理層</strong>：管理物理連接，如硬體、電纜、信號傳輸。在 AWS 上，這層由 AWS 數據中心的物理基礎設施管理，開發者無法直接接觸。</li><li><strong>數據鏈路層</strong>：涉及資料封裝與網路接口，如 MAC 地址與網卡管理。在 AWS 中，這一層的操作通常由虛擬網卡（ENI）和 VPC 網路接口管理。</li><li><strong>網路層</strong>：負責路由選擇與 IP 地址管理。在 AWS 上，使用 Virtual Private Cloud (VPC)、路由表、Internet Gateway 和 NAT Gateway 來管理網路流量。</li><li><strong>傳輸層</strong>：提供數據傳輸控制與管理，如 TCP、UDP 協議。在 AWS 中，可以利用 Elastic Load Balancer (ELB) 來分配傳輸層流量。</li><li><strong>會話層</strong>：管理連接的建立與維護，如 VPN 連接、TLS 加密通道。AWS 提供的服務如 AWS VPN 和 AWS Direct Connect 協助管理長連接。</li><li><strong>表示層</strong>：負責數據格式轉換與加密解密。在 AWS 上，這層主要涉及到 AWS Certificate Manager (ACM) 和數據加密服務。</li><li><strong>應用層</strong>：提供與使用者互動的服務，如 HTTP、DNS。在 AWS 環境中，這層可使用服務如 Route 53（DNS）、API Gateway（HTTP API）、以及各種應用程序服務。</li></ul><blockquote><p><strong>備註</strong>：AWS 提供了許多高階服務來簡化這些層的管理與配置，如 VPC、ELB、和 Route 53，使得雲端架構更容易部署與管理。</p></blockquote><hr><h2 id="AWS-中的網路設置與安全配置"><a href="#AWS-中的網路設置與安全配置" class="headerlink" title="AWS 中的網路設置與安全配置"></a>AWS 中的網路設置與安全配置</h2><h3 id="1-VPC-設置與-IP-配置"><a href="#1-VPC-設置與-IP-配置" class="headerlink" title="1. VPC 設置與 IP 配置"></a>1. VPC 設置與 IP 配置</h3><ul><li><strong>VPC（Virtual Private Cloud）</strong>：AWS 中的 VPC 相當於自定義網路層，允許你設定 IP 範圍、子網、路由規則等，並且可以在內部建立私有網路環境。</li><li><strong>子網劃分</strong>：將 VPC 劃分為公共和私有子網，以隔離公開與內部服務。例如，將 Web 服務部署在公共子網，而數據庫部署在私有子網內。</li><li><strong>路由與網關</strong>：配置路由表來控制流量流向，使用 Internet Gateway 來連接外部網路，或使用 NAT Gateway 來讓私有子網訪問外部資源。</li></ul><h3 id="2-防火牆配置與安全組"><a href="#2-防火牆配置與安全組" class="headerlink" title="2. 防火牆配置與安全組"></a>2. 防火牆配置與安全組</h3><ul><li><strong>安全組（Security Groups）</strong>：AWS 上的虛擬防火牆，用於控制入站和出站流量。可以根據 IP 或端口設定規則，預設拒絕所有未授權的流量。</li><li><strong>網路 ACL（Network Access Control List）</strong>：用於子網級別的流量控制，提供更細緻的流量過濾規則，適合需要加強安全的應用場景。</li></ul><h3 id="3-傳輸層與負載均衡"><a href="#3-傳輸層與負載均衡" class="headerlink" title="3. 傳輸層與負載均衡"></a>3. 傳輸層與負載均衡</h3><ul><li>**Elastic Load Balancer (ELB)**：負責傳輸層的流量分配，支持 TCP 和 UDP 協議，並提供健康檢查功能，確保後端服務的可用性。</li><li><strong>TLS&#x2F;SSL 加密</strong>：可以在 ELB 上配置 TLS 設定，確保數據在傳輸過程中安全加密。可使用 AWS Certificate Manager (ACM) 管理憑證。</li></ul><h3 id="4-會話管理與連接優化"><a href="#4-會話管理與連接優化" class="headerlink" title="4. 會話管理與連接優化"></a>4. 會話管理與連接優化</h3><ul><li><strong>AWS VPN</strong>：用於建立安全的 VPN 通道，連接本地數據中心與 AWS VPC，確保數據傳輸的安全性。</li><li><strong>AWS Direct Connect</strong>：提供專用網路連接，降低延遲並提高網路性能，適合對帶寬和穩定性要求較高的業務。</li></ul><h3 id="5-DNS-與域名解析"><a href="#5-DNS-與域名解析" class="headerlink" title="5. DNS 與域名解析"></a>5. DNS 與域名解析</h3><ul><li><strong>Amazon Route 53</strong>：提供高可用的 DNS 服務，支持域名解析、健康檢查和流量路由策略，確保應用的全球可達性。</li><li><strong>內部 DNS 設置</strong>：在 VPC 中配置內部 DNS，用於解析內部服務域名，便於內部服務間的通信。</li></ul><h3 id="6-流量管理與-QoS"><a href="#6-流量管理與-QoS" class="headerlink" title="6. 流量管理與 QoS"></a>6. 流量管理與 QoS</h3><ul><li><strong>Traffic Mirroring</strong>：複製 VPC 中的網路流量，用於流量分析和監控。</li><li><strong>QoS 設置</strong>：雖然 AWS 上沒有直接的 QoS 設置，但可以通過配置網路策略和資源限制來優化網路性能。</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AWS</tag>
      
      <tag>network</tag>
      
      <tag>infra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02-aws-iam-setting</title>
    <link href="/aws/20241030/3396982194/"/>
    <url>/aws/20241030/3396982194/</url>
    
    <content type="html"><![CDATA[<h1 id="AWS-IAM-用戶創建和設置步驟"><a href="#AWS-IAM-用戶創建和設置步驟" class="headerlink" title="AWS IAM 用戶創建和設置步驟"></a>AWS IAM 用戶創建和設置步驟</h1><p><img src="/images/aws/02-iam-setup.webp" alt="設置IAM"></p><h2 id="1-登入AWS管理控制台"><a href="#1-登入AWS管理控制台" class="headerlink" title="1. 登入AWS管理控制台"></a>1. 登入AWS管理控制台</h2><ul><li>使用根帳戶或具有相應權限的IAM用戶登入AWS管理控制台。</li></ul><h2 id="2-創建用戶組"><a href="#2-創建用戶組" class="headerlink" title="2. 創建用戶組"></a>2. 創建用戶組</h2><h3 id="2-1-導航到IAM服務"><a href="#2-1-導航到IAM服務" class="headerlink" title="2.1 導航到IAM服務"></a>2.1 導航到IAM服務</h3><ul><li>在控制台首頁，搜尋並選擇“IAM”。</li></ul><h3 id="2-2-創建用戶組"><a href="#2-2-創建用戶組" class="headerlink" title="2.2 創建用戶組"></a>2.2 創建用戶組</h3><ul><li>在左側導航欄中選擇「User groups」。</li><li>點擊「Create group」。</li><li>輸入用戶組名稱（例如，<code>Admins</code>）。</li><li>在「Attach permissions policies」部分，選擇<code>AdministratorAccess</code>策略。</li><li>點擊「Create group」。</li></ul><blockquote><p><strong>影響範圍</strong>：</p><ul><li>用戶組的設定直接影響用戶能夠操作和訪問哪些AWS服務與資源。</li><li>授予<code>AdministratorAccess</code>策略的用戶組可以完全控制AWS帳戶，請僅在必要時分配此級別的權限，以降低安全風險。</li></ul></blockquote><hr><h2 id="3-創建IAM用戶"><a href="#3-創建IAM用戶" class="headerlink" title="3. 創建IAM用戶"></a>3. 創建IAM用戶</h2><h3 id="3-1-添加新用戶"><a href="#3-1-添加新用戶" class="headerlink" title="3.1 添加新用戶"></a>3.1 添加新用戶</h3><ul><li>在左側導航欄中選擇「Users」，然後點擊「Add user」。</li></ul><h3 id="3-2-設定用戶名和訪問類型"><a href="#3-2-設定用戶名和訪問類型" class="headerlink" title="3.2 設定用戶名和訪問類型"></a>3.2 設定用戶名和訪問類型</h3><ul><li>輸入用戶名（例如，<code>joe</code>）。</li><li>勾選「AWS Management Console access」以允許該用戶通過AWS管理控制台登錄。</li><li>設定密碼（自定義或自動生成），並選擇「User must create a new password at next sign-in」（可選）。</li></ul><h3 id="3-3-設置權限"><a href="#3-3-設置權限" class="headerlink" title="3.3 設置權限"></a>3.3 設置權限</h3><ul><li>在「Set permissions」頁面上，選擇「Add user to group」，然後從下拉列表中選擇剛剛創建的用戶組（例如，<code>Admins</code>）。</li></ul><h3 id="3-4-檢查並創建用戶"><a href="#3-4-檢查並創建用戶" class="headerlink" title="3.4 檢查並創建用戶"></a>3.4 檢查並創建用戶</h3><ul><li>點擊「Next: Tags」，然後可以選擇添加標籤（可選）。</li><li>點擊「Next: Review」，檢查所有設置是否正確，然後點擊「Create user」。</li></ul><h3 id="3-5-保存登入資訊"><a href="#3-5-保存登入資訊" class="headerlink" title="3.5 保存登入資訊"></a>3.5 保存登入資訊</h3><ul><li>系統會顯示該用戶的登入詳細資訊，包括用戶名、密碼和登入URL。<strong>務必將這些信息保密，並發送給該用戶進行首次登入</strong>。</li></ul><hr><h2 id="4-測試登入"><a href="#4-測試登入" class="headerlink" title="4. 測試登入"></a>4. 測試登入</h2><h3 id="4-1-獲取登入URL"><a href="#4-1-獲取登入URL" class="headerlink" title="4.1 獲取登入URL"></a>4.1 獲取登入URL</h3><ul><li><p>用戶需要使用以下格式的登入URL：</p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">https://&lt;Your_AWS_Account_ID&gt;.signin.aws.amazon.com/console/<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-2-提供用戶名和密碼"><a href="#4-2-提供用戶名和密碼" class="headerlink" title="4.2 提供用戶名和密碼"></a>4.2 提供用戶名和密碼</h3><ul><li>將用戶名和密碼發送給該用戶，並提醒他們首次登入後更改密碼。</li></ul><h3 id="4-3-進行測試登入"><a href="#4-3-進行測試登入" class="headerlink" title="4.3 進行測試登入"></a>4.3 進行測試登入</h3><ul><li>用戶訪問上述URL，輸入其用戶名和密碼進行登錄。</li></ul><hr><h2 id="常見設定的IAM群組類型"><a href="#常見設定的IAM群組類型" class="headerlink" title="常見設定的IAM群組類型"></a>常見設定的IAM群組類型</h2><ol><li><strong>Admins</strong>：擁有<code>AdministratorAccess</code>，用於管理所有AWS服務和資源。</li><li><strong>Developers</strong>：擁有<code>PowerUserAccess</code>或自定義策略，允許訪問開發相關的服務，但無法管理帳戶配置。</li><li><strong>ReadOnly</strong>：只能查看所有資源，無法進行任何更改，適用於監控和審計。</li><li><strong>Billing</strong>：擁有<code>Billing</code>訪問權限，允許查看和管理帳單相關信息。</li><li><strong>DatabaseAdmins</strong>：擁有與資料庫服務（如 RDS、DynamoDB）相關的管理權限。</li><li><strong>NetworkAdmins</strong>：能夠管理VPC、子網、路由表和其他網路資源。</li></ol><hr><h2 id="為什麼要設定IAM？"><a href="#為什麼要設定IAM？" class="headerlink" title="為什麼要設定IAM？"></a>為什麼要設定IAM？</h2><ul><li><strong>安全控制</strong>：IAM提供精細化的訪問控制，確保只有授權用戶能夠訪問特定的AWS資源。</li><li><strong>多用戶管理</strong>：允許不同角色的用戶擁有不同的權限設置，有助於團隊協作和帳戶安全性。</li><li><strong>審計和合規</strong>：通過IAM可以記錄和監控誰在何時訪問或修改了哪些資源，確保符合安全和合規需求。</li></ul><hr><h2 id="如果不使用群組設定權限，如何配置？"><a href="#如果不使用群組設定權限，如何配置？" class="headerlink" title="如果不使用群組設定權限，如何配置？"></a>如果不使用群組設定權限，如何配置？</h2><ol><li><p><strong>直接附加策略到用戶</strong>：</p><ul><li>可以直接將權限策略附加到個別用戶，但這種方式在大規模環境中難以管理。</li></ul></li><li><p><strong>使用自定義策略</strong>：</p><ul><li><p>通過編寫JSON格式的策略，可以針對具體需求設置細緻的權限控制。</p></li><li><p><strong>範例</strong>：</p>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;s3:ListBucket&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:s3:::example-bucket&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;s3:GetObject&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:s3:::example-bucket/*&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>策略邊界（Permissions Boundary）</strong>：</p><ul><li>可以使用策略邊界限制IAM用戶或角色的最大權限集，進一步加強安全性。</li></ul></li></ol><hr><h2 id="權限控管的建議"><a href="#權限控管的建議" class="headerlink" title="權限控管的建議"></a>權限控管的建議</h2><ul><li><strong>最小權限原則</strong>：只分配用戶完成任務所需的最少權限，避免安全風險。</li><li><strong>多重身份驗證（MFA）</strong>：為用戶啟用MFA，增加一層安全保護。</li><li><strong>使用標籤（Tags）管理</strong>：對用戶或資源添加標籤，以便於管理和權限分組。</li><li><strong>定期審查和更新</strong>：隨著項目需求的變化，定期檢查和更新IAM設置，確保權限始終與安全需求匹配。</li></ul><hr><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>通過以上步驟，您成功創建並配置了AWS IAM用戶與群組，確保您的AWS帳戶受到適當的訪問控制。進一步管理IAM權限時，務必考慮最小權限原則，靈活使用群組和自定義策略，以提高安全性和可管理性。</p><h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><ul><li><a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/introduction.html">AWS IAM 官方文件</a></li><li><a href="https://aws.amazon.com/security/">AWS 安全最佳實踐</a></li><li><a href="https://docs.aws.amazon.com/organizations/latest/userguide/orgs_introduction.html">如何使用 AWS Organizations 進行多帳戶管理</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>aws</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AWS</tag>
      
      <tag>IAM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01-使用 aws 建設 vpn</title>
    <link href="/devOps/20241030/4035312234/"/>
    <url>/devOps/20241030/4035312234/</url>
    
    <content type="html"><![CDATA[<h2 id="為什麼使用-VPN？"><a href="#為什麼使用-VPN？" class="headerlink" title="為什麼使用 VPN？"></a>為什麼使用 VPN？</h2><p><img src="/images/aws/01-vpn-setup.webp" alt="使用VPN"></p><p>VPN（虛擬私人網路）是一種通過網路加密連接不同網路節點的技術，提供了一種私密、安全的方式來進行網路訪問。當我們需要訪問內部網路資源、加強網路傳輸安全，或在不安全的網路環境中（如公共 Wi-Fi）保護數據時，VPN 就成為了理想的解決方案。</p><p>使用 VPN 的主要優勢包括：</p><ul><li><strong>隱私保護</strong>：所有數據在傳輸過程中被加密，有效防止被竊聽。</li><li><strong>安全性增強</strong>：VPN 建立在加密通道之上，有效降低遭受中間人攻擊的風險。</li><li><strong>遠端訪問</strong>：允許員工從不同地點安全地訪問公司內部資源。</li><li><strong>地區限制突破</strong>：允許從受限地區訪問全球的資源，特別適合需要跨地區工作的團隊。</li></ul><p>在本文章中，我們將使用 AWS EC2 搭建 OpenVPN 伺服器，並結合 VPC、Subnet、Internet Gateway、路由表和安全組等 AWS 網路資源來實現一個完整、安全的 VPN 服務。這樣的架構適合需要安全遠程訪問企業資源或分布式團隊的需求。</p><hr><h2 id="架設步驟"><a href="#架設步驟" class="headerlink" title="架設步驟"></a>架設步驟</h2><h3 id="1-AWS-網路層相關設置"><a href="#1-AWS-網路層相關設置" class="headerlink" title="1. AWS 網路層相關設置"></a>1. AWS 網路層相關設置</h3><ol><li><p>建立 VPC<br> VPC 是 AWS 中專用網路的基礎配置。設定 VPC 時，需設置 IPv4 CIDR 為 <code>10.0.0.0/16</code>，以確保在子網分配中有足夠的 IP 範圍。  </p></li><li><p>設置公共 Subnet<br> 創建子網（Subnet）並命名為 <code>Public-Subnet</code>，將範圍設為 <code>10.0.1.0/24</code>，以允許實例連接至公共網路。</p></li><li><p>配置 Internet Gateway<br> 在 VPC 控制台中創建 Internet Gateway，並將其附加到先前建立的 VPC，讓子網能訪問外部網路。</p></li><li><p>設置路由表<br> 新增一個路由表，將 <code>0.0.0.0/0</code> 的流量路由至 Internet Gateway，以允許所有出站流量。</p></li><li><p>設置安全組<br> 在 AWS 安全組中新增入站規則來允許 UDP 1194 端口（用於 OpenVPN）和 ICMP（用於 ping 測試），並允許所有出站流量。</p></li></ol><hr><h3 id="2-OpenVPN-伺服器設置"><a href="#2-OpenVPN-伺服器設置" class="headerlink" title="2. OpenVPN 伺服器設置"></a>2. OpenVPN 伺服器設置</h3><ol><li><p>啟動 EC2 實例並安裝 OpenVPN<br> 使用 <code>Public-Subnet</code> 啟動 EC2 實例，選擇 Amazon Linux 或 Ubuntu 作為作業系統，並更新系統及安裝 OpenVPN 和 Easy-RSA 工具：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum update -y                        <span class="hljs-comment"># Amazon Linux</span><br>sudo apt update &amp;&amp; sudo apt upgrade -y    <span class="hljs-comment"># Ubuntu</span><br><br>sudo yum install openvpn easy-rsa -y      <span class="hljs-comment"># Amazon Linux</span><br>sudo apt install openvpn easy-rsa -y      <span class="hljs-comment"># Ubuntu</span><br></code></pre></td></tr></table></figure></li><li><p>設置 PKI 和生成憑證<br> 使用 Easy-RSA 在 <code>/etc/openvpn/</code> 位置建立 PKI 環境並生成 CA 憑證、伺服器和客戶端憑證：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /etc/openvpn<br>sudo <span class="hljs-built_in">mkdir</span> -p /etc/openvpn/easy-rsa/keys<br>sudo <span class="hljs-built_in">cp</span> -r /usr/share/easy-rsa/* /etc/openvpn/easy-rsa<br><span class="hljs-built_in">cd</span> /etc/openvpn/easy-rsa<br>sudo ./easyrsa init-pki<br>sudo ./easyrsa build-ca nopass<br>sudo ./easyrsa gen-req server nopass<br>sudo ./easyrsa sign-req server server<br>sudo ./easyrsa gen-dh<br>sudo ./easyrsa build-client-full client1 nopass<br>sudo <span class="hljs-built_in">cp</span> pki/ca.crt pki/private/server.key pki/issued/server.crt pki/dh.pem /etc/openvpn/<br></code></pre></td></tr></table></figure></li><li><p>編輯 OpenVPN 伺服器配置文件<br> 編輯 <code>/etc/openvpn/server/server.conf</code> 配置檔案，設置網段、加密方式、端口等。</p> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs text">port 1194<br>proto udp<br>dev tun<br>ca /etc/openvpn/ca.crt<br>cert /etc/openvpn/server.crt<br>key /etc/openvpn/server.key<br>dh /etc/openvpn/dh.pem<br>server 10.8.0.0 255.255.255.0<br>ifconfig-pool-persist ipp.txt<br>push &quot;redirect-gateway def1 bypass-dhcp&quot;<br>push &quot;dhcp-option DNS 8.8.8.8&quot;<br>push &quot;dhcp-option DNS 8.8.4.4&quot;<br>push &quot;route 10.0.1.0 255.255.255.0&quot;<br>keepalive 10 120<br>data-ciphers AES-256-GCM:AES-128-GCM:AES-256-CBC:AES-128-CBC<br>user nobody<br>group nobody<br>persist-key<br>persist-tun<br>status openvpn-status.log<br>verb 3<br></code></pre></td></tr></table></figure></li><li><p><strong>注意</strong>: 配置 <code>user nobody</code> 和 <code>group nobody</code> 以確保 OpenVPN 以最低權限執行，同時應確認伺服器配置文件的擁有權設定為 <code>nobody</code>，這樣可減少伺服器遭受入侵時的風險。<br> 驗證文件擁有權：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chown</span> nobody:nobody /etc/openvpn/server/server.conf<br><span class="hljs-built_in">ls</span> -l /etc/openvpn/server/server.conf<br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="3-Server-IP-和-NAT-確認"><a href="#3-Server-IP-和-NAT-確認" class="headerlink" title="3. Server IP 和 NAT 確認"></a>3. Server IP 和 NAT 確認</h3><ol><li><p>啟用 IP 轉發<br> 透過下列指令，將 <code>net.ipv4.ip_forward</code> 設為 <code>1</code> 以確保 EC2 可以作為路由器來轉發 VPN 客戶端的流量。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo sysctl -w net.ipv4.ip_forward=1<br></code></pre></td></tr></table></figure></li><li><p>設置 NAT 規則<br> 使用 <code>iptables</code> 設置 NAT 規則，讓來自 VPN 網段 <code>10.8.0.0/24</code> 的流量能夠轉發至公共網路：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j MASQUERADE<br></code></pre></td></tr></table></figure></li><li><p>確認 NAT 設置<br> 安裝 <code>iptables</code> 後可輸入以下指令來檢查 NAT 規則是否正確設定：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo iptables -t nat -F POSTROUTING<br>ip route show<br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="4-線上啟動測試-OpenVPN"><a href="#4-線上啟動測試-OpenVPN" class="headerlink" title="4. 線上啟動測試 OpenVPN"></a>4. 線上啟動測試 OpenVPN</h3><ol><li><p>啟動 OpenVPN 伺服器<br> 開啟 OpenVPN 服務並設置自動啟動。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl start openvpn-server@server.service<br>sudo systemctl <span class="hljs-built_in">enable</span> openvpn-server@server.service<br></code></pre></td></tr></table></figure></li><li><p>檢查伺服器狀態和日誌<br> 確認伺服器已正常啟動並無錯誤。若使用 <code>nobody</code> 權限執行，可用以下指令檢查配置：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">cat</span> /etc/openvpn/server/server.conf<br>sudo systemctl status openvpn-server@server.service<br>sudo journalctl -u openvpn-server@server.service<br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="5-地端啟動測試-OpenVPN"><a href="#5-地端啟動測試-OpenVPN" class="headerlink" title="5. 地端啟動測試 OpenVPN"></a>5. 地端啟動測試 OpenVPN</h3><ol><li><p>下載所需的憑證和設定文件<br> 使用 <code>scp</code> 將伺服器的憑證和配置檔案下載到本地端：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp -i /path/to/your-key.pem ec2-user@&lt;EC2_PUBLIC_IP&gt;:/etc/openvpn/ca.crt .<br>scp -i /path/to/your-key.pem ec2-user@&lt;EC2_PUBLIC_IP&gt;:/etc/openvpn/issued/client1.crt .<br>scp -i /path/to/your-key.pem ec2-user@&lt;EC2_PUBLIC_IP&gt;:/etc/openvpn/private/client1.key .<br></code></pre></td></tr></table></figure></li><li><p>建立 <code>client.ovpn</code> 文件<br> 創建 OpenVPN 配置文件，並填寫伺服器 IP 和憑證信息。</p> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">client<br>dev tun<br>proto udp<br>remote &lt;EC2_PUBLIC_IP&gt; 1194<br>nobind<br>ca ca.crt<br>cert client1.crt<br>key client1.key<br></code></pre></td></tr></table></figure></li><li><p>測試連線<br> 啟動 OpenVPN 客戶端並測試連接。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo openvpn --config client.ovpn<br></code></pre></td></tr></table></figure></li><li><p>確認連線狀況<br> 成功連接後，執行 <code>ping google.com</code> 來測試連線是否正常。</p></li></ol><hr><h3 id="附加注意事項"><a href="#附加注意事項" class="headerlink" title="附加注意事項"></a>附加注意事項</h3><ul><li>確保防火牆和安全組規則正確配置，以允許必要的流量。</li><li>檢查 NAT 規則是否正確，以便來自 VPN 網段的流量能夠通過 EC2 實例訪問互聯網。</li><li>如果使用 <code>iptables</code>，可以考慮是否需要安裝 <code>ufw</code> 作為簡化管理的工具，但通常選擇其中一個即可。</li></ul>]]></content>
    
    
    <categories>
      
      <category>devOps</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AWS</tag>
      
      <tag>VPN</tag>
      
      <tag>OpenVPN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[hexo] Hexo 部署大小寫敏感問題排查與解決指南</title>
    <link href="/blog/20241030/3996696377/"/>
    <url>/blog/20241030/3996696377/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo-部署大小寫敏感問題完整筆記"><a href="#Hexo-部署大小寫敏感問題完整筆記" class="headerlink" title="Hexo 部署大小寫敏感問題完整筆記"></a>Hexo 部署大小寫敏感問題完整筆記</h1><p><img src="/images/hexo/05-hexo-case-sensitive.webp" alt="hexo 新增文章"></p><h2 id="情境描述"><a href="#情境描述" class="headerlink" title="情境描述"></a>情境描述</h2><p>在使用 Hexo 部署 GitHub Pages 的過程中，我們發現資料夾名稱在本地生成為小寫（如 <code>mac</code>），但在 GitHub 上會變回大寫（如 <code>Mac</code>）。這樣的情況會導致網址中大小寫不一致，對搜尋引擎優化（SEO）及現有的搜尋索引造成負面影響。這次異動的範圍其實超級大，尤其考量到之前已部署的頁面已經被搜尋引擎索引。</p><p>具體情境如下：</p><ol><li><p>初始狀況：</p><ul><li>本地 <code>hexo generate</code> 正確生成小寫的資料夾名稱。</li><li>在檢查 GitHub Pages 部署後，發現遠端仍然顯示為大寫的 <code>Mac</code> 資料夾。</li></ul></li><li><p>嘗試直接在 GitHub 上修改：</p><ul><li>我們手動在 GitHub 上將 <code>Mac</code> 資料夾刪除，並嘗試推送更改，這個步驟成功更新了 GitHub 上的資料夾名稱。</li><li>然而，當再次執行 <code>hexo deploy</code> 時，遠端又恢復為大寫的 <code>Mac</code>。</li></ul></li><li><p>分析問題：</p><ul><li>為了解決這個問題，我們先嘗試了使用 <code>rm -rf tags/Mac</code> 來刪除大寫資料夾，再推送確認 GitHub 上資料夾被刪除。</li><li>然後嘗試使用 <code>mv</code> 將 <code>Mac</code> 重命名為小寫的 <code>mac</code>，並確保這些變更已提交並推送。</li><li>但是每次重新執行 <code>hexo generate</code> 後，Hexo 依然生成了大寫的 <code>Mac</code> 資料夾。</li><li>最後，經分析認為可能是 Hexo 部署使用 <code>.deploy_git</code> 資料夾來管理緩存，這可能導致遠端在部署時帶回了之前的大小寫配置。</li><li>同時，Git 對於純大小寫變更無法敏感追蹤，因此可能需要手動強制 Git 認識這些大小寫的變更。</li></ul></li></ol><h3 id="SEO-和搜尋引擎索引的影響"><a href="#SEO-和搜尋引擎索引的影響" class="headerlink" title="SEO 和搜尋引擎索引的影響"></a>SEO 和搜尋引擎索引的影響</h3><p>需要特別注意的是，這樣的網址大小寫異動可能會對搜尋引擎造成以下負面影響：</p><ul><li><strong>搜尋不到已發佈內容</strong>：因為原本的 URL 已被索引，如果網址的大小寫異動或結構變動，搜尋引擎可能會無法正確找到頁面。</li><li><strong>現有索引失效</strong>：搜尋引擎已經索引過的 URL（如 <code>tags/Mac</code>）會因為大小寫變更導致無法正確對應，進而影響網站的搜尋排名和流量。</li><li><strong>網站權重受影響</strong>：若多次更改網址結構或出現 404 錯誤，會讓搜尋引擎認為網站不穩定，可能導致網站權重降低。</li></ul><p>這些問題的影響可能會持續一段時間，直到搜尋引擎重新索引新的 URL。因此，處理這個大小寫問題非常重要，尤其對於長期的網站流量及 SEO 成效。</p><h2 id="問題分析"><a href="#問題分析" class="headerlink" title="問題分析"></a>問題分析</h2><ul><li>Git 對大小寫變更的敏感度較低，在某些系統中（如 macOS）無法正確追蹤到大小寫差異。</li><li><code>.deploy_git</code> 資料夾緩存了之前的部署狀態，Hexo 使用它來維持部署記錄，導致每次 Hexo 部署時恢復為舊的大小寫配置。</li></ul><h2 id="解決方案"><a href="#解決方案" class="headerlink" title="解決方案"></a>解決方案</h2><h3 id="步驟-1：確認-config-yml-配置"><a href="#步驟-1：確認-config-yml-配置" class="headerlink" title="步驟 1：確認 _config.yml 配置"></a>步驟 1：確認 <code>_config.yml</code> 配置</h3><p>首先，檢查 Hexo 的 <code>_config.yml</code> 配置，特別是 <code>permalink</code> 的設定，確保不會影響資料夾的大小寫。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">permalink:</span> <span class="hljs-string">:category/:year:month:day/:abbrlink/</span><br><span class="hljs-attr">pretty_urls:</span><br>    <span class="hljs-attr">trailing_index:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">trailing_html:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="步驟-2：使用-mv-強制變更大小寫"><a href="#步驟-2：使用-mv-強制變更大小寫" class="headerlink" title="步驟 2：使用 mv 強制變更大小寫"></a>步驟 2：使用 <code>mv</code> 強制變更大小寫</h3><p>為了讓 Git 能夠正確追蹤大小寫變更，採用以下方法強制改變資料夾名稱：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 將資料夾臨時重命名為其他名稱</span><br><span class="hljs-built_in">mv</span> tags/Mac tags/mac_temp<br>git add tags/mac_temp<br>git commit -m <span class="hljs-string">&quot;Temporarily rename Mac to mac_temp&quot;</span><br>git push origin main<br><br><span class="hljs-comment"># 再將資料夾名稱更改回小寫的 `mac`</span><br><span class="hljs-built_in">mv</span> tags/mac_temp tags/mac<br>git add tags/mac<br>git commit -m <span class="hljs-string">&quot;Rename mac_temp back to mac&quot;</span><br>git push origin main<br></code></pre></td></tr></table></figure><p>這時候 push 後會發現 github 上面確實 <code>tags/Mac</code> 這些不如預期的網址不見了，但是當我們在做一次 <code>hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</code> 以後會發現現在的 github 這邊之前被我們刪掉的 <code>tags/Mac</code> 又跑出來了。<br>代表問題可能不是 github cache 或者 mac 上的 git 對於大小寫不敏感造成的問題，那跟部署相關的檔案剩下 <code>.deploy_git</code> 了，所以才會有嘗試把 <code>.deploy_git</code> 刪掉重建的選項。</p><h3 id="步驟-3：清空-deploy-git-資料夾"><a href="#步驟-3：清空-deploy-git-資料夾" class="headerlink" title="步驟 3：清空 .deploy_git 資料夾"></a>步驟 3：清空 <code>.deploy_git</code> 資料夾</h3><p>刪除 <code>.deploy_git</code> 資料夾，以防止 Hexo 使用緩存的部署狀態。這樣可以確保下次部署時會重新生成所有文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -rf .deploy_git<br></code></pre></td></tr></table></figure><h3 id="步驟-4：重新生成並部署"><a href="#步驟-4：重新生成並部署" class="headerlink" title="步驟 4：重新生成並部署"></a>步驟 4：重新生成並部署</h3><p>執行以下命令來清理、生成、並重新部署 Hexo 靜態網站，以確保所有檔案已更新為小寫名稱。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo generate<br>hexo deploy<br></code></pre></td></tr></table></figure><h3 id="步驟-5：檢查-GitHub-上的資料夾名稱"><a href="#步驟-5：檢查-GitHub-上的資料夾名稱" class="headerlink" title="步驟 5：檢查 GitHub 上的資料夾名稱"></a>步驟 5：檢查 GitHub 上的資料夾名稱</h3><p>完成部署後，前往 GitHub Repo，確認 <code>tags</code> 資料夾中小寫名稱（如 <code>mac</code>）已正確應用。</p><h2 id="備選方案"><a href="#備選方案" class="headerlink" title="備選方案"></a>備選方案</h2><p>若上述步驟無法解決問題，可考慮以下備選方案：</p><ul><li><strong>使用 GitHub Actions 部署</strong>：透過 GitHub Actions 來自動化部署流程，避免 <code>.deploy_git</code> 緩存問題的影響，並確保每次部署時自動清除舊的部署記錄。</li><li><strong>手動刪除遠端大寫資料夾</strong>：若大寫資料夾持續出現，可以在 <code>[your account].github.io</code> 的 <code>main</code> 分支中手動刪除並推送，確保重新部署時不會出現舊資料夾。</li></ul>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>seo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>00-aws-basic-concept</title>
    <link href="/aws/20241029/1064703203/"/>
    <url>/aws/20241029/1064703203/</url>
    
    <content type="html"><![CDATA[<h2 id="AWS-基本概念與設定流程"><a href="#AWS-基本概念與設定流程" class="headerlink" title="AWS 基本概念與設定流程"></a>AWS 基本概念與設定流程</h2><p>AWS 提供了強大的雲端基礎設施服務，透過合理的設定，可以構建穩定、安全且可擴展的雲端環境。本篇將指導您完成從基本設定到啟用服務的步驟，並詳述背後的概念與常見問題，適合初學者理解與操作。</p><hr><h3 id="1-使用-AWS-Root-帳戶"><a href="#1-使用-AWS-Root-帳戶" class="headerlink" title="1. 使用 AWS Root 帳戶"></a>1. 使用 AWS Root 帳戶</h3><h4 id="1-1-確認帳戶與地區"><a href="#1-1-確認帳戶與地區" class="headerlink" title="1.1 確認帳戶與地區"></a>1.1 確認帳戶與地區</h4><ul><li>登入 AWS 管理控制台，確保使用的是 Root 帳戶或具有必要權限的 IAM 帳戶。</li><li>確認帳戶所選用的地區（Region），這將影響到資源的部署位置與延遲。</li></ul><blockquote><p><strong>注意</strong>：初次設置 AWS 資源時，請選擇距離使用者近的地區以減少網路延遲。</p></blockquote><hr><h3 id="2-VPC-與網路配置"><a href="#2-VPC-與網路配置" class="headerlink" title="2. VPC 與網路配置"></a>2. VPC 與網路配置</h3><h4 id="2-1-VPC-的設置"><a href="#2-1-VPC-的設置" class="headerlink" title="2.1 VPC 的設置"></a>2.1 VPC 的設置</h4><ul><li>VPC（Virtual Private Cloud）是 AWS 中的虛擬網路，可讓您在雲中設定與管理網路資源。</li><li>常見設置包括：<ul><li><strong>公有子網（Public Subnet）</strong>：允許訪問公網（通常需要搭配 IGW）。</li><li><strong>私有子網（Private Subnet）</strong>：限制對外訪問，僅允許內部網路通訊。</li></ul></li></ul><h4 id="2-2-設置-VPC-的步驟"><a href="#2-2-設置-VPC-的步驟" class="headerlink" title="2.2 設置 VPC 的步驟"></a>2.2 設置 VPC 的步驟</h4><ol><li>登入 AWS 控制台，選擇 VPC 服務。</li><li>點選「Create VPC」按鈕，設置名稱與 CIDR block（例如 <code>10.0.0.0/16</code>）。</li><li>建立子網：<ul><li>公有子網：設置可連接 Internet Gateway（IGW）。</li><li>私有子網：設置內部網路資源，無需直接連接 IGW。</li></ul></li></ol><h4 id="2-3-設置-Internet-Gateway-IGW"><a href="#2-3-設置-Internet-Gateway-IGW" class="headerlink" title="2.3 設置 Internet Gateway (IGW)"></a>2.3 設置 Internet Gateway (IGW)</h4><ul><li>IGW 是一種讓 VPC 內的資源訪問公網的設備。</li><li>為 VPC 附加 IGW，使公有子網內的資源能夠訪問外部網路。</li></ul><h4 id="2-4-子網和-CIDR-設定的選擇"><a href="#2-4-子網和-CIDR-設定的選擇" class="headerlink" title="2.4 子網和 CIDR 設定的選擇"></a>2.4 子網和 CIDR 設定的選擇</h4><ul><li>**<code>10.0.0.0/16</code> vs <code>10.0.0.0/24</code>**：前者擁有更多的 IP 範圍，適合大規模環境；後者則適合較小範圍的網路設置。</li><li>設置 VPN 時需注意避免子網與其他公司網段重疊。</li></ul><h4 id="2-5-設置-Security-Groups"><a href="#2-5-設置-Security-Groups" class="headerlink" title="2.5 設置 Security Groups"></a>2.5 設置 Security Groups</h4><ul><li>Security Groups 是 AWS 中的虛擬防火牆，可控制入站與出站流量。<ul><li><strong>入站規則</strong>：控制哪些流量可以進入實例（例如允許 SSH, HTTP&#x2F;HTTPS）。</li><li><strong>出站規則</strong>：控制哪些流量可以從實例發出。</li></ul></li></ul><blockquote><p><strong>建議</strong>：初次設置時，請遵循最小權限原則，只允許必要的流量進出，並根據業務需求調整規則。</p></blockquote><h4 id="2-6-公司網路與私有網路的設定"><a href="#2-6-公司網路與私有網路的設定" class="headerlink" title="2.6 公司網路與私有網路的設定"></a>2.6 公司網路與私有網路的設定</h4><ul><li>建立一個私有子網來存放內部資源，並確保其不直接暴露於公網。</li><li>公有子網則可用於暴露需要對外提供服務的資源，如 Web 伺服器。</li></ul><hr><h3 id="3-建立-EC2-實例"><a href="#3-建立-EC2-實例" class="headerlink" title="3. 建立 EC2 實例"></a>3. 建立 EC2 實例</h3><h4 id="3-1-選擇-EC2-Instance-Type"><a href="#3-1-選擇-EC2-Instance-Type" class="headerlink" title="3.1 選擇 EC2 Instance Type"></a>3.1 選擇 EC2 Instance Type</h4><ul><li>根據您的需求選擇適當的實例類型，如 <code>t2.micro</code>（輕量應用）或 <code>m5.large</code>（更強效能）。</li><li>選擇實例時，應考慮 CPU、內存與 I&#x2F;O 性能。</li></ul><h4 id="3-2-設置-PEM-檔案"><a href="#3-2-設置-PEM-檔案" class="headerlink" title="3.2 設置 PEM 檔案"></a>3.2 設置 PEM 檔案</h4><ul><li>建立新實例時，下載 PEM 檔案以便未來的 SSH 登入。</li><li>PEM 檔案是用於 EC2 SSH 登入的憑證，請妥善保管。</li></ul><h4 id="3-3-配置網路與子網"><a href="#3-3-配置網路與子網" class="headerlink" title="3.3 配置網路與子網"></a>3.3 配置網路與子網</h4><ul><li>指定實例應使用的 VPC 與子網（公有或私有）。</li><li>確認是否需要公開 IP 地址，取決於實例是否需要對外訪問。</li></ul><h4 id="3-4-配置安全群組"><a href="#3-4-配置安全群組" class="headerlink" title="3.4 配置安全群組"></a>3.4 配置安全群組</h4><ul><li>設定 EC2 的安全群組規則，確保開啟必要的端口（如 22 端口用於 SSH，80&#x2F;443 用於 HTTP&#x2F;HTTPS）。</li></ul><h4 id="3-5-啟動服務"><a href="#3-5-啟動服務" class="headerlink" title="3.5 啟動服務"></a>3.5 啟動服務</h4><ul><li><p>啟動實例後，服務通常即為可用狀態。</p></li><li><p>若需進行網路層檢查，請確認 Security Group 的規則與內部防火牆（例如 <code>iptables</code>）設定是否允許所需流量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo iptables -L<br></code></pre></td></tr></table></figure></li><li><p>根據需求進行防火牆規則的開放或限制，確保網路安全與正常訪問。</p></li></ul><hr><h3 id="4-資料儲存設定"><a href="#4-資料儲存設定" class="headerlink" title="4. 資料儲存設定"></a>4. 資料儲存設定</h3><h4 id="4-1-建立與掛載-EBS-Volume"><a href="#4-1-建立與掛載-EBS-Volume" class="headerlink" title="4.1 建立與掛載 EBS Volume"></a>4.1 建立與掛載 EBS Volume</h4><ul><li><p>EBS（Elastic Block Store）是 AWS 的持久性儲存服務。</p><ol><li>建立新的 EBS Volume，選擇大小與磁碟類型。</li><li>使用 CLI 或 AWS 管理控制台將 Volume 附加至指定的 EC2 實例。</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws ec2 attach-volume --volume-id &lt;volume-id&gt; --instance-id &lt;instance-id&gt; --device /dev/xvdf<br></code></pre></td></tr></table></figure><ol start="3"><li>在實例內部格式化並掛載 Volume：</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo mkfs -t xfs /dev/xvdf<br>sudo <span class="hljs-built_in">mkdir</span> /data<br>sudo mount /dev/xvdf /data<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-2-編輯-etc-fstab"><a href="#4-2-編輯-etc-fstab" class="headerlink" title="4.2 編輯 &#x2F;etc&#x2F;fstab"></a>4.2 編輯 &#x2F;etc&#x2F;fstab</h4><ul><li><p>配置開機自動掛載：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/fstab<br>/dev/xvdf  /data  xfs  defaults,nofail  0  2<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="5-監控與維護"><a href="#5-監控與維護" class="headerlink" title="5. 監控與維護"></a>5. 監控與維護</h3><h4 id="5-1-自建-Grafana-監控"><a href="#5-1-自建-Grafana-監控" class="headerlink" title="5.1 自建 Grafana 監控"></a>5.1 自建 Grafana 監控</h4><ul><li>安裝與配置 Prometheus 作為數據來源，並搭配 Grafana 進行可視化監控。<ol><li>安裝 Prometheus 以收集與儲存時間序列數據。</li><li>安裝與配置 Grafana：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install grafana -y<br>sudo systemctl start grafana-server<br>sudo systemctl <span class="hljs-built_in">enable</span> grafana-server<br></code></pre></td></tr></table></figure></li><li>在 Grafana 中添加 Prometheus 來源，並設定所需的儀表板以監控資源使用情況。</li></ol></li></ul><h4 id="5-2-常見監控指標"><a href="#5-2-常見監控指標" class="headerlink" title="5.2 常見監控指標"></a>5.2 常見監控指標</h4><ul><li><strong>CPU 使用率</strong>、<strong>記憶體消耗</strong>、<strong>磁碟 I&#x2F;O</strong>、<strong>網路流量</strong>等。</li><li>定期檢查這些指標，確保系統運行穩定，並及時調整資源配置以應對負載變化。</li></ul><hr><h3 id="6-綜合考量與最佳實踐"><a href="#6-綜合考量與最佳實踐" class="headerlink" title="6. 綜合考量與最佳實踐"></a>6. 綜合考量與最佳實踐</h3><ul><li><strong>最小權限原則</strong>：只允許必要的網路流量進出。</li><li><strong>資源標籤管理</strong>：給資源加上標籤，有助於管理與權限分配。</li><li><strong>監控與審計</strong>：使用自建的 Grafana、Prometheus 監控系統，確保資源使用符合需求，並能夠及時排查問題。</li></ul><hr><p>以上為基本的 AWS 操作與設置流程，涵蓋網路配置、實例創建與存儲管理。希望能夠幫助您在實踐中掌握 AWS 的核心概念與運用，進一步深化理解與應用。</p>]]></content>
    
    
    <categories>
      
      <category>aws</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AWS</tag>
      
      <tag>EC2</tag>
      
      <tag>VPC</tag>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日覆盤：建立習慣、選擇工具與工作方法</title>
    <link href="/personal-update/20241025/3273636124/"/>
    <url>/personal-update/20241025/3273636124/</url>
    
    <content type="html"><![CDATA[<h1 id="每日覆盤：建立習慣、選擇工具與工作方法"><a href="#每日覆盤：建立習慣、選擇工具與工作方法" class="headerlink" title="每日覆盤：建立習慣、選擇工具與工作方法"></a>每日覆盤：建立習慣、選擇工具與工作方法</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><img src="/images/blog/daily-retrospective-tools-and-methods.webp" alt="每日覆盤"><br>在日常開發工作中，隨著項目日漸複雜，保持反思與調整顯得尤為重要。我在嘗試多種生產力管理方法後，最終決定通過建立每日覆盤的習慣來提升自我管理，進而促進工作效率和長期目標的達成。這篇文章將分享我的覆盤思路、選擇的工具、長期目標以及具體的工作方法。</p><h2 id="每日覆盤的目的"><a href="#每日覆盤的目的" class="headerlink" title="每日覆盤的目的"></a>每日覆盤的目的</h2><p>每日覆盤不僅僅是回顧一天的工作，更多的是一種反思和調整的過程。透過每天總結成就、挑戰和明天的計劃，覆盤可以幫助我們：</p><ol><li>持續改進工作流程與效率。</li><li>增強對工作的掌控感與自信心。</li><li>通過小步快跑的方式，逐步達成長期目標。</li></ol><h2 id="覆盤的框架"><a href="#覆盤的框架" class="headerlink" title="覆盤的框架"></a>覆盤的框架</h2><p>在覆盤的過程中，我關注以下五個核心點：</p><ol><li><strong>今日成就</strong>：記錄當天完成的主要工作或目標，無論大小，都可以成為一項成就。</li><li><strong>遇到的挑戰</strong>：反思當天遇到的困難或卡住的地方，有助於找到改進的機會與需要注意的問題。</li><li><strong>明天的目標</strong>：設定具體的行動計劃，讓下一天的工作更加專注與高效。</li><li><strong>情緒與反思</strong>：反思當天的情緒狀態，並思考情緒背後的原因，保持心理平衡，減少長期壓力。</li><li><strong>建議</strong>：根據當天的情況，記錄具體的建議，這些建議可以用於調整未來的策略或行動。</li></ol><h2 id="工具選擇"><a href="#工具選擇" class="headerlink" title="工具選擇"></a>工具選擇</h2><h3 id="Notion"><a href="#Notion" class="headerlink" title="Notion"></a>Notion</h3><p>為了更好地記錄和管理每日覆盤，我選擇了 <strong>Notion</strong> 作為主要工具。Notion 的靈活性和跨平台支持讓我隨時隨地進行覆盤，並結合日曆、表格等功能進行長期追蹤。使用 Notion，我可以：</p><ul><li>建立每日覆盤的模板，快速進行內容填寫。</li><li>將每週、每月的覆盤進行彙總，分析自己的工作模式和進展。</li><li>使用日曆視圖方便地查看每一天的覆盤狀況。</li></ul><h3 id="其他考慮的工具"><a href="#其他考慮的工具" class="headerlink" title="其他考慮的工具"></a>其他考慮的工具</h3><p>在選擇 Notion 之前，我也曾探索過其他工具，如 Google Keep 和 Apple Notes 等，這些工具適合快速記錄與簡單反思。如果您需要更輕量化的解決方案，也可以考慮這些選擇。</p><h2 id="如何進行覆盤"><a href="#如何進行覆盤" class="headerlink" title="如何進行覆盤"></a>如何進行覆盤</h2><p>以下是我在 Notion 中常用的覆盤模板：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">### 今日成就：</span><br><span class="hljs-bullet">-</span> 記錄今天完成的重要工作或目標。<br><span class="hljs-code">    </span><br><span class="hljs-code">### 遇到的挑戰：</span><br><span class="hljs-code">- 描述今天遇到的困難或需要改進的地方。</span><br><span class="hljs-code"></span><br><span class="hljs-section">### 明天的目標：</span><br><span class="hljs-bullet">-</span> 為明天設定具體的行動目標。<br><br><span class="hljs-section">### 今天的情緒或反思：</span><br><span class="hljs-bullet">-</span> 反思今天的情緒狀態與整體感受，並思考其原因。<br><br><span class="hljs-section">### 建議：</span><br><span class="hljs-bullet">-</span> 根據當天情況提出的具體建議，幫助未來改進。<br></code></pre></td></tr></table></figure><p>這樣的覆盤模板能幫助我保持清晰的思路，在每天結束時進行深度反思，從而提升工作效率和心態管理。</p><h2 id="每週覆盤"><a href="#每週覆盤" class="headerlink" title="每週覆盤"></a>每週覆盤</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>每週覆盤的目的是檢視整週的進展、總結成功與挑戰，並為下週設置具體的行動目標。透過每週回顧，能夠更好地掌握長期目標的實現狀況。</p><h3 id="覆盤要點"><a href="#覆盤要點" class="headerlink" title="覆盤要點"></a>覆盤要點</h3><ol><li><strong>本週成就</strong>：記錄本週完成的所有主要任務或達成的目標。</li><li><strong>遇到的挑戰</strong>：反思本週面臨的困難，尋找改進的機會。</li><li><strong>下週計劃</strong>：設定下週的目標與行動計劃，讓工作更加有條不紊。</li><li><strong>情緒狀態回顧</strong>：反思一週的情緒變化，並檢視壓力的來源與應對方式。</li><li><strong>改善建議</strong>：總結可以改善的地方，為下週提供具體建議。</li></ol><h3 id="覆盤模板"><a href="#覆盤模板" class="headerlink" title="覆盤模板"></a>覆盤模板</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">### 本週成就：</span><br><span class="hljs-bullet">-</span> 本週完成的主要工作或目標。<br><br><span class="hljs-section">### 遇到的挑戰：</span><br><span class="hljs-bullet">-</span> 本週遇到的困難或需要改進的地方。<br><br><span class="hljs-section">### 下週的目標：</span><br><span class="hljs-bullet">-</span> 為下週設定的具體行動計劃。<br><br><span class="hljs-section">### 情緒與反思：</span><br><span class="hljs-bullet">-</span> 本週的情緒狀態回顧與原因分析。<br><br><span class="hljs-section">### 建議與改善：</span><br><span class="hljs-bullet">-</span> 根據本週情況提出的具體改善建議。<br></code></pre></td></tr></table></figure><h2 id="每月覆盤"><a href="#每月覆盤" class="headerlink" title="每月覆盤"></a>每月覆盤</h2><h3 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h3><p>每月覆盤有助於檢視長期進展，了解是否朝著大目標穩步前進。通過月度覆盤，可以評估整個月的工作模式、挑戰和個人成長。</p><h3 id="覆盤要點-1"><a href="#覆盤要點-1" class="headerlink" title="覆盤要點"></a>覆盤要點</h3><ol><li><strong>本月成就</strong>：列出月度完成的重要目標或項目。</li><li><strong>挑戰與學習</strong>：反思本月遇到的主要挑戰，以及從中學到的教訓。</li><li><strong>下月目標</strong>：為下月設定具體的目標，並細化行動計劃。</li><li><strong>長期目標進展</strong>：檢視長期目標的達成情況，並調整策略以適應新挑戰。</li><li><strong>情緒與健康狀態回顧</strong>：反思整月的心理狀態，確保平衡工作與生活。</li></ol><h3 id="覆盤模板-1"><a href="#覆盤模板-1" class="headerlink" title="覆盤模板"></a>覆盤模板</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">### 本月成就：</span><br><span class="hljs-bullet">-</span> 本月完成的主要工作或目標。<br><br><span class="hljs-section">### 遇到的挑戰：</span><br><span class="hljs-bullet">-</span> 本月遇到的困難或需要改進的地方。<br><br><span class="hljs-section">### 下月的目標：</span><br><span class="hljs-bullet">-</span> 為下月設定的具體行動計劃。<br><br><span class="hljs-section">### 長期目標進展：</span><br><span class="hljs-bullet">-</span> 回顧長期目標的達成情況，並調整策略。<br><br><span class="hljs-section">### 情緒與健康反思：</span><br><span class="hljs-bullet">-</span> 整個月的情緒與健康狀態回顧。<br></code></pre></td></tr></table></figure><h2 id="長期目標"><a href="#長期目標" class="headerlink" title="長期目標"></a>長期目標</h2><p>建立每日覆盤的最終目標是：</p><ol><li><strong>保持自我反思的習慣</strong>：通過每日覆盤養成反思習慣，逐漸將其內化，並在更長期的目標規劃中運用這些反思結果。</li><li><strong>增強自信心</strong>：通過日積月累的成就記錄和挑戰解決，增強對工作的掌控感，提升自信心。</li><li><strong>推動工作項目的穩定進展</strong>：覆盤習慣可以幫助我及時調整工作節奏，提升每一個階段的質量和效率。</li></ol><h2 id="建議與反饋"><a href="#建議與反饋" class="headerlink" title="建議與反饋"></a>建議與反饋</h2><ol><li><strong>建立穩定的反思習慣</strong>：每日覆盤的習慣有助於提升自我覺察，減少壓力積累，並促進心理健康和工作穩定性。</li><li><strong>促進長期成長</strong>：短期目標和長期目標的結合能夠推動長期進步，並通過數據積累進行分析和調整。</li><li><strong>靈活選擇工具</strong>：使用像 Notion 這樣的工具，讓您在記錄覆盤的同時，結合日曆與任務管理，進行更系統化的工作管理。</li><li><strong>增強自信與掌控感</strong>：每日記錄和反思有助於逐步提升自信心，並在面對困難時回顧過去的成就，從中獲得激勵。</li><li><strong>與他人分享經驗</strong>：透過博客分享覆盤經驗，不僅幫助您深化反思習慣，還能與他人交流經驗，促進共同成長。</li></ol><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>建立每日覆盤習慣是我提升工作效率與自我成長的一項重要策略。通過選擇合適的工具，並設置一個簡單且有效的覆盤框架，我希望能在未來持續進步，達成更大的目標。如果您也在尋找提升自我管理的方法，不妨嘗試每日覆盤，或許會帶來意想不到的收穫！</p>]]></content>
    
    
    <categories>
      
      <category>個人成長</category>
      
    </categories>
    
    
    <tags>
      
      <tag>覆盤</tag>
      
      <tag>生產力</tag>
      
      <tag>個人成長</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[express][02]ESLint, Typings, Tests 設定</title>
    <link href="/express/web-develop/20241021/3915171955/"/>
    <url>/express/web-develop/20241021/3915171955/</url>
    
    <content type="html"><![CDATA[<h1 id="ESLint-Typings-Tests-設定"><a href="#ESLint-Typings-Tests-設定" class="headerlink" title="ESLint, Typings, Tests 設定"></a>ESLint, Typings, Tests 設定</h1><h2 id="0-基本介紹"><a href="#0-基本介紹" class="headerlink" title="0. 基本介紹"></a>0. 基本介紹</h2><p>在專案開發中，統一的代碼風格、明確的型別檢查以及穩定的測試流程，能夠有效提升專案的可維護性，並避免因不同開發者的工作環境差異導致不必要的版本問題。以下是我們設定 ESLint、Typings 和測試環境的步驟。</p><ul><li><strong>ESLint</strong> 用來保持一致的代碼風格，避免開發過程中不同開發者之間因代碼風格不同而引起的變動。</li><li><strong>Typings</strong> 資料夾的設置是為了清晰管理型別定義，讓程式碼更加自我說明，並減少額外文件的依賴。</li><li><strong>Tests</strong> 資料夾則是專門用來撰寫測試，確保專案的每個功能都能被有效測試，避免隱藏錯誤。</li></ul><hr><h2 id="1-資料夾結構"><a href="#1-資料夾結構" class="headerlink" title="1. 資料夾結構"></a>1. 資料夾結構</h2><p>做完以後最終的資料夾結構如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ tree<br>.<br>├── coverage<br>├── eslint.config.mjs<br>├── jest.config.ts<br>├── package.json<br>├── pnpm-lock.yaml<br>├── public<br>│   ├── images<br>│   ├── index.html<br>│   ├── javascripts<br>│   └── stylesheets<br>│       └── style.css<br>├── src<br>│   ├── app.ts<br>│   ├── bin<br>│   │   └── www.ts<br>│   └── routes<br>│       ├── index.ts<br>│       └── users.ts<br>├── tests<br>│   └── routes<br>│       ├── index.test.ts<br>│       └── users.test.ts<br>├── tsconfig.json<br>└── typings<br>    └── routes<br>        ├── index.ts<br>        └── users.ts<br></code></pre></td></tr></table></figure><hr><h2 id="2-ESLint-設定"><a href="#2-ESLint-設定" class="headerlink" title="2. ESLint 設定"></a>2. ESLint 設定</h2><h3 id="2-1-安裝-ESLint-及相關套件"><a href="#2-1-安裝-ESLint-及相關套件" class="headerlink" title="2.1 安裝 ESLint 及相關套件"></a>2.1 安裝 ESLint 及相關套件</h3><p>使用以下指令安裝 ESLint 和 TypeScript 相關的插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm add -D eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint-config-airbnb-base eslint-config-prettier eslint-plugin-import eslint-plugin-node eslint-plugin-prettier prettier @eslint/js typescript-eslint<br></code></pre></td></tr></table></figure><h3 id="2-2-初始化-ESLint-配置"><a href="#2-2-初始化-ESLint-配置" class="headerlink" title="2.2 初始化 ESLint 配置"></a>2.2 初始化 ESLint 配置</h3><p>使用 <code>eslint --init</code> 來初始化 ESLint 配置（最新版本可能與以往不同，生成 <code>.mjs</code> 格式的配置文件）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm <span class="hljs-built_in">exec</span> eslint --init<br></code></pre></td></tr></table></figure><p>如果選項有所不同，以下是新的初始化步驟：</p><ul><li><p><strong>How would you like to use ESLint?</strong></p><ul><li>選擇：<code>To check syntax and find problems</code></li></ul></li><li><p><strong>What type of modules does your project use?</strong></p><ul><li>選擇：<code>esm</code></li></ul></li><li><p><strong>Which framework does your project use?</strong></p><ul><li>選擇：<code>none</code></li></ul></li><li><p><strong>Does your project use TypeScript?</strong></p><ul><li>選擇：<code>typescript</code></li></ul></li><li><p><strong>Where does your code run?</strong></p><ul><li>選擇：<code>node</code></li></ul></li></ul><p>ESLint 會根據這些選項生成一個新的配置文件 <code>eslint.config.mjs</code>。</p><h3 id="2-3-ESLint-配置文件-eslint-config-mjs"><a href="#2-3-ESLint-配置文件-eslint-config-mjs" class="headerlink" title="2.3 ESLint 配置文件 eslint.config.mjs"></a>2.3 ESLint 配置文件 <code>eslint.config.mjs</code></h3><p>生成的 <code>eslint.config.mjs</code> 可能類似於以下內容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> globals <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;globals&quot;</span>;<br><span class="hljs-keyword">import</span> pluginJs <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@eslint/js&quot;</span>;<br><span class="hljs-keyword">import</span> tseslint <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;typescript-eslint&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [<br>  &#123; <span class="hljs-attr">files</span>: [<span class="hljs-string">&quot;**/*.&#123;js,mjs,cjs,ts&#125;&quot;</span>] &#125;,<br>  &#123; <span class="hljs-attr">languageOptions</span>: &#123; <span class="hljs-attr">globals</span>: globals.<span class="hljs-property">browser</span> &#125; &#125;,<br>  pluginJs.<span class="hljs-property">configs</span>.<span class="hljs-property">recommended</span>,<br>  ...tseslint.<span class="hljs-property">configs</span>.<span class="hljs-property">recommended</span>,<br>  &#123;<br>    <span class="hljs-attr">rules</span>: &#123;<br>      <span class="hljs-string">&quot;@typescript-eslint/no-unused-vars&quot;</span>: [<span class="hljs-string">&quot;error&quot;</span>, &#123; <span class="hljs-string">&quot;argsIgnorePattern&quot;</span>: <span class="hljs-string">&quot;^_&quot;</span> &#125;]<br>    &#125;<br>  &#125;<br>];<br></code></pre></td></tr></table></figure><h3 id="2-4-在-package-json-中添加-ESLint-指令"><a href="#2-4-在-package-json-中添加-ESLint-指令" class="headerlink" title="2.4 在 package.json 中添加 ESLint 指令"></a>2.4 在 <code>package.json</code> 中添加 ESLint 指令</h3><p>在 <code>package.json</code> 中新增 ESLint 的執行指令：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;lint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;eslint &#x27;src/**/*.ts&#x27;&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>這樣，你可以使用 <code>pnpm run lint</code> 來執行代碼檢查。<br>基本上會有兩個錯誤：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh">❯ pnpm run lint<br><br>&gt; express-ts-proto@0.0.0 lint /Users/**yourname**/work/express-ts-proto<br>&gt; eslint <span class="hljs-string">&#x27;src/**/*.ts&#x27;</span><br><br><br>/Users/**yourname**/work/express-ts-proto/src/app.ts<br>  2:10  error  <span class="hljs-string">&#x27;join&#x27;</span> is defined but never used  @typescript-eslint/no-unused-vars<br><br>/Users/**yourname**/work/express-ts-proto/src/bin/www.ts<br>  27:25  error  Unexpected any. Specify a different <span class="hljs-built_in">type</span>  @typescript-eslint/no-explicit-any<br><br>✖ 2 problems (2 errors, 0 warnings)<br><br> ELIFECYCLE  Command failed with <span class="hljs-built_in">exit</span> code 1.<br></code></pre></td></tr></table></figure><p><code>join</code> 的錯誤只需在 <code>app.ts</code> 中移除 <code>join</code>，而另一個錯誤則需要更多的調整。</p><hr><h2 id="3-Error-Handling-更新"><a href="#3-Error-Handling-更新" class="headerlink" title="3. Error Handling 更新"></a>3. Error Handling 更新</h2><h3 id="3-1-更新-src-bin-www-ts-中的錯誤處理"><a href="#3-1-更新-src-bin-www-ts-中的錯誤處理" class="headerlink" title="3.1 更新 src/bin/www.ts 中的錯誤處理"></a>3.1 更新 <code>src/bin/www.ts</code> 中的錯誤處理</h3><p>在 <code>src/bin/www.ts</code> 中，將 <code>any</code> 修改為 <code>NodeJS.ErrnoException</code> 以避免使用 <code>any</code> 類型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">onError</span> = (<span class="hljs-params">error: NodeJS.ErrnoException</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (error.<span class="hljs-property">syscall</span> !== <span class="hljs-string">&#x27;listen&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> error;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> bind = <span class="hljs-keyword">typeof</span> port === <span class="hljs-string">&#x27;string&#x27;</span><br>    ? <span class="hljs-string">&#x27;Pipe &#x27;</span> + port<br>    : <span class="hljs-string">&#x27;Port &#x27;</span> + port;<br><br>  <span class="hljs-comment">// handle specific listen errors with friendly messages</span><br>  <span class="hljs-keyword">switch</span> (error.<span class="hljs-property">code</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;EACCES&#x27;</span>:<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(bind + <span class="hljs-string">&#x27; requires elevated privileges&#x27;</span>);<br>      process.<span class="hljs-title function_">exit</span>(<span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;EADDRINUSE&#x27;</span>:<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(bind + <span class="hljs-string">&#x27; is already in use&#x27;</span>);<br>      process.<span class="hljs-title function_">exit</span>(<span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">throw</span> error;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h2 id="4-Typings-設定"><a href="#4-Typings-設定" class="headerlink" title="4. Typings 設定"></a>4. Typings 設定</h2><h3 id="4-1-建立-src-typings-routes-index-ts-和-src-typings-routes-users-ts"><a href="#4-1-建立-src-typings-routes-index-ts-和-src-typings-routes-users-ts" class="headerlink" title="4.1 建立 src/typings/routes/index.ts 和 src/typings/routes/users.ts"></a>4.1 建立 <code>src/typings/routes/index.ts</code> 和 <code>src/typings/routes/users.ts</code></h3><p>使用以下指令建立 <code>src/typings</code> 資料夾來管理路由相關的型別定義：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p src/typings/routes<br><span class="hljs-built_in">touch</span> src/typings/routes/index.ts src/typings/routes/users.ts<br></code></pre></td></tr></table></figure><h3 id="4-2-在-src-typings-routes-index-ts-中定義路由的-enum"><a href="#4-2-在-src-typings-routes-index-ts-中定義路由的-enum" class="headerlink" title="4.2 在 src/typings/routes/index.ts 中定義路由的 enum"></a>4.2 在 <code>src/typings/routes/index.ts</code> 中定義路由的 <code>enum</code></h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// src/typings/routes/index.ts</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">IndexRoutePaths</span> &#123;<br>  <span class="hljs-variable constant_">HOME</span> = <span class="hljs-string">&#x27;/&#x27;</span>,<br>  <span class="hljs-variable constant_">USERS</span> = <span class="hljs-string">&#x27;/users&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-在-src-typings-routes-users-ts-中定義與-users-路由相關的-enum"><a href="#4-3-在-src-typings-routes-users-ts-中定義與-users-路由相關的-enum" class="headerlink" title="4.3 在 src/typings/routes/users.ts 中定義與 users 路由相關的 enum"></a>4.3 在 <code>src/typings/routes/users.ts</code> 中定義與 <code>users</code> 路由相關的 <code>enum</code></h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// src/typings/routes/users.ts</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">UserRoutePaths</span> &#123;<br>  <span class="hljs-variable constant_">INDEX</span> = <span class="hljs-string">&#x27;/&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-確保-tsconfig-json-包含-src-typings-和-tests"><a href="#4-4-確保-tsconfig-json-包含-src-typings-和-tests" class="headerlink" title="4.4 確保 tsconfig.json 包含 src/typings 和 tests"></a>4.4 確保 <code>tsconfig.json</code> 包含 <code>src/typings</code> 和 <code>tests</code></h3><p>在 <code>tsconfig.json</code> 中確認 <code>include</code> 部分包含 <code>src/typings/</code> 和 <code>tests/</code> 資料夾：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;es2016&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;commonjs&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;rootDir&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;outDir&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./dist&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;esModuleInterop&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;forceConsistentCasingInFileNames&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;strict&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;skipLibCheck&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;src/**/*&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;tests/**/*&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;typings/**/*&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><hr><h2 id="5-Routes-設定"><a href="#5-Routes-設定" class="headerlink" title="5. Routes 設定"></a>5. Routes 設定</h2><h3 id="5-1-更新-src-routes-index-ts"><a href="#5-1-更新-src-routes-index-ts" class="headerlink" title="5.1 更新 src/routes/index.ts"></a>5.1 更新 <code>src/routes/index.ts</code></h3><p>在 <code>src/routes/index.ts</code> 中使用 <code>enum</code> 來定義路徑：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Router</span>, <span class="hljs-title class_">Request</span>, <span class="hljs-title class_">Response</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;express&#x27;</span>;<br><span class="hljs-keyword">import</span> usersRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./users&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">IndexRoutePaths</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../typings/routes/index&#x27;</span>;<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title class_">Router</span>();<br><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-title class_">IndexRoutePaths</span>.<span class="hljs-property">HOME</span>, <span class="hljs-function">(<span class="hljs-params">req: Request, res: Response</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Welcome to the Home Page&#x27;</span>);<br>&#125;);<br>router.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">IndexRoutePaths</span>.<span class="hljs-property">USERS</span>, usersRouter);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure><h3 id="5-2-更新-src-routes-users-ts"><a href="#5-2-更新-src-routes-users-ts" class="headerlink" title="5.2 更新 src/routes/users.ts"></a>5.2 更新 <code>src/routes/users.ts</code></h3><p>在 <code>src/routes/users.ts</code> 中使用 <code>enum</code> 來定義路徑：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Router</span>, <span class="hljs-title class_">Request</span>, <span class="hljs-title class_">Response</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;express&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">UserRoutePaths</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../typings/routes/users&#x27;</span>;<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title class_">Router</span>();<br><br><span class="hljs-comment">/* GET users listing. */</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-title class_">UserRoutePaths</span>.<span class="hljs-property">INDEX</span>, <span class="hljs-function">(<span class="hljs-params">req: Request, res: Response</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;respond with a resource&#x27;</span>);<br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure><hr><h2 id="6-Jest-設定"><a href="#6-Jest-設定" class="headerlink" title="6. Jest 設定"></a>6. Jest 設定</h2><h3 id="6-1-使用-Jest-初始化"><a href="#6-1-使用-Jest-初始化" class="headerlink" title="6.1 使用 Jest 初始化"></a>6.1 使用 Jest 初始化</h3><p>你可以使用以下指令初始化 Jest 設定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm <span class="hljs-built_in">exec</span> jest --init<br></code></pre></td></tr></table></figure><h3 id="6-2-初始化步驟"><a href="#6-2-初始化步驟" class="headerlink" title="6.2 初始化步驟"></a>6.2 初始化步驟</h3><p>選擇以下選項來初始化 Jest 設定：</p><ol><li><strong>Would you like to use Jest when running “test” script in “package.json”?</strong><ul><li>選擇：<code>Yes</code></li></ul></li><li><strong>Would you like to use Typescript for the configuration file?</strong><ul><li>選擇：<code>Yes</code></li></ul></li><li><strong>Choose the test environment that will be used for testing</strong><ul><li>選擇：<code>node</code></li></ul></li><li><strong>Do you want Jest to add coverage reports?</strong><ul><li>選擇：<code>Yes</code></li></ul></li><li><strong>Which provider should be used to instrument code for coverage?</strong><ul><li>選擇：<code>v8</code></li></ul></li><li><strong>Automatically clear mock calls, instances, contexts and results before every test?</strong><ul><li>選擇：<code>No</code></li></ul></li></ol><p>最終，Jest 會修改 <code>package.json</code> 並生成 <code>jest.config.ts</code> 文件。</p><h3 id="6-3-更新-jest-config-ts"><a href="#6-3-更新-jest-config-ts" class="headerlink" title="6.3 更新 jest.config.ts"></a>6.3 更新 <code>jest.config.ts</code></h3><p>以下是 Jest 的配置內容：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> &#123;<span class="hljs-title class_">Config</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jest&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">config</span>: <span class="hljs-title class_">Config</span> = &#123;<br>  <span class="hljs-attr">clearMocks</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">collectCoverage</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">collectCoverageFrom</span>: [<span class="hljs-string">&#x27;src/**/*.ts&#x27;</span>],<br>  <span class="hljs-attr">coverageDirectory</span>: <span class="hljs-string">&quot;coverage&quot;</span>,<br>  <span class="hljs-attr">coverageProvider</span>: <span class="hljs-string">&quot;v8&quot;</span>,<br>  <span class="hljs-attr">preset</span>: <span class="hljs-string">&#x27;ts-jest&#x27;</span>,<br>  <span class="hljs-attr">testEnvironment</span>: <span class="hljs-string">&#x27;node&#x27;</span>,<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> config;<br></code></pre></td></tr></table></figure><h3 id="6-4-在-package-json-中添加測試指令"><a href="#6-4-在-package-json-中添加測試指令" class="headerlink" title="6.4 在 package.json 中添加測試指令"></a>6.4 在 <code>package.json</code> 中添加測試指令</h3><p>在 <code>package.json</code> 中添加 Jest 測試指令：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;jest&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="6-5-建立-tests-資料夾"><a href="#6-5-建立-tests-資料夾" class="headerlink" title="6.5 建立 tests 資料夾"></a>6.5 建立 <code>tests</code> 資料夾</h3><p>使用以下指令建立 <code>tests/</code> 資料夾來撰寫測試：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> tests<br><span class="hljs-built_in">mkdir</span> tests/routes<br><span class="hljs-built_in">touch</span> tests/routes/index.test.ts<br><span class="hljs-built_in">touch</span> tests/routes/users.test.ts<br></code></pre></td></tr></table></figure><h3 id="6-6-撰寫測試文件"><a href="#6-6-撰寫測試文件" class="headerlink" title="6.6 撰寫測試文件"></a>6.6 撰寫測試文件</h3><p>在 <code>tests/routes/index.test.ts</code> 中撰寫基本測試：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;supertest&#x27;</span>;<br><span class="hljs-keyword">import</span> app <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../src/app&#x27;</span>;<br><br><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;GET /&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;should return Welcome to the Home Page&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">request</span>(app).<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>);<br>    <span class="hljs-title function_">expect</span>(res.<span class="hljs-property">statusCode</span>).<span class="hljs-title function_">toEqual</span>(<span class="hljs-number">200</span>);<br>    <span class="hljs-title function_">expect</span>(res.<span class="hljs-property">text</span>).<span class="hljs-title function_">toContain</span>(<span class="hljs-string">&#x27;Welcome to the Home Page&#x27;</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在 <code>tests/routes/users.test.ts</code> 中撰寫基本測試：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;supertest&#x27;</span>;<br><span class="hljs-keyword">import</span> app <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../src/app&#x27;</span>;<br><br><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;GET /users&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;should return Welcome to the Home Page&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">request</span>(app).<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/users&#x27;</span>);<br>    <span class="hljs-title function_">expect</span>(res.<span class="hljs-property">statusCode</span>).<span class="hljs-title function_">toEqual</span>(<span class="hljs-number">200</span>);<br>    <span class="hljs-title function_">expect</span>(res.<span class="hljs-property">text</span>).<span class="hljs-title function_">toContain</span>(<span class="hljs-string">&#x27;respond with a resource&#x27;</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="6-7-測試結果"><a href="#6-7-測試結果" class="headerlink" title="6.7 測試結果"></a>6.7 測試結果</h3><p>當所有測試通過後，使用以下指令可以運行測試並檢查覆蓋率：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm run <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>測試成功結果應如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sh">❯ pnpm run <span class="hljs-built_in">test</span><br><br>&gt; express-ts-proto@0.0.0 <span class="hljs-built_in">test</span> /Users/**yourname**/work/express-ts-proto<br>&gt; jest<br><br>  PASS  tests/routes/index.test.ts<br>GET / 200 1.224 ms - 24<br>  PASS  tests/routes/users.test.ts<br>GET /users 200 1.116 ms - 23<br>------------|---------|----------|---------|---------|-------------------<br>File        | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line <span class="hljs-comment">#s </span><br>------------|---------|----------|---------|---------|-------------------<br>All files   |   33.58 |    66.66 |       0 |   33.58 |                   <br>  src        |     100 |      100 |     100 |     100 |                   <br>  app.ts    |     100 |      100 |     100 |     100 |                   <br>  src/bin    |       0 |        0 |       0 |       0 |                   <br>  www.ts    |       0 |        0 |       0 |       0 | 1-89              <br>  src/routes |     100 |      100 |     100 |     100 |                   <br>  index.ts  |     100 |      100 |     100 |     100 |                   <br>  users.ts  |     100 |      100 |     100 |     100 |                   <br>------------|---------|----------|---------|---------|-------------------<br><br>Test Suites: 2 passed, 2 total<br>Tests:       2 passed, 2 total<br>Snapshots:   0 total<br>Time:        1.953 s, estimated 2 s<br>Ran all <span class="hljs-built_in">test</span> suites.<br></code></pre></td></tr></table></figure><hr><h2 id="7-測試-www-ts-的計畫"><a href="#7-測試-www-ts-的計畫" class="headerlink" title="7 測試 www.ts 的計畫"></a>7 測試 <code>www.ts</code> 的計畫</h2><p>目前還沒有針對 <code>src/bin/www.ts</code> 編寫測試，但未來可能會考慮撰寫相關測試來覆蓋伺服器啟動的場景。可能的測試項目包括：</p><ol><li><strong>伺服器成功啟動</strong>：確認伺服器可以在指定的端口上啟動。</li><li><strong>處理端口被佔用的錯誤</strong>：模擬 <code>EADDRINUSE</code> 錯誤，確保正確處理。</li><li><strong>處理權限不足的錯誤</strong>：模擬 <code>EACCES</code> 錯誤，檢查應用是否正確終止。</li></ol><h4 id="為什麼測試-www-ts"><a href="#為什麼測試-www-ts" class="headerlink" title="為什麼測試 www.ts"></a>為什麼測試 <code>www.ts</code></h4><ol><li><strong>伺服器啟動流程的關鍵性</strong>：<ul><li>負責 PORT 配置、HTTP 伺服器創建、錯誤處理邏輯（如 <code>EACCES</code>、<code>EADDRINUSE</code>）。</li></ul></li><li><strong>測試覆蓋率的完整性</strong>：<ul><li>提升測試覆蓋率，確保應用穩定。</li></ul></li><li><strong>錯誤處理邏輯驗證</strong>：<ul><li>檢查伺服器啟動錯誤處理是否正確運作。</li></ul></li></ol><h4 id="為什麼不測試-www-ts"><a href="#為什麼不測試-www-ts" class="headerlink" title="為什麼不測試 www.ts"></a>為什麼不測試 <code>www.ts</code></h4><ol><li><strong>重複測試</strong>：<ul><li>啟動邏輯已在 <code>app.ts</code> 及路由測試中覆蓋。</li></ul></li><li><strong>依賴伺服器狀態</strong>：<ul><li>測試伺服器端口增加測試複雜度及環境依賴。</li></ul></li></ol><h4 id="建議"><a href="#建議" class="headerlink" title="建議"></a>建議</h4><ul><li>如果伺服器啟動邏輯重要，測試錯誤處理邏輯是有價值的。</li><li>如果伺服器邏輯簡單且穩定，可以將測試重點放在應用邏輯上。</li></ul><h4 id="可測試的場景"><a href="#可測試的場景" class="headerlink" title="可測試的場景"></a>可測試的場景</h4><ol><li>伺服器成功啟動。</li><li>端口被佔用錯誤處理 (<code>EADDRINUSE</code>)。</li><li>權限不足錯誤處理 (<code>EACCES</code>)。</li></ol><h4 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h4><p>測試 <code>www.ts</code> 能增強應用穩定性，但非必須。</p><h2 id="8-參考連結"><a href="#8-參考連結" class="headerlink" title="8. 參考連結"></a>8. 參考連結</h2><p><a href="https://github.com/terryyaowork/express-ts-proto/commit/54f6219c8c3440e1642a3f421e5cdbc749ad7dd8">參考連結</a></p>]]></content>
    
    
    <categories>
      
      <category>express</category>
      
      <category>Web 開發</category>
      
    </categories>
    
    
    <tags>
      
      <tag>express</tag>
      
      <tag>typescript</tag>
      
      <tag>pnpm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[express][01]Express + TypeScript 專案從零開始的步驟</title>
    <link href="/express/web-develop/20241017/368853435/"/>
    <url>/express/web-develop/20241017/368853435/</url>
    
    <content type="html"><![CDATA[<h1 id="Express-TypeScript-專案從零開始的步驟"><a href="#Express-TypeScript-專案從零開始的步驟" class="headerlink" title="Express + TypeScript 專案從零開始的步驟"></a>Express + TypeScript 專案從零開始的步驟</h1><p><img src="/images/express/01-init.webp" alt="Express + TypeScript 專案從零開始的步驟"></p><h2 id="前置說明"><a href="#前置說明" class="headerlink" title="前置說明"></a>前置說明</h2><p>本文將教你如何使用 <code>pnpm</code> 來從零開始建立一個 Express + TypeScript 的專案。使用 <code>pnpm</code> 的好處在於它提供了快速、節省磁碟空間的套件管理方式，並且非常適合大型專案的依賴管理。接下來，我們會一步步完成專案的初始化、基本架構的搭建，以及一些 Express 與 TypeScript 的最佳實踐。</p><h2 id="1-建立專案目錄"><a href="#1-建立專案目錄" class="headerlink" title="1. 建立專案目錄"></a>1. 建立專案目錄</h2><p>首先，進入到你想要創建專案的目錄並初始化專案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> express_ts_proto<br><span class="hljs-built_in">cd</span> express_ts_proto<br>pnpm init<br></code></pre></td></tr></table></figure><p><code>pnpm init</code> 會初始化專案並生成 <code>package.json</code> 文件，這將作為專案的基礎設定檔。</p><p>還有要新增 .gitignore 檔案，把常見的檔案都 ignore 掉。</p><h2 id="2-安裝-Express-和相關依賴"><a href="#2-安裝-Express-和相關依賴" class="headerlink" title="2. 安裝 Express 和相關依賴"></a>2. 安裝 Express 和相關依賴</h2><p>使用 <code>pnpm</code> 安裝 Express 和相關的依賴：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm add express cookie-parser morgan<br></code></pre></td></tr></table></figure><p>這個指令會安裝 Express 框架以及常用的中介軟體，例如處理 cookie 的 <code>cookie-parser</code> 和記錄 HTTP 請求的 <code>morgan</code>。</p><h2 id="3-安裝-TypeScript-和相關開發依賴"><a href="#3-安裝-TypeScript-和相關開發依賴" class="headerlink" title="3. 安裝 TypeScript 和相關開發依賴"></a>3. 安裝 TypeScript 和相關開發依賴</h2><p>接著，安裝 TypeScript 及相關的型別定義檔案，讓專案支援 TypeScript：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm add -D typescript @types/node @types/express @types/cookie-parser @types/morgan ts-node @types/debug<br></code></pre></td></tr></table></figure><p>這些開發依賴會幫助專案在開發階段支援 TypeScript 型別檢查。</p><h2 id="4-初始化-TypeScript-配置"><a href="#4-初始化-TypeScript-配置" class="headerlink" title="4. 初始化 TypeScript 配置"></a>4. 初始化 TypeScript 配置</h2><p>創建一個 <code>tsconfig.json</code> 文件來設置 TypeScript 編譯器的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm <span class="hljs-built_in">exec</span> tsc --init<br></code></pre></td></tr></table></figure><p>修改 <code>tsconfig.json</code> 文件如下，來配置輸出和根目錄：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ES2020&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;commonjs&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;outDir&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./dist&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;rootDir&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./src&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;strict&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;esModuleInterop&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;src/**/*&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>這樣的配置可以確保 TypeScript 會將編譯後的 JavaScript 文件輸出到 <code>dist</code> 目錄，並設置專案的源文件路徑為 <code>src</code>。</p><h2 id="5-建立-Express-應用模板"><a href="#5-建立-Express-應用模板" class="headerlink" title="5. 建立 Express 應用模板"></a>5. 建立 Express 應用模板</h2><p>使用 <code>express-generator</code> 來生成基本的 Express 應用結構，並指定不使用視圖引擎：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm add express-generator --save-dev<br><br>pnpm <span class="hljs-built_in">exec</span> express --no-view<br></code></pre></td></tr></table></figure><p>這將會建立一個預設的應用結構，隨後我們會將其轉換為 TypeScript 格式。</p><h2 id="6-安裝-dotenv-用來管理環境變數"><a href="#6-安裝-dotenv-用來管理環境變數" class="headerlink" title="6. 安裝 dotenv 用來管理環境變數"></a>6. 安裝 <code>dotenv</code> 用來管理環境變數</h2><p>安裝 <code>dotenv</code> 來處理 <code>.env</code> 環境變數文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm add dotenv<br></code></pre></td></tr></table></figure><h2 id="7-建立-env-文件"><a href="#7-建立-env-文件" class="headerlink" title="7. 建立 .env 文件"></a>7. 建立 <code>.env</code> 文件</h2><p>在專案根目錄創建 <code>.env</code> 文件來定義環境變數：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">PORT</span><span class="hljs-operator">=</span><span class="hljs-number">3000</span><br><span class="hljs-attribute">DEBUG</span><span class="hljs-operator">=</span>*<br></code></pre></td></tr></table></figure><p>這裡設定了應用的預設埠和調試模式。</p><h2 id="8-建立應用文件結構"><a href="#8-建立應用文件結構" class="headerlink" title="8. 建立應用文件結構"></a>8. 建立應用文件結構</h2><p>新增 <code>src/</code> 目錄並且在 <code>src/</code> 下建立以下文件結構：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">/src<br>    /bin<br>        www.ts<br>    /routes<br>        index.ts<br>        users.ts<br>    app.ts<br></code></pre></td></tr></table></figure><h2 id="9-編寫-src-app-ts"><a href="#9-編寫-src-app-ts" class="headerlink" title="9. 編寫 src/app.ts"></a>9. 編寫 <code>src/app.ts</code></h2><p>請將原本的 <code>app.js</code> 重新命名修改為 <code>app.ts</code>，並且確認搬移到 <code>src/</code> 資料夾裡面。<br><code>app.ts</code> 是應用的核心，負責設置中介軟體（Middleware）和路由。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;express&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; join &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span>;<br><span class="hljs-keyword">import</span> cookieParser <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;cookie-parser&#x27;</span>;<br><span class="hljs-keyword">import</span> logger <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;morgan&#x27;</span>;<br><span class="hljs-keyword">import</span> routes <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./routes&#x27;</span>;<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br><span class="hljs-comment">// Middleware</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">logger</span>(<span class="hljs-string">&#x27;dev&#x27;</span>));<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">json</span>());<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">urlencoded</span>(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span> &#125;));<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">cookieParser</span>());<br><br><span class="hljs-comment">// Uncomment if needed for serving static files</span><br><span class="hljs-comment">// app.use(express.static(join(__dirname, &#x27;public&#x27;)));</span><br><br><span class="hljs-comment">// Use centralized routes</span><br>app.<span class="hljs-title function_">use</span>(routes);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> app;<br></code></pre></td></tr></table></figure><h2 id="10-編寫-src-bin-www-ts"><a href="#10-編寫-src-bin-www-ts" class="headerlink" title="10. 編寫 src/bin/www.ts"></a>10. 編寫 <code>src/bin/www.ts</code></h2><p>請講原本的 <code>bin/www</code> 移動並且修改副檔案名 <code>src/bin/www.ts</code>。<br><code>www.ts</code> 負責啟動伺服器並處理錯誤。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">#!/usr/bin/env node</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dotenv/config&#x27;</span>;  <span class="hljs-comment">// Load .env variables</span><br><span class="hljs-keyword">import</span> app <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../app&#x27;</span>;<br><span class="hljs-keyword">import</span> http <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;http&#x27;</span>;<br><span class="hljs-keyword">import</span> debug <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;debug&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">normalizePort</span> = (<span class="hljs-params">val: <span class="hljs-built_in">string</span></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> port = <span class="hljs-built_in">parseInt</span>(val, <span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(port)) <span class="hljs-keyword">return</span> val;<br>  <span class="hljs-keyword">if</span> (port &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> port;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">onError</span> = (<span class="hljs-params">error: <span class="hljs-built_in">any</span></span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (error.<span class="hljs-property">syscall</span> !== <span class="hljs-string">&#x27;listen&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> error;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> bind = <span class="hljs-keyword">typeof</span> port === <span class="hljs-string">&#x27;string&#x27;</span><br>    ? <span class="hljs-string">&#x27;Pipe &#x27;</span> + port<br>    : <span class="hljs-string">&#x27;Port &#x27;</span> + port;<br><br>  <span class="hljs-comment">// handle specific listen errors with friendly messages</span><br>  <span class="hljs-keyword">switch</span> (error.<span class="hljs-property">code</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;EACCES&#x27;</span>:<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(bind + <span class="hljs-string">&#x27; requires elevated privileges&#x27;</span>);<br>      process.<span class="hljs-title function_">exit</span>(<span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;EADDRINUSE&#x27;</span>:<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(bind + <span class="hljs-string">&#x27; is already in use&#x27;</span>);<br>      process.<span class="hljs-title function_">exit</span>(<span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">throw</span> error;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">onListening</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> addr = server.<span class="hljs-title function_">address</span>();<br>  <span class="hljs-keyword">if</span> (addr !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> addr !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-keyword">const</span> bind = <span class="hljs-string">&#x27;port &#x27;</span> + addr.<span class="hljs-property">port</span>;<br>    <span class="hljs-title function_">debug</span>(<span class="hljs-string">&#x27;Listening on &#x27;</span> + bind);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (addr !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> addr === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-keyword">const</span> bind = <span class="hljs-string">&#x27;pipe &#x27;</span> + addr;<br>    <span class="hljs-title function_">debug</span>(<span class="hljs-string">&#x27;Listening on &#x27;</span> + bind);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Server address is null.&#x27;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> port = <span class="hljs-title function_">normalizePort</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">PORT</span> || <span class="hljs-string">&#x27;3000&#x27;</span>);<br>app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;port&#x27;</span>, port);<br><br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(app);<br>server.<span class="hljs-title function_">listen</span>(port);<br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, onError);<br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;listening&#x27;</span>, onListening);<br></code></pre></td></tr></table></figure><h2 id="11-建立-src-routes-index-ts"><a href="#11-建立-src-routes-index-ts" class="headerlink" title="11. 建立 src/routes/index.ts"></a>11. 建立 <code>src/routes/index.ts</code></h2><p>這個文件管理首頁的路由邏輯。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Router</span>, <span class="hljs-title class_">Request</span>, <span class="hljs-title class_">Response</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;express&#x27;</span>;<br><span class="hljs-keyword">import</span> usersRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./users&#x27;</span>;<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title class_">Router</span>();<br><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req: Request, res: Response</span>) =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Welcome to the Home Page&#x27;</span>)<br>&#125;);<br>router.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/users&#x27;</span>, usersRouter);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure><h2 id="12-建立-src-routes-users-ts"><a href="#12-建立-src-routes-users-ts" class="headerlink" title="12. 建立 src/routes/users.ts"></a>12. 建立 <code>src/routes/users.ts</code></h2><p><code>users.ts</code> 負責管理 <code>/users</code> 路由邏輯。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Router</span>, <span class="hljs-title class_">Request</span>, <span class="hljs-title class_">Response</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;express&#x27;</span>;<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title class_">Router</span>();<br><br><span class="hljs-comment">/* GET users listing. */</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req: Request, res: Response</span>) =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;respond with a resource&#x27;</span>);<br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure><h2 id="13-更新-package-json"><a href="#13-更新-package-json" class="headerlink" title="13. 更新 package.json"></a>13. 更新 <code>package.json</code></h2><p>在 <code>package.json</code> 中添加 <code>start</code> 腳本來啟動應用：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ts-node ./src/bin/www&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="14-運行專案"><a href="#14-運行專案" class="headerlink" title="14. 運行專案"></a>14. 運行專案</h2><p>現在，應用可以通過 <code>pnpm start</code> 命令啟動：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm start<br></code></pre></td></tr></table></figure><p>如果一切順利，你應該會看到伺服器成功啟動並開始監聽指定的端口。</p><hr><h2 id="15-最佳實踐與未來發展"><a href="#15-最佳實踐與未來發展" class="headerlink" title="15. 最佳實踐與未來發展"></a>15. 最佳實踐與未來發展</h2><ul><li><strong>環境變數管理</strong>：通過 <code>.env</code> 文件靈活管理專案的環境設置。</li><li><strong>TypeScript 錯誤處理</strong>：確保每個文件中的參數、返回值都有正確的型別註解。</li><li><strong>中介軟體與路由的拆分</strong>：未來可以將中介軟體和路由拆分成更多模組以便</li></ul><h2 id="16-參考連結"><a href="#16-參考連結" class="headerlink" title="16. 參考連結"></a>16. 參考連結</h2><p><a href="https://github.com/terryyaowork/express-ts-proto/commit/b86bf41985cc6c9ae3618a349ab630cf154770ff">參考連結</a></p>]]></content>
    
    
    <categories>
      
      <category>express</category>
      
      <category>Web 開發</category>
      
    </categories>
    
    
    <tags>
      
      <tag>express</tag>
      
      <tag>typescript</tag>
      
      <tag>pnpm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CommitLint：規範提交信息的工具</title>
    <link href="/devOps/20240915/3317806134/"/>
    <url>/devOps/20240915/3317806134/</url>
    
    <content type="html"><![CDATA[<h2 id="Commitlint：提升提交訊息質量的工具"><a href="#Commitlint：提升提交訊息質量的工具" class="headerlink" title="Commitlint：提升提交訊息質量的工具"></a>Commitlint：提升提交訊息質量的工具</h2><p><img src="/images/devOps/02-commitlint.webp" alt="Commitlint 流程圖"></p><p><strong>流程圖說明</strong>：此流程圖展示了 Commitlint 的基本流程，包括撰寫提交訊息、提交訊息檢查、通過檢查或拒絕提交等步驟。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在軟體開發過程中，提交訊息的質量對於團隊協作和代碼管理至關重要。Commitlint 是一款用於強制執行提交訊息規範的工具，能夠幫助團隊維持一致的提交格式，提升代碼質量和可維護性。通過使用 Commitlint，開發團隊可以確保每次提交都有清晰、結構化的描述，便於追蹤和回溯代碼變更。</p><h3 id="Commitlint-的基本概念"><a href="#Commitlint-的基本概念" class="headerlink" title="Commitlint 的基本概念"></a>Commitlint 的基本概念</h3><p>Commitlint 主要用於驗證 Git 提交訊息是否符合預先定義的規範。通過配置規則，Commitlint 可以自動檢查提交訊息的格式和內容，確保每次提交都具有清晰、結構化的描述。這不僅提升了代碼庫的可讀性，還有助於自動生成發佈說明（Changelog）和版本控制。</p><h4 id="語義化提交訊息（Conventional-Commits）"><a href="#語義化提交訊息（Conventional-Commits）" class="headerlink" title="語義化提交訊息（Conventional Commits）"></a>語義化提交訊息（Conventional Commits）</h4><p>Commitlint 通常結合語義化提交訊息使用，語義化提交訊息遵循一定的格式，如 <code>type(scope): description</code>，其中：</p><ul><li><strong>type</strong>：提交類型，如 <code>feat</code>（新功能）、<code>fix</code>（修復）、<code>docs</code>（文檔）、<code>chore</code>（雜項）等。</li><li><strong>scope</strong>：可選，提交所涉及的範圍，如模塊名稱或功能名稱。</li><li><strong>description</strong>：簡短的提交描述。</li></ul><p>使用語義化版本控制（Semantic Versioning，SemVer）配合 Commitlint，可以讓用戶和團隊清楚了解每個版本的變更範圍和影響，有助於更好地管理版本發佈和依賴關係。</p><h3 id="如何安裝與配置-Commitlint"><a href="#如何安裝與配置-Commitlint" class="headerlink" title="如何安裝與配置 Commitlint"></a>如何安裝與配置 Commitlint</h3><p>以下是安裝和配置 Commitlint 的步驟：</p><h4 id="安裝-Commitlint"><a href="#安裝-Commitlint" class="headerlink" title="安裝 Commitlint"></a>安裝 Commitlint</h4><p>首先，確保您已經安裝了 Node.js 和 npm。然後，在您的專案中安裝 Commitlint 及相關依賴：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save-dev @commitlint/&#123;config-conventional,cli&#125;<br></code></pre></td></tr></table></figure><h4 id="配置-Commitlint"><a href="#配置-Commitlint" class="headerlink" title="配置 Commitlint"></a>配置 Commitlint</h4><p>在專案根目錄下創建一個 <code>commitlint.config.js</code> 文件，並添加以下內容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123; <span class="hljs-attr">extends</span>: [<span class="hljs-string">&#x27;@commitlint/config-conventional&#x27;</span>] &#125;;<br></code></pre></td></tr></table></figure><p>這樣配置後，Commitlint 將遵循 Conventional Commits 規範來檢查提交訊息。</p><h4 id="配合-Husky-使用"><a href="#配合-Husky-使用" class="headerlink" title="配合 Husky 使用"></a>配合 Husky 使用</h4><p>為了在每次提交時自動執行 Commitlint，可以使用 Husky 來設置 Git hooks。</p><ol><li><p><strong>安裝 Husky</strong>：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save-dev husky<br></code></pre></td></tr></table></figure></li><li><p><strong>初始化 Husky</strong>：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx husky install<br></code></pre></td></tr></table></figure></li><li><p><strong>添加 commit-msg hook</strong>：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx husky add .husky/commit-msg <span class="hljs-string">&#x27;npx --no -- commitlint --edit &quot;$1&quot;&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>更新 <code>package.json</code> 以啟用 Husky</strong>：</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;prepare&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;husky install&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ol><p>這樣，每次提交時，Commitlint 都會自動檢查提交訊息是否符合規範，並在不符合時拒絕提交。</p><h3 id="使用-Commitlint"><a href="#使用-Commitlint" class="headerlink" title="使用 Commitlint"></a>使用 Commitlint</h3><p>當您按照上述步驟配置好 Commitlint 後，每次提交時，Commitlint 會自動檢查提交訊息是否符合規範。如果提交訊息不符合，提交將被拒絕，並提示您修正訊息格式。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><strong>正確的提交訊息：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;feat(login): add user authentication&quot;</span><br></code></pre></td></tr></table></figure><p><strong>錯誤的提交訊息：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;Added user authentication feature&quot;</span><br></code></pre></td></tr></table></figure><p>在錯誤的提交訊息中，缺少了類型 <code>feat</code> 和作用域 <code>login</code>，Commitlint 會提示訊息格式不正確，要求按照規範修正。</p><h3 id="Commitlint-的優缺點"><a href="#Commitlint-的優缺點" class="headerlink" title="Commitlint 的優缺點"></a>Commitlint 的優缺點</h3><h4 id="優點"><a href="#優點" class="headerlink" title="優點"></a>優點</h4><ul><li><strong>提升代碼質量</strong>：統一的提交訊息格式有助於更好地理解和維護代碼。</li><li><strong>促進團隊協作</strong>：清晰的提交訊息能夠讓團隊成員更快地了解每次變更的內容和目的。</li><li><strong>自動化檢查</strong>：結合 Husky，自動在提交時檢查訊息格式，減少人工錯誤。</li><li><strong>便於生成發佈說明</strong>：統一的提交訊息格式便於使用工具自動生成 Changelog 和發佈文檔。</li></ul><h4 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h4><ul><li><strong>學習曲線</strong>：需要團隊成員熟悉語義化提交訊息的規範。</li><li><strong>初期配置</strong>：設置 Commitlint 和 Husky 需要一定的時間和配置工作。</li><li><strong>靈活性限制</strong>：嚴格的提交訊息規範可能會限制某些特殊情況下的提交描述。</li></ul><h3 id="實際案例"><a href="#實際案例" class="headerlink" title="實際案例"></a>實際案例</h3><h4 id="案例一：統一提交訊息格式"><a href="#案例一：統一提交訊息格式" class="headerlink" title="案例一：統一提交訊息格式"></a>案例一：統一提交訊息格式</h4><p>在一個多開發者協作的專案中，團隊使用 Commitlint 來強制執行語義化提交訊息。這不僅提升了代碼庫的可讀性，還使得生成變更日誌（Changelog）變得更加簡單和自動化。例如，使用工具如 <code>conventional-changelog</code> 可以根據提交訊息自動生成發佈說明。</p><h4 id="案例二：自動化發佈流程"><a href="#案例二：自動化發佈流程" class="headerlink" title="案例二：自動化發佈流程"></a>案例二：自動化發佈流程</h4><p>在一個需要頻繁發佈新版本的專案中，團隊結合 Commitlint 和 GitLab CI&#x2F;CD，自動化了發佈流程。每次提交訊息符合規範後，CI&#x2F;CD 流程會自動運行測試、打包並部署到生產環境，極大提升了發佈效率和穩定性。</p><h3 id="發佈策略"><a href="#發佈策略" class="headerlink" title="發佈策略"></a>發佈策略</h3><p>不同的發佈策略適用於不同的專案需求和環境。以下是幾種常見的發佈策略：</p><h4 id="滾動發佈（Rolling-Releases）"><a href="#滾動發佈（Rolling-Releases）" class="headerlink" title="滾動發佈（Rolling Releases）"></a>滾動發佈（Rolling Releases）</h4><ul><li><strong>描述</strong>：逐步將新版本部署到不同的服務器或節點，確保系統在發佈過程中始終保持可用。</li><li><strong>優點</strong>：減少停機時間，降低風險。</li><li><strong>缺點</strong>：需要複雜的部署管理和監控。</li></ul><h4 id="藍綠部署（Blue-Green-Deployments）"><a href="#藍綠部署（Blue-Green-Deployments）" class="headerlink" title="藍綠部署（Blue-Green Deployments）"></a>藍綠部署（Blue-Green Deployments）</h4><ul><li><strong>描述</strong>：維護兩個相同的生產環境（藍環境和綠環境），新版本先部署到一個環境，經過測試後切換流量。</li><li><strong>優點</strong>：快速回滾，減少風險。</li><li><strong>缺點</strong>：需要額外的基礎設施資源。</li></ul><h4 id="金絲雀發佈（Canary-Releases）"><a href="#金絲雀發佈（Canary-Releases）" class="headerlink" title="金絲雀發佈（Canary Releases）"></a>金絲雀發佈（Canary Releases）</h4><ul><li><strong>描述</strong>：將新版本僅部署到一小部分用戶，觀察其表現後逐步擴大部署範圍。</li><li><strong>優點</strong>：早期發現問題，減少影響範圍。</li><li><strong>缺點</strong>：需要精細的流量控制和監控。</li></ul><h3 id="Commitlint-管理工具"><a href="#Commitlint-管理工具" class="headerlink" title="Commitlint 管理工具"></a>Commitlint 管理工具</h3><p>有效的 Commitlint 管理離不開自動化工具的支持。以下是幾種常用的 Commitlint 管理工具：</p><ul><li><strong>GitLab CI&#x2F;CD</strong>：GitLab 提供的持續集成和持續部署工具，支持自動化測試和部署流程。</li><li><strong>Jenkins</strong>：開源的自動化服務器，適合複雜的 CI&#x2F;CD 流程配置。</li><li><strong>Travis CI</strong>：與 GitHub 無縫集成的持續整合工具，適合開源項目和快速設置。</li><li><strong>GitHub Actions</strong>：GitHub 提供的自動化工作流程工具，支持多種語言和框架的構建、測試和部署。</li></ul><h3 id="回滾策略"><a href="#回滾策略" class="headerlink" title="回滾策略"></a>回滾策略</h3><p>在發佈過程中，可能會遇到各種問題，設計有效的回滾策略能夠迅速恢復系統穩定性。以下是幾種常見的回滾策略：</p><ul><li><strong>版本回滾</strong>：將生產環境回滾到上一個穩定版本，確保系統可用。</li><li><strong>熱修復分支</strong>：創建 Hotfix 分支，修復緊急問題後合併回 Master 和 Release 分支。</li><li><strong>備份恢復</strong>：在發佈前對生產環境進行全面備份，遇到問題時從備份恢復。</li><li><strong>多環境測試</strong>：在多個環境中進行測試，確保新版本的穩定性和兼容性，減少發佈風險。</li></ul><h3 id="實際案例-1"><a href="#實際案例-1" class="headerlink" title="實際案例"></a>實際案例</h3><h4 id="案例一：統一提交訊息格式-1"><a href="#案例一：統一提交訊息格式-1" class="headerlink" title="案例一：統一提交訊息格式"></a>案例一：統一提交訊息格式</h4><p>在一個多開發者協作的專案中，團隊使用 Commitlint 來強制執行語義化提交訊息。這不僅提升了代碼庫的可讀性，還使得生成變更日誌（Changelog）變得更加簡單和自動化。例如，使用工具如 <code>conventional-changelog</code> 可以根據提交訊息自動生成發佈說明。</p><h4 id="案例二：自動化發佈流程-1"><a href="#案例二：自動化發佈流程-1" class="headerlink" title="案例二：自動化發佈流程"></a>案例二：自動化發佈流程</h4><p>在一個需要頻繁發佈新版本的專案中，團隊結合 Commitlint 和 GitLab CI&#x2F;CD，自動化了發佈流程。每次提交訊息符合規範後，CI&#x2F;CD 流程會自動運行測試、打包並部署到生產環境，極大提升了發佈效率和穩定性。</p><h3 id="最佳實踐提示"><a href="#最佳實踐提示" class="headerlink" title="最佳實踐提示"></a>最佳實踐提示</h3><ul><li><strong>遵循命名規則</strong>：使用一致的提交訊息命名規則，如 <code>type(scope): description</code>，以保持提交歷史的清晰。</li><li><strong>定期審查規範</strong>：根據團隊需求和專案變化，定期更新和審查提交訊息規範，確保其適用性和有效性。</li><li><strong>代碼審查與測試</strong>：在合併分支前，通過 Merge Request 進行代碼審查和測試，確保代碼質量和穩定性。</li><li><strong>自動化部署</strong>：結合 CI&#x2F;CD 工具，自動化提交訊息檢查、測試和部署流程，提升發佈效率和可靠性。</li><li><strong>文檔與培訓</strong>：撰寫提交訊息指南並對團隊成員進行培訓，確保所有人都能遵循規範。</li></ul><h3 id="常見問題解答"><a href="#常見問題解答" class="headerlink" title="常見問題解答"></a>常見問題解答</h3><h4 id="問：Commitlint-適用於哪些專案？"><a href="#問：Commitlint-適用於哪些專案？" class="headerlink" title="問：Commitlint 適用於哪些專案？"></a>問：Commitlint 適用於哪些專案？</h4><p>答：Commitlint 適用於任何使用 Git 進行版本控制的專案，特別是多開發者協作的專案。無論是小型專案還是大型專案，統一的提交訊息格式都能提升代碼質量和團隊協作效率。</p><h4 id="問：如果我的團隊不使用-Commitlint，會有什麼影響？"><a href="#問：如果我的團隊不使用-Commitlint，會有什麼影響？" class="headerlink" title="問：如果我的團隊不使用 Commitlint，會有什麼影響？"></a>問：如果我的團隊不使用 Commitlint，會有什麼影響？</h4><p>答：如果不使用 Commitlint，團隊需要自行制定提交訊息規範，並手動檢查提交訊息的格式，這可能會導致提交訊息格式混亂，降低代碼庫的可讀性和可維護性。使用 Commitlint 可以自動化這一過程，減少人為錯誤，提升團隊效率。</p><h4 id="問：Commitlint-和其他提交訊息檢查工具有何不同？"><a href="#問：Commitlint-和其他提交訊息檢查工具有何不同？" class="headerlink" title="問：Commitlint 和其他提交訊息檢查工具有何不同？"></a>問：Commitlint 和其他提交訊息檢查工具有何不同？</h4><p>答：Commitlint 專注於驗證提交訊息是否符合預定的規範，並且易於與 Husky 等 Git hooks 工具集成。相比其他工具，Commitlint 提供了靈活的配置選項，支持自定義規則，並與語義化提交訊息（Conventional Commits）無縫集成，是一個專業且易於使用的提交訊息檢查工具。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>Commitlint 是一款強大的工具，能夠幫助團隊統一提交訊息格式，提升代碼質量和團隊協作效率。通過結合 Husky 和語義化提交訊息，Commitlint 能夠自動化檢查和維護提交訊息的規範，為專案的可維護性和可讀性提供有力支持。無論是小型專案還是大型專案，Commitlint 都是提升代碼管理和團隊協作的利器。</p><h3 id="參考資源"><a href="#參考資源" class="headerlink" title="參考資源"></a>參考資源</h3><ul><li><a href="https://commitlint.js.org/#/">Commitlint 官方文檔</a></li><li><a href="https://typicode.github.io/husky/#/">Husky 官方文檔</a></li><li><a href="https://semver.org/lang/zh-TW/">語義化版本控制（Semantic Versioning）</a></li><li><a href="https://www.conventionalcommits.org/zh-hant/v1.0.0/">Conventional Commits</a></li><li><a href="https://pjchender.dev/npm/note-git-conventional-commit/">git conventional commit</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>devOps</category>
      
    </categories>
    
    
    <tags>
      
      <tag>devOps</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Release 管理：確保版本穩定的流程</title>
    <link href="/devOps/20240915/3152381087/"/>
    <url>/devOps/20240915/3152381087/</url>
    
    <content type="html"><![CDATA[<h2 id="Release-管理：確保版本穩定的流程"><a href="#Release-管理：確保版本穩定的流程" class="headerlink" title="Release 管理：確保版本穩定的流程"></a>Release 管理：確保版本穩定的流程</h2><p><img src="/images/git/08-release.webp" alt="release"></p><h3 id="Release-管理的流程圖"><a href="#Release-管理的流程圖" class="headerlink" title="Release 管理的流程圖"></a>Release 管理的流程圖</h3><pre class="mermaid">graph TD    A[需求收集] --> B[版本規劃]    B --> C[開發與測試]    C --> D[發布準備]    D --> E[正式發佈]    E --> F[監控與回滾]</pre><p><img src="/images/git/08-release.png" alt="Release 管理流程圖"></p><p><strong>流程圖說明</strong>：此流程圖展示了 Release 管理的基本流程，包括需求收集、版本規劃、開發與測試、發布準備、正式發佈等步驟。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Release 管理是軟體開發過程中至關重要的一環，旨在確保每個版本的穩定性和可用性。通過明確的流程和規範，團隊能夠有效管理版本發佈，降低生產環境的風險。</p><h3 id="Release-管理的基本概念"><a href="#Release-管理的基本概念" class="headerlink" title="Release 管理的基本概念"></a>Release 管理的基本概念</h3><p>Release 管理涉及版本的計劃、開發、測試和發佈。其主要目的是確保每個版本的穩定性和可用性。</p><h4 id="Release-流程"><a href="#Release-流程" class="headerlink" title="Release 流程"></a>Release 流程</h4><ol><li><strong>需求收集</strong>：與產品經理和相關團隊討論，確定新版本需要實現的功能和修復的問題，並優先排序。</li><li><strong>版本規劃</strong>：根據需求制定詳細的版本計劃，確定發佈時間、範圍以及相關資源分配。</li><li><strong>開發與測試</strong>：在開發環境中進行功能開發和單元測試，確保新功能的穩定性和兼容性。</li><li><strong>發布準備</strong>：創建 Release 分支，進行整合測試和最終修正，並準備發佈文檔和發佈說明。</li><li><strong>正式發佈</strong>：將 Release 分支合併到 Master 分支，打上版本標籤，並將代碼部署到生產環境。</li></ol><h3 id="Release-管理的最佳實踐"><a href="#Release-管理的最佳實踐" class="headerlink" title="Release 管理的最佳實踐"></a>Release 管理的最佳實踐</h3><ul><li><strong>定期發佈</strong>：設定固定的發佈週期，讓團隊和用戶都有預期。</li><li><strong>明確的版本號</strong>：使用語義化版本控制（SemVer）來管理版本號，讓用戶清楚了解每個版本的變更。</li><li><strong>自動化測試</strong>：在發佈之前，運行自動化測試以確保代碼的穩定性。</li><li><strong>文檔更新</strong>：在每次發佈後更新相關文檔，確保用戶能夠了解新功能和變更。</li><li><strong>發佈文檔和發佈說明</strong>：撰寫詳細的發佈說明，幫助用戶和團隊了解新版本的變更內容。</li></ul><h3 id="發佈策略"><a href="#發佈策略" class="headerlink" title="發佈策略"></a>發佈策略</h3><p>不同的發佈策略適用於不同的專案需求和環境。以下是幾種常見的發佈策略：</p><h4 id="滾動發佈（Rolling-Releases）"><a href="#滾動發佈（Rolling-Releases）" class="headerlink" title="滾動發佈（Rolling Releases）"></a>滾動發佈（Rolling Releases）</h4><ul><li><strong>描述</strong>：逐步將新版本部署到不同的服務器或節點，確保系統在發佈過程中始終保持可用。</li><li><strong>優點</strong>：減少停機時間，降低風險。</li><li><strong>缺點</strong>：需要複雜的部署管理和監控。</li></ul><h4 id="藍綠部署（Blue-Green-Deployments）"><a href="#藍綠部署（Blue-Green-Deployments）" class="headerlink" title="藍綠部署（Blue-Green Deployments）"></a>藍綠部署（Blue-Green Deployments）</h4><ul><li><strong>描述</strong>：維護兩個相同的生產環境（藍環境和綠環境），新版本先部署到一個環境，經過測試後切換流量。</li><li><strong>優點</strong>：快速回滾，減少風險。</li><li><strong>缺點</strong>：需要額外的基礎設施資源。</li></ul><h4 id="金絲雀發佈（Canary-Releases）"><a href="#金絲雀發佈（Canary-Releases）" class="headerlink" title="金絲雀發佈（Canary Releases）"></a>金絲雀發佈（Canary Releases）</h4><ul><li><strong>描述</strong>：將新版本僅部署到一小部分用戶，觀察其表現後逐步擴大部署範圍。</li><li><strong>優點</strong>：早期發現問題，減少影響範圍。</li><li><strong>缺點</strong>：需要精細的流量控制和監控。</li></ul><h3 id="Release-管理工具"><a href="#Release-管理工具" class="headerlink" title="Release 管理工具"></a>Release 管理工具</h3><p>有效的 Release 管理離不開自動化工具的支持。以下是幾種常用的 Release 管理工具：</p><ul><li><strong>GitLab CI&#x2F;CD</strong>：GitLab 提供的持續集成和持續部署工具，支持自動化測試和部署流程。</li><li><strong>Jenkins</strong>：開源的自動化服務器，適合複雜的 CI&#x2F;CD 流程配置。</li><li><strong>Travis CI</strong>：與 GitHub 無縫集成的持續整合工具，適合開源項目和快速設置。</li><li><strong>GitHub Actions</strong>：GitHub 提供的自動化工作流程工具，支持多種語言和框架的構建、測試和部署。</li></ul><h3 id="回滾策略"><a href="#回滾策略" class="headerlink" title="回滾策略"></a>回滾策略</h3><p>在發佈過程中，可能會遇到各種問題，設計有效的回滾策略能夠迅速恢復系統穩定性。以下是幾種常見的回滾策略：</p><ul><li><strong>版本回滾</strong>：將生產環境回滾到上一個穩定版本，確保系統可用。</li><li><strong>熱修復分支</strong>：創建 Hotfix 分支，修復緊急問題後合併回 Master 和 Release 分支。</li><li><strong>備份恢復</strong>：在發佈前對生產環境進行全面備份，遇到問題時從備份恢復。</li><li><strong>多環境測試</strong>：在多個環境中進行測試，確保新版本的穩定性和兼容性，減少發佈風險。</li></ul><h3 id="實際案例"><a href="#實際案例" class="headerlink" title="實際案例"></a>實際案例</h3><h4 id="案例一：持續發布的-Web-應用開發"><a href="#案例一：持續發布的-Web-應用開發" class="headerlink" title="案例一：持續發布的 Web 應用開發"></a>案例一：持續發布的 Web 應用開發</h4><p>在一個需要頻繁發布新功能的 Web 應用專案中，團隊採用 Release 管理來確保每個版本的穩定性。每當開發完成一個功能，團隊會創建一個 Release 分支，進行最終測試和修正。為了確保部署過程的穩定性，團隊使用 GitLab CI&#x2F;CD 自動運行測試和部署腳本，並設置了回滾機制，以應對可能出現的部署問題。</p><h4 id="案例二：版本發佈管理"><a href="#案例二：版本發佈管理" class="headerlink" title="案例二：版本發佈管理"></a>案例二：版本發佈管理</h4><p>在一個大型專案中，團隊使用 Release 管理來確保每個版本的穩定性。每個穩定版本都從 <code>master</code> 創建一個新的 Release 分支，並在該分支上進行最終測試和修正。當發現 bug 時，團隊會從 Release 分支創建 Hotfix 分支，修復完成後合併到 <code>master</code> 和 Release 分支，確保所有環境都保持最新狀態。通過這種方式，團隊能夠有效管理多個版本的並行開發，並在緊急情況下快速修復生產環境中的問題。</p><h3 id="最佳實踐提示"><a href="#最佳實踐提示" class="headerlink" title="最佳實踐提示"></a>最佳實踐提示</h3><ul><li><strong>遵循命名規則</strong>：使用一致的分支命名規則，如 <code>feature/&lt;name&gt;</code>、<code>release/&lt;version&gt;</code>、<code>hotfix/&lt;name&gt;</code>，以保持分支結構的清晰。</li><li><strong>定期同步 Master 分支</strong>：確保 Master 分支保持最新，定期從 Release 分支合併或變基，減少合併衝突。</li><li><strong>代碼審查與測試</strong>：在合併分支前，通過 Merge Request 進行代碼審查和測試，確保代碼質量和穩定性。</li><li><strong>自動化部署</strong>：結合 CI&#x2F;CD 工具，自動化 Release 和 Hotfix 的部署流程，提升發佈效率和可靠性。</li><li><strong>版本號管理</strong>：使用語義化版本控制（Semantic Versioning）來管理版本號，讓用戶清楚了解每個版本的變更範圍和影響。</li></ul><h3 id="常見問題解答"><a href="#常見問題解答" class="headerlink" title="常見問題解答"></a>常見問題解答</h3><h4 id="問：Release-管理適用於哪些專案？"><a href="#問：Release-管理適用於哪些專案？" class="headerlink" title="問：Release 管理適用於哪些專案？"></a>問：Release 管理適用於哪些專案？</h4><p>答：Release 管理適用於中大型專案，特別是那些需要明確版本發佈和多個穩定分支的專案。對於小型專案或快速迭代的環境，可能需要選擇更簡潔的發佈管理策略。</p><h4 id="問：如果我的團隊不使用-Release-管理，會有什麼影響？"><a href="#問：如果我的團隊不使用-Release-管理，會有什麼影響？" class="headerlink" title="問：如果我的團隊不使用 Release 管理，會有什麼影響？"></a>問：如果我的團隊不使用 Release 管理，會有什麼影響？</h4><p>答：如果不使用 Release 管理，團隊需要自行制定發佈策略，可能會導致版本控制不當、發佈流程混亂，增加生產環境的風險。使用 Release 管理可以提供一套成熟的發佈流程，幫助團隊更有條理地管理版本發佈和代碼部署。</p><h4 id="問：Release-管理和分支管理模型有何關聯？"><a href="#問：Release-管理和分支管理模型有何關聯？" class="headerlink" title="問：Release 管理和分支管理模型有何關聯？"></a>問：Release 管理和分支管理模型有何關聯？</h4><p>答：Release 管理與分支管理模型緊密相關。不同的分支管理模型（如 Git Flow、GitHub Flow、GitLab Flow）提供了不同的分支結構和發佈流程，Release 管理則是在這些基礎上進行具體的版本發佈和管理。選擇合適的分支管理模型能夠更好地支持 Release 管理的需求。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>Release 管理是確保軟體版本穩定的重要流程。通過明確的流程和最佳實踐，團隊能夠有效管理版本發佈，降低生產環境的風險。結合合適的分支管理模型和自動化工具，Release 管理能夠大幅提升團隊協作效率和發佈質量。</p><h3 id="參考資源"><a href="#參考資源" class="headerlink" title="參考資源"></a>參考資源</h3><ul><li><a href="https://www.atlassian.com/software-development/release-management">Release Management Best Practices</a></li><li><a href="https://docs.gitlab.com/ee/user/project/releases/">GitLab Release Management</a></li><li><a href="https://semver.org/lang/zh-TW/">語義化版本控制（Semantic Versioning）</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>devOps</category>
      
    </categories>
    
    
    <tags>
      
      <tag>devOps</tag>
      
      <tag>git</tag>
      
      <tag>release</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitLab Flow：靈活的分支管理模型</title>
    <link href="/devOps/20240915/3670510823/"/>
    <url>/devOps/20240915/3670510823/</url>
    
    <content type="html"><![CDATA[<h2 id="GitLab-Flow：靈活的分支管理模型"><a href="#GitLab-Flow：靈活的分支管理模型" class="headerlink" title="GitLab Flow：靈活的分支管理模型"></a>GitLab Flow：靈活的分支管理模型</h2><p><img src="/images/git/07-gitlab-flow.webp" alt="GitLab Flow 流程圖"></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>GitLab Flow 是一種靈活的分支管理模型，結合了 Git Flow 和 GitHub Flow 的優點，適用於需要快速集成和持續發佈的專案。它由 GitLab 提出，強調上游優先的原則，並支持多環境的部署策略，適合中大型專案和快速迭代的開發環境。</p><h3 id="GitLab-Flow-的基本概念"><a href="#GitLab-Flow-的基本概念" class="headerlink" title="GitLab Flow 的基本概念"></a>GitLab Flow 的基本概念</h3><p>GitLab Flow 的核心思想是：</p><ol><li>只存在一個主分支 <code>master</code>，它是所有分支的上游。</li><li>創建新的分支來開發新功能或修復 bug。</li><li>當開發完成時，發起一個 Merge Request 請求合併。</li><li>在 Merge Request 中進行代碼審查和測試。</li><li>如果代碼審查通過，就可以合併到 <code>master</code> 分支。</li><li>合併後，<code>master</code> 分支上的代碼可以部署到生產環境。</li></ol><p><img src="/images/git/07-gitlab-flow.png" alt="Git Flow 流程圖"></p><h3 id="GitLab-Flow-大略流程"><a href="#GitLab-Flow-大略流程" class="headerlink" title="GitLab Flow 大略流程"></a>GitLab Flow 大略流程</h3><pre class="mermaid">graph TD    A[Master Branch] --> B[Create Feature Branch]    B --> C[Develop Feature]    C --> D[Push Feature Branch]     D --> E[Create Merge Request]    E --> F[Code Review]    F --> G{Approval?}    G -->|Yes| H[Merge to Master]    G -->|No| I[Request Changes]    H --> J[Deploy to Pre-Production]    J --> K{Testing Successful?}    K -->|Yes| L[Deploy to Production]    K -->|No| M[Fix Issues]</pre><p><img src="/images/git/07-gitlab-flow2.png" alt="Git Flow 流程圖"></p><h3 id="如何使用-GitLab-Flow"><a href="#如何使用-GitLab-Flow" class="headerlink" title="如何使用 GitLab Flow"></a>如何使用 GitLab Flow</h3><ol><li><p><strong>從 <code>master</code> 分支創建一個新的分支</strong>:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b feature/new-feature<br></code></pre></td></tr></table></figure></li><li><p><strong>在新分支上進行開發和提交</strong>:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;Add new feature&quot;</span><br>git push origin feature/new-feature<br></code></pre></td></tr></table></figure></li><li><p><strong>在 GitLab 上發起一個 Merge Request</strong>:</p><ul><li>在 GitLab 頁面上，點擊 <code>Merge Request</code> 按鈕。</li><li>填寫 MR 標題和描述，描述本次 MR 的內容。</li></ul></li><li><p><strong>在 MR 頁面進行代碼審查和測試</strong>:</p><ul><li>其他開發者可以查看變更內容並進行代碼審查。</li><li>可以運行自動化測試來確保新功能的正確性。</li></ul></li><li><p><strong>合併 MR 到 <code>master</code> 分支</strong>:</p><ul><li>如果代碼審查通過，就可以點擊 <code>Merge</code> 按鈕將分支合併到 <code>master</code>。</li><li>合併後，<code>master</code> 分支上的代碼就是最新的版本。</li></ul></li><li><p><strong>部署到生產環境</strong>:</p><ul><li>合併到 <code>master</code> 後，可以自動部署到生產環境。</li><li>可以結合 CI&#x2F;CD 工具來自動化部署流程。</li></ul></li></ol><h3 id="各類分支的用途"><a href="#各類分支的用途" class="headerlink" title="各類分支的用途"></a>各類分支的用途</h3><h4 id="Master-分支"><a href="#Master-分支" class="headerlink" title="Master 分支"></a>Master 分支</h4><ul><li><strong>用途</strong>：存放生產環境的穩定版本。</li><li><strong>特點</strong>：所有的變更都必須通過測試後才能合併到此分支。</li></ul><h4 id="Feature-分支"><a href="#Feature-分支" class="headerlink" title="Feature 分支"></a>Feature 分支</h4><ul><li><strong>用途</strong>：用於開發新功能或修復特定問題。</li><li><strong>命名規則</strong>：<code>feature/&lt;功能名稱&gt;</code>，例如 <code>feature/login</code></li><li><strong>生命周期</strong>：從 <code>master</code> 分支創建，完成開發後合併回 <code>master</code>。</li><li><strong>最佳實踐</strong>：每個 Feature 分支應專注於一個單一功能，避免功能之間的耦合，以便更容易進行代碼審查和測試。</li></ul><h4 id="Environment-分支"><a href="#Environment-分支" class="headerlink" title="Environment 分支"></a>Environment 分支</h4><ul><li><strong>用途</strong>：用於不同的部署環境，如 <code>pre-production</code> 和 <code>production</code>。</li><li><strong>特點</strong>：這些分支用於測試和驗證功能，確保在正式環境中穩定運行。</li></ul><h4 id="Release-分支"><a href="#Release-分支" class="headerlink" title="Release 分支"></a>Release 分支</h4><ul><li><strong>用途</strong>：準備新版本的發佈，進行最終測試和修正。</li><li><strong>命名規則</strong>：<code>release/&lt;版本號&gt;</code>，例如 <code>release/1.0.0</code></li><li><strong>生命周期</strong>：從 <code>master</code> 分支創建，完成後合併回 <code>master</code>。</li></ul><h3 id="優點和缺點"><a href="#優點和缺點" class="headerlink" title="優點和缺點"></a>優點和缺點</h3><h4 id="優點"><a href="#優點" class="headerlink" title="優點"></a>優點</h4><ul><li><strong>靈活性高</strong>：適合快速迭代和持續發佈的開發環境。例如，團隊可以根據不同的需求快速創建和刪除分支，適應市場變化。</li><li><strong>上游優先</strong>：確保 <code>master</code> 分支始終處於可部署狀態，所有合併的變更都經過測試。</li><li><strong>支持多環境</strong>：可以根據需要創建不同的環境分支，如開發、預發和生產環境。</li></ul><h4 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h4><ul><li><strong>不適合小型專案</strong>：對於小型專案，過多的分支管理可能會增加複雜性，導致協作困難。</li><li><strong>依賴持續集成</strong>：需要穩定的 CI&#x2F;CD 流程支持，否則可能影響部署效率。</li></ul><h3 id="實際案例"><a href="#實際案例" class="headerlink" title="實際案例"></a>實際案例</h3><h4 id="案例一：持續發布的-Web-應用開發"><a href="#案例一：持續發布的-Web-應用開發" class="headerlink" title="案例一：持續發布的 Web 應用開發"></a>案例一：持續發布的 Web 應用開發</h4><p>在一個需要頻繁發布新功能的 Web 應用專案中，團隊採用 GitLab Flow 來管理分支和發佈流程。每個新功能都在獨立的 Feature 分支上開發，完成後通過 Merge Request 合併到 <code>master</code> 分支，並立即部署到生產環境。這種方式使得團隊能夠快速迭代，迅速響應市場需求。</p><h4 id="案例二：版本發佈管理"><a href="#案例二：版本發佈管理" class="headerlink" title="案例二：版本發佈管理"></a>案例二：版本發佈管理</h4><p>在一個大型專案中，團隊使用 GitLab Flow 來管理版本發佈。每個穩定版本都從 <code>master</code> 創建一個新的版本分支，並在該分支上進行修復和更新。當發現 bug 時，團隊會從版本分支創建 Hotfix 分支，修復完成後合併到 <code>master</code> 和版本分支，確保所有環境都保持最新狀態。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>GitLab Flow 提供了一套靈活且結構化的分支管理模型，適合需要快速迭代和持續發佈的專案。通過明確分支的用途和流程，GitLab Flow 有助於提升團隊協作效率，降低發佈風險。它強調上游優先，並支持多環境的部署策略，能夠幫助開發團隊更好地管理代碼和版本。</p><h3 id="參考資源"><a href="#參考資源" class="headerlink" title="參考資源"></a>參考資源</h3><ul><li><a href="https://docs.gitlab.com/ee/topics/gitlab_flow.html">GitLab Flow 官方文件</a></li><li><a href="https://www.cnblogs.com/xiaoqi/p/gitlab-flow.html">GitLab Flow 介紹</a></li><li><a href="https://www.cnblogs.com/FLY_DREAM/p/17280256.html">GitLab Flow Best Practices</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10228195">GIT 團隊協作 談 流程管理 03 GitLab Flow</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>devOps</category>
      
    </categories>
    
    
    <tags>
      
      <tag>devOps</tag>
      
      <tag>git</tag>
      
      <tag>workflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub Flow：簡單高效的分支管理模型</title>
    <link href="/devOps/20240915/277537605/"/>
    <url>/devOps/20240915/277537605/</url>
    
    <content type="html"><![CDATA[<h2 id="GitHub-Flow：簡單高效的分支管理模型"><a href="#GitHub-Flow：簡單高效的分支管理模型" class="headerlink" title="GitHub Flow：簡單高效的分支管理模型"></a>GitHub Flow：簡單高效的分支管理模型</h2><p><img src="/images/git/06-github-flow.webp" alt="GitHub Flow 流程圖"></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>GitHub Flow 是一種輕量級、基於分支的工作流程，適用於需要快速集成和持續發佈的專案。它由 GitHub 的工程師 Scott Chacon 提出，強調簡單性和靈活性。與 Git Flow 相比，GitHub Flow 更加簡潔，只使用 <code>master</code> 和 <code>feature</code> 分支，適合小型專案和快速迭代的開發環境。</p><h3 id="GitHub-Flow-的基本概念"><a href="#GitHub-Flow-的基本概念" class="headerlink" title="GitHub Flow 的基本概念"></a>GitHub Flow 的基本概念</h3><p>GitHub Flow 的核心思想是：</p><ol><li>一切都在 <code>master</code> 分支上進行。</li><li>創建一個新的分支來開發新功能或修復 bug。</li><li>當開發完成時，發起一個 Pull Request 請求合併。</li><li>在 Pull Request 中進行代碼審查和測試。</li><li>如果代碼審查通過，就可以合併到 <code>master</code> 分支。</li><li>合併後，<code>master</code> 分支上的代碼就可以部署到生產環境了。</li></ol><h3 id="GitHub-Flow-大略流程圖"><a href="#GitHub-Flow-大略流程圖" class="headerlink" title="GitHub Flow 大略流程圖"></a>GitHub Flow 大略流程圖</h3><pre class="mermaid">graph TD    A[Master] --> B[Create Feature Branch]    B --> C[Develop Feature]    C --> D[Push Feature Branch]    D --> E[Create Pull Request]    E --> F[Code Review]    F --> G{Approval?}    G -->|Yes| H[Merge to Master]    G -->|No| I[Request Changes]    H --> J[Deploy to Production]</pre><p><img src="/images/git/06-github-flow.png" alt="GitHub Flow 流程圖"></p><h3 id="如何使用-GitHub-Flow"><a href="#如何使用-GitHub-Flow" class="headerlink" title="如何使用 GitHub Flow"></a>如何使用 GitHub Flow</h3><ol><li><p><strong>從 <code>master</code> 分支創建一個新的分支</strong>:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b feature/new-feature<br></code></pre></td></tr></table></figure></li><li><p><strong>在新分支上進行開發和提交</strong>:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;Add new feature&quot;</span><br>git push origin feature/new-feature<br></code></pre></td></tr></table></figure></li><li><p><strong>在 GitHub 上發起一個 Pull Request</strong>:</p><ul><li>在 GitHub 頁面上，點擊 <code>Compare &amp; pull request</code> 按鈕。</li><li>填寫 PR 標題和描述，描述本次 PR 的內容。</li></ul></li><li><p><strong>在 PR 頁面進行代碼審查和測試</strong>:</p><ul><li>其他開發者可以查看變更內容並進行代碼審查。</li><li>可以運行自動化測試來確保新功能的正確性。</li></ul></li><li><p><strong>合併 PR 到 <code>master</code> 分支</strong>:</p><ul><li>如果代碼審查通過，就可以點擊 <code>Merge pull request</code> 按鈕將分支合併到 <code>master</code>。</li><li>合併後，<code>master</code> 分支上的代碼就是最新的版本。</li></ul></li><li><p><strong>部署到生產環境</strong>:</p><ul><li>合併到 <code>master</code> 後，可以自動部署到生產環境。</li><li>可以結合 CI&#x2F;CD 工具來自動化部署流程。</li></ul></li></ol><h3 id="優點和缺點"><a href="#優點和缺點" class="headerlink" title="優點和缺點"></a>優點和缺點</h3><h4 id="優點"><a href="#優點" class="headerlink" title="優點"></a>優點</h4><ul><li><strong>簡單易用</strong>：只使用 <code>master</code> 和 <code>feature</code> 分支，流程簡單明了。</li><li><strong>靈活性高</strong>：適合快速迭代和持續發佈的開發環境。</li><li><strong>適合小型專案</strong>：對於小型專案或單人開發，GitHub Flow 更加輕量。</li><li><strong>促進代碼審查</strong>：Pull Request 強化了團隊內部的代碼審查機制，提高代碼質量。</li></ul><h4 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h4><ul><li><strong>不適合大型專案</strong>：對於需要明確版本發佈和多個穩定分支的大型專案，GitHub Flow 可能不太適合。</li><li><strong>缺乏版本控制</strong>：沒有 Git Flow 中的 <code>develop</code> 和 <code>release</code> 分支，可能會影響版本管理。</li><li><strong>依賴持續部署</strong>：需要穩定的部署環境和自動化工具支持，否則部署流程可能會混亂。</li></ul><h3 id="實際案例"><a href="#實際案例" class="headerlink" title="實際案例"></a>實際案例</h3><h4 id="案例一：快速迭代的-Web-應用開發"><a href="#案例一：快速迭代的-Web-應用開發" class="headerlink" title="案例一：快速迭代的 Web 應用開發"></a>案例一：快速迭代的 Web 應用開發</h4><p>在一個需要頻繁發布新功能的 Web 應用專案中，團隊採用 GitHub Flow 來管理分支和發佈流程。每個新功能都在獨立的 Feature 分支上開發，完成後通過 Pull Request 合併到 <code>master</code> 分支，並立即部署到生產環境。這種方式使得團隊能夠快速迭代，迅速響應市場需求。</p><h4 id="案例二：協作開發中的代碼審查"><a href="#案例二：協作開發中的代碼審查" class="headerlink" title="案例二：協作開發中的代碼審查"></a>案例二：協作開發中的代碼審查</h4><p>在一個多開發者協作的專案中，團隊使用 GitHub Flow 來管理分支。每個開發者在自己的 Feature 分支上工作，完成後通過 Pull Request 提交代碼，其他團隊成員進行審查和測試。這不僅提升了代碼質量，還促進了團隊內部的知識共享和協作。</p><h3 id="實作示例"><a href="#實作示例" class="headerlink" title="實作示例"></a>實作示例</h3><p>以下是使用 GitHub Flow 的具體步驟示例：</p><h4 id="步驟-1：從-master-創建新分支"><a href="#步驟-1：從-master-創建新分支" class="headerlink" title="步驟 1：從 master 創建新分支"></a>步驟 1：從 <code>master</code> 創建新分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b feature/signup-system<br></code></pre></td></tr></table></figure><h4 id="步驟-2：在新分支上開發和提交"><a href="#步驟-2：在新分支上開發和提交" class="headerlink" title="步驟 2：在新分支上開發和提交"></a>步驟 2：在新分支上開發和提交</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;Add signup feature&quot;</span><br>git push origin feature/signup-system<br></code></pre></td></tr></table></figure><h4 id="步驟-3：發起-Pull-Request"><a href="#步驟-3：發起-Pull-Request" class="headerlink" title="步驟 3：發起 Pull Request"></a>步驟 3：發起 Pull Request</h4><ul><li>在 GitHub 上，點擊 <code>Compare &amp; pull request</code> 按鈕。</li><li>填寫 PR 標題和詳細描述。</li></ul><h4 id="步驟-4：代碼審查和測試"><a href="#步驟-4：代碼審查和測試" class="headerlink" title="步驟 4：代碼審查和測試"></a>步驟 4：代碼審查和測試</h4><ul><li>其他團隊成員審查代碼。</li><li>運行自動化測試，確保功能正常。</li></ul><h4 id="步驟-5：合併-Pull-Request"><a href="#步驟-5：合併-Pull-Request" class="headerlink" title="步驟 5：合併 Pull Request"></a>步驟 5：合併 Pull Request</h4><ul><li>點擊 <code>Merge pull request</code>，將 <code>feature/signup-system</code> 合併到 <code>master</code>。</li></ul><h4 id="步驟-6：部署到生產環境"><a href="#步驟-6：部署到生產環境" class="headerlink" title="步驟 6：部署到生產環境"></a>步驟 6：部署到生產環境</h4><ul><li>合併後，自動部署到生產環境，使用戶可以立即使用新功能。</li></ul><h3 id="工具和插件推薦"><a href="#工具和插件推薦" class="headerlink" title="工具和插件推薦"></a>工具和插件推薦</h3><p>為了更好地實現 GitHub Flow，以下是一些推薦的工具和插件：</p><ul><li><strong>GitHub Actions</strong>：自動化工作流程工具，支援自動測試和部署。</li><li><strong>Travis CI</strong>：持續整合工具，與 GitHub 無縫集成。</li><li><strong>Jenkins</strong>：靈活的自動化服務器，適合複雜的 CI&#x2F;CD 流程。</li><li><strong>Pull Request Template</strong>：使用模板來標準化 PR 描述，提升審查效率。</li><li><strong>GitHub Apps</strong>：如 CodeClimate、Snyk 等，提升代碼質量和安全性。</li></ul><h3 id="最佳實踐提示"><a href="#最佳實踐提示" class="headerlink" title="最佳實踐提示"></a>最佳實踐提示</h3><ul><li><strong>保持 <code>master</code> 分支穩定</strong>：確保 <code>master</code> 分支始終處於可部署狀態，所有合併的變更都經過充分測試。</li><li><strong>小步快跑</strong>：將變更拆分為小的、可管理的 Feature 分支，便於審查和測試。</li><li><strong>自動化測試與部署</strong>：結合 CI&#x2F;CD 工具，自動化代碼測試和部署流程，提升效率和可靠性。</li><li><strong>代碼審查</strong>：通過 Pull Request 進行代碼審查，確保代碼質量和一致性。</li><li><strong>清晰的 PR 描述</strong>：在 Pull Request 中詳細描述變更內容和原因，幫助審查者更好地理解變更。</li></ul><h3 id="常見問題解答"><a href="#常見問題解答" class="headerlink" title="常見問題解答"></a>常見問題解答</h3><h4 id="問：GitHub-Flow-適用於哪些專案？"><a href="#問：GitHub-Flow-適用於哪些專案？" class="headerlink" title="問：GitHub Flow 適用於哪些專案？"></a>問：GitHub Flow 適用於哪些專案？</h4><p>答：GitHub Flow 適用於需要快速迭代和持續部署的小型至中型專案，特別是 Web 應用和 SaaS 產品。</p><h4 id="問：如果需要明確的版本發佈，是否應該使用-GitHub-Flow？"><a href="#問：如果需要明確的版本發佈，是否應該使用-GitHub-Flow？" class="headerlink" title="問：如果需要明確的版本發佈，是否應該使用 GitHub Flow？"></a>問：如果需要明確的版本發佈，是否應該使用 GitHub Flow？</h4><p>答：如果專案需要明確的版本發佈和多個穩定分支，建議使用 Git Flow 或 GitLab Flow，而非 GitHub Flow。</p><h4 id="問：如何在-GitHub-Flow-中處理熱修復？"><a href="#問：如何在-GitHub-Flow-中處理熱修復？" class="headerlink" title="問：如何在 GitHub Flow 中處理熱修復？"></a>問：如何在 GitHub Flow 中處理熱修復？</h4><p>答：在 GitHub Flow 中，熱修復可以通過直接在 <code>master</code> 分支上創建一個臨時的 Hotfix 分支來進行，完成後立即合併回 <code>master</code> 分支並部署。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>GitHub Flow 是一種簡單高效的分支管理模型，適合小型專案和快速迭代的開發環境。它強調簡單性和靈活性，只使用 <code>master</code> 和 <code>feature</code> 分支，通過 Pull Request 進行代碼審查和合併。GitHub Flow 適合需要持續集成和持續部署的專案，能夠幫助開發團隊提高效率和響應速度。</p><h3 id="參考資源"><a href="#參考資源" class="headerlink" title="參考資源"></a>參考資源</h3><ul><li><a href="https://guides.github.com/introduction/flow/">GitHub Flow 官方文件</a></li><li><a href="https://git-scm.com/book/zh/v2/GitHub-flow">Pro Git 書籍 - GitHub Flow</a></li><li><a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">GitHub Flow vs Git Flow vs GitLab Flow</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10228090">GIT 團隊協作 談 流程管理 02 GitHub Flow</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>devOps</category>
      
    </categories>
    
    
    <tags>
      
      <tag>devOps</tag>
      
      <tag>git</tag>
      
      <tag>workflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git Flow：完整的分支管理模型</title>
    <link href="/devOps/20240915/2194877756/"/>
    <url>/devOps/20240915/2194877756/</url>
    
    <content type="html"><![CDATA[<h2 id="Git-Flow：完整的分支管理模型"><a href="#Git-Flow：完整的分支管理模型" class="headerlink" title="Git Flow：完整的分支管理模型"></a>Git Flow：完整的分支管理模型</h2><p><img src="/images/git/05-git-flow.png" alt="Git Flow 流程圖"></p><h3 id="文章概覽"><a href="#文章概覽" class="headerlink" title="文章概覽"></a>文章概覽</h3><p>在本篇文章中，您將學習到：</p><ul><li>Git Flow 的基本概念與流程</li><li>各類分支的用途（feature、develop、release、hotfix、master）</li><li>如何在實際專案中應用 Git Flow</li><li>Git Flow 的優缺點</li><li>與其他分支模型的比較</li></ul><h3 id="Git-Flow-的基本概念與流程"><a href="#Git-Flow-的基本概念與流程" class="headerlink" title="Git Flow 的基本概念與流程"></a>Git Flow 的基本概念與流程</h3><h4 id="Git-Flow-概述"><a href="#Git-Flow-概述" class="headerlink" title="Git Flow 概述"></a>Git Flow 概述</h4><p>Git Flow 是一種分支管理模型，由 Vincent Driessen 提出，旨在幫助團隊在複雜的開發環境中有效地管理分支和版本。它基於 Git 的分支機制，並定義了一套明確的流程和分支用途。Git Flow 主要包含兩個長期存在的分支：<code>master</code> 和 <code>develop</code>，這兩個分支在整個專案生命周期中始終存在，並各自承擔不同的角色。</p><h4 id="Git-Flow-流程圖"><a href="#Git-Flow-流程圖" class="headerlink" title="Git Flow 流程圖"></a>Git Flow 流程圖</h4><pre class="mermaid">graph TD    A[Master] --> B[Develop]    B --> C[Feature]    B --> D[Release]    D --> A    B --> E[Hotfix]    E --> A</pre><p><img src="/images/git/05-git-flow2.png" alt="Git Flow 流程圖"></p><h3 id="各類分支的用途"><a href="#各類分支的用途" class="headerlink" title="各類分支的用途"></a>各類分支的用途</h3><h4 id="Master-分支"><a href="#Master-分支" class="headerlink" title="Master 分支"></a>Master 分支</h4><ul><li><strong>用途</strong>：存放生產環境的穩定版本。</li><li><strong>特點</strong>：只能接受從 Release 或 Hotfix 分支合併的變更，確保每個版本都是經過測試和穩定的。</li></ul><h4 id="Develop-分支"><a href="#Develop-分支" class="headerlink" title="Develop 分支"></a>Develop 分支</h4><ul><li><strong>用途</strong>：整合所有功能分支的變更，作為下一個發佈版本的基礎。</li><li><strong>特點</strong>：是開發人員進行日常開發和整合的主要分支，所有新功能的開發都基於此分支進行。</li></ul><h4 id="Feature-分支"><a href="#Feature-分支" class="headerlink" title="Feature 分支"></a>Feature 分支</h4><ul><li><strong>用途</strong>：用於開發新功能或修復特定問題。</li><li><strong>命名規則</strong>：<code>feature/&lt;功能名稱&gt;</code>，例如 <code>feature/login</code></li><li><strong>生命周期</strong>：從 Develop 分支創建，完成開發後合併回 Develop 分支。</li></ul><h4 id="Release-分支"><a href="#Release-分支" class="headerlink" title="Release 分支"></a>Release 分支</h4><ul><li><strong>用途</strong>：準備新版本的發佈，進行最終測試和修正。</li><li><strong>命名規則</strong>：<code>release/&lt;版本號&gt;</code>，例如 <code>release/1.0.0</code></li><li><strong>生命周期</strong>：從 Develop 分支創建，完成後合併回 Master 和 Develop 分支。</li></ul><h4 id="Hotfix-分支"><a href="#Hotfix-分支" class="headerlink" title="Hotfix 分支"></a>Hotfix 分支</h4><ul><li><strong>用途</strong>：緊急修復生產環境中的問題。</li><li><strong>命名規則</strong>：<code>hotfix/&lt;修復名稱&gt;</code>，例如 <code>hotfix/login-bug</code></li><li><strong>生命周期</strong>：從 Master 分支創建，完成後合併回 Master 和 Develop 分支。</li></ul><h3 id="如何在實際專案中應用-Git-Flow"><a href="#如何在實際專案中應用-Git-Flow" class="headerlink" title="如何在實際專案中應用 Git Flow"></a>如何在實際專案中應用 Git Flow</h3><h4 id="初始化-Git-Flow"><a href="#初始化-Git-Flow" class="headerlink" title="初始化 Git Flow"></a>初始化 Git Flow</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git flow init<br></code></pre></td></tr></table></figure><p>按照提示設置分支前綴，通常使用默認設置即可。</p><h4 id="創建功能分支"><a href="#創建功能分支" class="headerlink" title="創建功能分支"></a>創建功能分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git flow feature start &lt;feature-name&gt;<br></code></pre></td></tr></table></figure><h4 id="完成功能分支並合併回-Develop"><a href="#完成功能分支並合併回-Develop" class="headerlink" title="完成功能分支並合併回 Develop"></a>完成功能分支並合併回 Develop</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git flow feature finish &lt;feature-name&gt;<br></code></pre></td></tr></table></figure><h4 id="創建-Release-分支"><a href="#創建-Release-分支" class="headerlink" title="創建 Release 分支"></a>創建 Release 分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git flow release start &lt;version&gt;<br></code></pre></td></tr></table></figure><h4 id="完成-Release-分支並合併回-Master-和-Develop"><a href="#完成-Release-分支並合併回-Master-和-Develop" class="headerlink" title="完成 Release 分支並合併回 Master 和 Develop"></a>完成 Release 分支並合併回 Master 和 Develop</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git flow release finish &lt;version&gt;<br></code></pre></td></tr></table></figure><h4 id="創建-Hotfix-分支"><a href="#創建-Hotfix-分支" class="headerlink" title="創建 Hotfix 分支"></a>創建 Hotfix 分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git flow hotfix start &lt;hotfix-name&gt;<br></code></pre></td></tr></table></figure><h4 id="完成-Hotfix-分支並合併回-Master-和-Develop"><a href="#完成-Hotfix-分支並合併回-Master-和-Develop" class="headerlink" title="完成 Hotfix 分支並合併回 Master 和 Develop"></a>完成 Hotfix 分支並合併回 Master 和 Develop</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git flow hotfix finish &lt;hotfix-name&gt;<br></code></pre></td></tr></table></figure><h3 id="Git-Flow-的優缺點"><a href="#Git-Flow-的優缺點" class="headerlink" title="Git Flow 的優缺點"></a>Git Flow 的優缺點</h3><h4 id="優點"><a href="#優點" class="headerlink" title="優點"></a>優點</h4><ul><li><strong>結構明確</strong>：明確的分支命名和用途，方便團隊協作。</li><li><strong>版本控制</strong>：有效管理版本發佈，降低生產環境風險。</li><li><strong>靈活性</strong>：適用於中大型專案，支持多個並行開發任務。</li></ul><h4 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h4><ul><li><strong>複雜性</strong>：對於小型專案或單人開發可能過於繁瑣。</li><li><strong>流程固定</strong>：需要嚴格遵循流程，對團隊協作要求較高。</li></ul><h3 id="與其他分支模型的比較"><a href="#與其他分支模型的比較" class="headerlink" title="與其他分支模型的比較"></a>與其他分支模型的比較</h3><h4 id="Git-Flow-vs-GitHub-Flow"><a href="#Git-Flow-vs-GitHub-Flow" class="headerlink" title="Git Flow vs GitHub Flow"></a>Git Flow vs GitHub Flow</h4><ul><li><strong>Git Flow</strong> 更適合需要明確版本發佈和多個穩定分支的大型專案。</li><li><strong>GitHub Flow</strong> 更簡潔，適合持續部署和小型專案，只有 Master 和 Feature 分支。</li></ul><h4 id="Git-Flow-vs-GitLab-Flow"><a href="#Git-Flow-vs-GitLab-Flow" class="headerlink" title="Git Flow vs GitLab Flow"></a>Git Flow vs GitLab Flow</h4><ul><li><strong>GitLab Flow</strong> 結合了 Git Flow 和 GitHub Flow 的優點，提供更多靈活性，支持不同的工作流程模式。</li></ul><h3 id="實際案例"><a href="#實際案例" class="headerlink" title="實際案例"></a>實際案例</h3><h4 id="案例一：功能分支的合併"><a href="#案例一：功能分支的合併" class="headerlink" title="案例一：功能分支的合併"></a>案例一：功能分支的合併</h4><p>假設您有一個功能分支 <code>feature-login</code>，該分支完成了用戶登入功能的開發。現在，您需要將其合併到 <code>develop</code> 分支。</p><h5 id="使用-Git-Flow-創建並合併功能分支"><a href="#使用-Git-Flow-創建並合併功能分支" class="headerlink" title="使用 Git Flow 創建並合併功能分支"></a>使用 Git Flow 創建並合併功能分支</h5><ol><li><p>創建功能分支：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git flow feature start login<br></code></pre></td></tr></table></figure></li><li><p>完成功能開發後，合併回 Develop：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git flow feature finish login<br></code></pre></td></tr></table></figure></li><li><p>這將自動合併 <code>feature-login</code> 分支到 <code>develop</code> 分支，並刪除功能分支。</p></li></ol><h4 id="案例二：發布新版本"><a href="#案例二：發布新版本" class="headerlink" title="案例二：發布新版本"></a>案例二：發布新版本</h4><ol><li><p>創建 Release 分支：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git flow release start 1.0.0<br></code></pre></td></tr></table></figure></li><li><p>在 Release 分支上進行最終測試和修正。</p></li><li><p>完成 Release 分支，合併回 Master 和 Develop：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git flow release finish 1.0.0<br></code></pre></td></tr></table></figure></li><li><p>這將自動合併 Release 分支到 <code>master</code> 和 <code>develop</code> 分支，並打上版本標籤 <code>v1.0.0</code>。</p></li></ol><h4 id="案例三：緊急修復"><a href="#案例三：緊急修復" class="headerlink" title="案例三：緊急修復"></a>案例三：緊急修復</h4><ol><li><p>創建 Hotfix 分支：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git flow hotfix start fix-login-bug<br></code></pre></td></tr></table></figure></li><li><p>修復生產環境中的登入錯誤。</p></li><li><p>完成 Hotfix 分支，合併回 Master 和 Develop：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git flow hotfix finish fix-login-bug<br></code></pre></td></tr></table></figure></li><li><p>這將自動合併 Hotfix 分支到 <code>master</code> 和 <code>develop</code> 分支，並打上版本標籤（如 <code>v1.0.1</code>）。</p></li></ol><h3 id="最佳實踐提示"><a href="#最佳實踐提示" class="headerlink" title="最佳實踐提示"></a>最佳實踐提示</h3><ul><li><strong>遵循命名規則</strong>：使用一致的分支命名規則，如 <code>feature/&lt;name&gt;</code>、<code>release/&lt;version&gt;</code>、<code>hotfix/&lt;name&gt;</code>，以保持分支結構的清晰。</li><li><strong>定期同步 Develop 分支</strong>：確保 Develop 分支保持最新，定期從 Master 分支合併或變基，減少合併衝突。</li><li><strong>代碼審查與測試</strong>：在合併分支前，通過 Pull Request 進行代碼審查和測試，確保代碼質量和穩定性。</li><li><strong>自動化部署</strong>：結合 CI&#x2F;CD 工具，自動化 Release 和 Hotfix 的部署流程，提升發佈效率和可靠性。</li></ul><h3 id="常見問題解答"><a href="#常見問題解答" class="headerlink" title="常見問題解答"></a>常見問題解答</h3><h4 id="問：Git-Flow-適用於哪些專案？"><a href="#問：Git-Flow-適用於哪些專案？" class="headerlink" title="問：Git Flow 適用於哪些專案？"></a>問：Git Flow 適用於哪些專案？</h4><p>答：Git Flow 適用於中大型專案，特別是那些需要明確版本發佈和多個穩定分支的專案。對於小型專案或快速迭代的環境，可能需要選擇更簡潔的分支管理策略，如 GitHub Flow 或 GitLab Flow。</p><h4 id="問：如果我的團隊不使用-Git-Flow，會有什麼影響？"><a href="#問：如果我的團隊不使用-Git-Flow，會有什麼影響？" class="headerlink" title="問：如果我的團隊不使用 Git Flow，會有什麼影響？"></a>問：如果我的團隊不使用 Git Flow，會有什麼影響？</h4><p>答：如果不使用 Git Flow，團隊需要自行制定分支管理策略，可能會導致分支結構混亂或版本管理不當。使用 Git Flow 可以提供一套成熟的分支管理模型，幫助團隊更有條理地管理開發流程。</p><h4 id="問：Git-Flow-和-GitHub-Flow-可以結合使用嗎？"><a href="#問：Git-Flow-和-GitHub-Flow-可以結合使用嗎？" class="headerlink" title="問：Git Flow 和 GitHub Flow 可以結合使用嗎？"></a>問：Git Flow 和 GitHub Flow 可以結合使用嗎？</h4><p>答：可以根據專案需求靈活結合使用。例如，可以在 Git Flow 的基礎上，採用 GitHub Flow 的簡化流程來處理某些特定的開發任務，提升整體的靈活性和效率。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>Git Flow 提供了一套完整且結構化的分支管理模型，適用於中大型專案和需要明確版本發佈的團隊。通過明確分支的用途和流程，Git Flow 有助於提升團隊協作效率，降低發佈風險。然而，對於小型專案或快速迭代的環境，可能需要選擇更簡潔的分支管理策略，如 GitHub Flow 或 GitLab Flow。</p><h3 id="參考資源"><a href="#參考資源" class="headerlink" title="參考資源"></a>參考資源</h3><ul><li><a href="https://nvie.com/posts/a-successful-git-branching-model/">Git Flow 官方文件</a></li><li><a href="https://git-scm.com/book/zh/v2/Git-Branching-Branch-Management">Pro Git 書籍 - Git Flow</a></li><li><a href="https://git-scm.com/book/zh/v2/GitHub-flow">Pro Git 書籍 - GitHub Flow</a></li><li><a href="https://git-scm.com/book/zh/v2/GitLab-flow">Pro Git 書籍 - GitLab Flow</a></li><li><a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">Git Flow vs GitHub Flow vs GitLab Flow</a></li><li><a href="https://terryyaowork.github.io/devOps/20240915/3260762878/">Git Merge 與 Git Rebase 的差異與應用</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10281080">常見的三種工作流程 - Git flow、GitHub Flow 與 Gitlab Flow - iT 邦幫忙</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10227605">GIT 團隊協作 談 流程管理 01 GitFlow</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>devOps</category>
      
    </categories>
    
    
    <tags>
      
      <tag>devOps</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git Merge 與 Git Rebase 的差異與應用</title>
    <link href="/devOps/20240915/3260762878/"/>
    <url>/devOps/20240915/3260762878/</url>
    
    <content type="html"><![CDATA[<h2 id="Git-Merge-與-Git-Rebase-的差異與應用"><a href="#Git-Merge-與-Git-Rebase-的差異與應用" class="headerlink" title="Git Merge 與 Git Rebase 的差異與應用"></a>Git Merge 與 Git Rebase 的差異與應用</h2><p><img src="/images/git/04-merge-rebase.webp" alt="merge &amp; rebase"></p><h3 id="文章概覽"><a href="#文章概覽" class="headerlink" title="文章概覽"></a>文章概覽</h3><p>在本篇文章中，您將學習到：</p><ul><li>Git Merge 與 Git Rebase 的基本概念</li><li>各自的優缺點</li><li>何時使用 Git Merge 何時使用 Git Rebase</li><li>實際操作示例</li><li>對團隊協作的影響</li></ul><h3 id="Git-Merge-與-Git-Rebase-的基本概念"><a href="#Git-Merge-與-Git-Rebase-的基本概念" class="headerlink" title="Git Merge 與 Git Rebase 的基本概念"></a>Git Merge 與 Git Rebase 的基本概念</h3><h4 id="Git-Merge"><a href="#Git-Merge" class="headerlink" title="Git Merge"></a>Git Merge</h4><ul><li><strong>定義</strong>：將兩個分支的歷史合併到一起，保留各自的提交歷史。</li><li><strong>作用</strong>：保持分支的歷史記錄，顯示合併點。</li></ul><h4 id="Git-Rebase"><a href="#Git-Rebase" class="headerlink" title="Git Rebase"></a>Git Rebase</h4><ul><li><strong>定義</strong>：將一個分支的基礎更改為另一個分支的最新提交，從而形成更線性的提交歷史。</li><li><strong>作用</strong>：重寫提交歷史，避免分支的合併提交，使歷史更簡潔。</li></ul><h3 id="優缺點分析"><a href="#優缺點分析" class="headerlink" title="優缺點分析"></a>優缺點分析</h3><h4 id="分析-Git-Merge"><a href="#分析-Git-Merge" class="headerlink" title="分析 Git Merge"></a>分析 Git Merge</h4><ul><li><strong>優點</strong>：<ul><li>保留完整的分支歷史，清楚顯示合併點。</li><li>不會重寫歷史，對公共分支更安全。</li></ul></li><li><strong>缺點</strong>：<ul><li>可能導致提交歷史變得雜亂，有許多合併提交。</li><li>對於大型專案，合併衝突可能較多。</li></ul></li></ul><h4 id="分析-Git-Rebase"><a href="#分析-Git-Rebase" class="headerlink" title="分析 Git Rebase"></a>分析 Git Rebase</h4><ul><li><strong>優點</strong>：<ul><li>生成更簡潔、線性的提交歷史，易於閱讀和理解。</li><li>避免不必要的合併提交，使歷史更乾淨。</li></ul></li><li><strong>缺點</strong>：<ul><li>會重寫提交歷史，對於公共分支可能導致問題。</li><li>使用不當可能丟失提交或引入錯誤。</li></ul></li></ul><h3 id="應用場景"><a href="#應用場景" class="headerlink" title="應用場景"></a>應用場景</h3><h4 id="何時使用-Git-Merge"><a href="#何時使用-Git-Merge" class="headerlink" title="何時使用 Git Merge"></a>何時使用 Git Merge</h4><ul><li>當您希望保留分支的完整歷史記錄時。</li><li>在公共分支上進行合併，避免歷史重寫帶來的問題。</li><li>當分支之間的差異較大且合併衝突可能較多時。</li></ul><h4 id="何時使用-Git-Rebase"><a href="#何時使用-Git-Rebase" class="headerlink" title="何時使用 Git Rebase"></a>何時使用 Git Rebase</h4><ul><li>當您希望保持提交歷史的線性和簡潔時。</li><li>在私有分支上進行變基操作，確保不影響其他團隊成員。</li><li>當您需要整合最新的主分支變更到功能分支時。</li></ul><h3 id="實際操作示例"><a href="#實際操作示例" class="headerlink" title="實際操作示例"></a>實際操作示例</h3><h4 id="操作-Git-Merge"><a href="#操作-Git-Merge" class="headerlink" title="操作 Git Merge"></a>操作 Git Merge</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout main<br>git merge feature-branch<br></code></pre></td></tr></table></figure><h4 id="操作-Git-Rebase"><a href="#操作-Git-Rebase" class="headerlink" title="操作 Git Rebase"></a>操作 Git Rebase</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout feature-branch<br>git rebase main<br></code></pre></td></tr></table></figure><h3 id="實際案例"><a href="#實際案例" class="headerlink" title="實際案例"></a>實際案例</h3><h4 id="案例一：功能分支的合併"><a href="#案例一：功能分支的合併" class="headerlink" title="案例一：功能分支的合併"></a>案例一：功能分支的合併</h4><p>假設您有一個功能分支 <code>feature-login</code>，該分支完成了用戶登入功能的開發。現在，您需要將其合併到 <code>main</code> 分支。</p><h5 id="使用-Git-Merge"><a href="#使用-Git-Merge" class="headerlink" title="使用 Git Merge"></a>使用 Git Merge</h5><ol><li><p>切換到 <code>main</code> 分支：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout main<br></code></pre></td></tr></table></figure></li><li><p>合併 <code>feature-login</code> 分支：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge feature-login<br></code></pre></td></tr></table></figure></li><li><p>這將在 <code>main</code> 分支上創建一個新的合併提交，保留所有提交歷史。</p></li></ol><h5 id="使用-Git-Rebase"><a href="#使用-Git-Rebase" class="headerlink" title="使用 Git Rebase"></a>使用 Git Rebase</h5><ol><li><p>切換到 <code>feature-login</code> 分支：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout feature-login<br></code></pre></td></tr></table></figure></li><li><p>變基到 <code>main</code> 分支：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rebase main<br></code></pre></td></tr></table></figure></li><li><p>解決任何可能出現的衝突，然後完成變基。</p></li><li><p>切換回 <code>main</code> 分支並快進合併：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout main<br>git merge feature-login<br></code></pre></td></tr></table></figure></li><li><p>這將不會創建新的合併提交，提交歷史更加線性。</p></li></ol><h3 id="對團隊協作的影響"><a href="#對團隊協作的影響" class="headerlink" title="對團隊協作的影響"></a>對團隊協作的影響</h3><ul><li><p><strong>Git Merge</strong>：</p><ul><li>保留完整的歷史記錄，便於追蹤變更和合併點。</li><li>更適合團隊協作中的公共分支，避免歷史重寫的風險。</li></ul></li><li><p><strong>Git Rebase</strong>：</p><ul><li>生成更乾淨的提交歷史，便於代碼審查和維護。</li><li>在協作過程中使用需謹慎，避免對公共分支進行變基操作。</li></ul></li></ul><h3 id="最佳實踐提示"><a href="#最佳實踐提示" class="headerlink" title="最佳實踐提示"></a>最佳實踐提示</h3><ul><li><strong>使用 Rebase 保持歷史清晰</strong>：在個人功能分支上使用 Rebase，可以保持提交歷史的線性和清晰。</li><li><strong>避免在公共分支上使用 Rebase</strong>：對於已經推送到遠端的分支，避免使用 Rebase，以防止影響其他協作者。</li><li><strong>經常同步主分支</strong>：無論是使用 Merge 還是 Rebase，經常將主分支的變更同步到功能分支，有助於減少合併衝突。</li><li><strong>使用 Pull Request 進行代碼審查</strong>：在合併分支前，通過 Pull Request 進行代碼審查，確保代碼質量和一致性。</li></ul><h3 id="常見問題解答"><a href="#常見問題解答" class="headerlink" title="常見問題解答"></a>常見問題解答</h3><h4 id="問：如果在-Rebase-過程中遇到衝突，應該怎麼辦？"><a href="#問：如果在-Rebase-過程中遇到衝突，應該怎麼辦？" class="headerlink" title="問：如果在 Rebase 過程中遇到衝突，應該怎麼辦？"></a>問：如果在 Rebase 過程中遇到衝突，應該怎麼辦？</h4><p>答：在遇到衝突時，Git 會提示您哪些文件有衝突。您需要手動編輯這些文件，解決衝突後，使用 <code>git add</code> 添加解決後的文件，然後繼續變基過程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add &lt;file&gt;<br>git rebase --<span class="hljs-built_in">continue</span><br></code></pre></td></tr></table></figure><h4 id="問：Rebase-會刪除分支的歷史記錄嗎？"><a href="#問：Rebase-會刪除分支的歷史記錄嗎？" class="headerlink" title="問：Rebase 會刪除分支的歷史記錄嗎？"></a>問：Rebase 會刪除分支的歷史記錄嗎？</h4><p>答：Rebase 不會刪除歷史記錄，但會重寫提交歷史，使其看起來更線性。這意味著原有的提交會被新的提交取代。</p><h4 id="問：什麼時候應該選擇-Merge，什麼時候應該選擇-Rebase？"><a href="#問：什麼時候應該選擇-Merge，什麼時候應該選擇-Rebase？" class="headerlink" title="問：什麼時候應該選擇 Merge，什麼時候應該選擇 Rebase？"></a>問：什麼時候應該選擇 Merge，什麼時候應該選擇 Rebase？</h4><p>答：如果您希望保留分支的完整歷史記錄，並且不介意有合併提交，可以選擇 Merge。若您希望提交歷史更線性，且主要在個人分支上工作，可以選擇 Rebase。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>Git Merge 和 Git Rebase 各有優缺點，適用於不同的場景。理解它們的差異和應用場景，能夠幫助開發者更有效地管理分支和版本控制。選擇合適的策略，不僅能提升開發效率，還能保持提交歷史的清晰和可讀性。建議在團隊中制定明確的分支管理策略，根據專案需求選擇最適合的方法。</p><hr><h2 id="參考資源"><a href="#參考資源" class="headerlink" title="參考資源"></a>參考資源</h2><ul><li><a href="https://git-scm.com/docs/git-merge">Git Merge 官方文件</a></li><li><a href="https://git-scm.com/docs/git-rebase">Git Rebase 官方文件</a></li><li><a href="https://git-scm.com/book/zh/v2/Git-Branching-Merging">Pro Git 書籍 - Git Merge</a></li><li><a href="https://git-scm.com/book/zh/v2/Git-Branching-Rebasing">Pro Git 書籍 - Git Rebase</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>devOps</category>
      
    </categories>
    
    
    <tags>
      
      <tag>devOps</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>從開發到生產：軟體發佈的多環境策略</title>
    <link href="/devOps/20240915/196766067/"/>
    <url>/devOps/20240915/196766067/</url>
    
    <content type="html"><![CDATA[<h2 id="從開發到生產：軟體發佈的多環境策略"><a href="#從開發到生產：軟體發佈的多環境策略" class="headerlink" title="從開發到生產：軟體發佈的多環境策略"></a>從開發到生產：軟體發佈的多環境策略</h2><p><img src="/images/devOps/01-env-planning.webp" alt="基本環境規劃"></p><h3 id="文章概覽"><a href="#文章概覽" class="headerlink" title="文章概覽"></a>文章概覽</h3><p>在本篇文章中，您將學習到：</p><ul><li>各個發佈環境（DEV、SIT、UAT、PROD）的功能與角色</li><li>環境配置的最佳實踐與安全措施</li><li>版本更新與驗收的完整流程</li><li>實際案例解析，了解多環境管理在團隊協作中的應用</li><li>如何利用自動化工具提升環境管理效率</li><li>版本回滾與災難恢復策略的重要性</li></ul><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在軟體開發的過程中，妥善管理開發（Development, DEV）、系統整合測試（System Integration Testing, SIT）、使用者驗收測試（User Acceptance Testing, UAT）以及生產（Production, PROD）環境，對專案的成功至關重要。這些環境的有效管理不僅能提高開發效率，還能降低風險，確保最終產品的質量和穩定性。然而，隨著專案規模的增大和複雜性的提升，如何有效地配置和管理這些環境成為一大挑戰。本文將深入探討每個環境的功能、配置及相關的安全措施，並介紹最佳實踐，幫助讀者更清楚地理解這些環境的角色及其在軟體發佈過程中的重要性。</p><h3 id="環境配置和角色職責"><a href="#環境配置和角色職責" class="headerlink" title="環境配置和角色職責"></a>環境配置和角色職責</h3><h4 id="開發環境（Development-DEV）"><a href="#開發環境（Development-DEV）" class="headerlink" title="開發環境（Development, DEV）"></a>開發環境（Development, DEV）</h4><ul><li><strong>主要用途</strong>：供開發人員在本地進行程式碼撰寫、初步測試及除錯。</li><li><strong>資料管理</strong>：主要使用由 Faker 或 Seeder 生成的模擬數據進行測試，確保開發過程中不受真實數據限制。</li><li><strong>安全措施</strong>：因為不涉及真實用戶資料，所需的安全需求相對較低，但仍需遵循基本的安全開發流程。</li><li><strong>常用工具</strong>：開發人員通常使用 IDE（如 Visual Studio Code、IntelliJ IDEA）來進行開發。</li></ul><h4 id="系統整合測試環境（System-Integration-Testing-SIT）"><a href="#系統整合測試環境（System-Integration-Testing-SIT）" class="headerlink" title="系統整合測試環境（System Integration Testing, SIT）"></a>系統整合測試環境（System Integration Testing, SIT）</h4><ul><li><strong>主要用途</strong>：檢驗不同模組間的協作與整合是否順利，確保各部分系統能夠協同工作。</li><li><strong>資料管理</strong>：使用非生產資料進行測試，以模擬實際運行環境，並避免影響真實數據。</li><li><strong>安全措施</strong>：需設置適當的存取權限，以保護測試資料不被未授權訪問，同時確保測試環境的安全性。</li><li><strong>測試方法</strong>：常用的測試方法包括 API 測試、端到端測試和自動化測試，以確保系統各部分的協同運作，並及早發現潛在問題。</li></ul><h4 id="使用者驗收測試環境（User-Acceptance-Testing-UAT）"><a href="#使用者驗收測試環境（User-Acceptance-Testing-UAT）" class="headerlink" title="使用者驗收測試環境（User Acceptance Testing, UAT）"></a>使用者驗收測試環境（User Acceptance Testing, UAT）</h4><ul><li><strong>主要用途</strong>：讓行銷團隊和客戶驗證新功能或修正的有效性，確保產品符合用戶需求和期望。</li><li><strong>資料管理</strong>：可能使用真實資料的複本來進行測試，以確保功能在真實情境下的表現和穩定性。</li><li><strong>安全措施</strong>：實施嚴格的存取控制，確保資料安全，並限制測試人員的權限以避免資料洩漏。</li><li><strong>用戶參與</strong>：通常會邀請實際用戶參與測試，收集他們的反饋，以進一步改善產品，確保最終產品能夠滿足市場需求。</li></ul><h4 id="生產環境（Production-PROD）"><a href="#生產環境（Production-PROD）" class="headerlink" title="生產環境（Production, PROD）"></a>生產環境（Production, PROD）</h4><ul><li><strong>主要用途</strong>：運行供終端用戶使用的應用程式，確保其穩定性和可用性，並提供高品質的使用體驗。</li><li><strong>資料管理</strong>：處理真實的用戶資料，並實施必要的數據保護措施，如加密和訪問控制，以確保資料的安全性和隱私性。</li><li><strong>安全措施</strong>：需實施最嚴格的安全控制，如防火牆、入侵檢測系統（IDS）、定期安全審計等，以防止資料外洩和其他安全風險。</li><li><strong>監控措施</strong>：通常會實施監控系統，如 Prometheus、Grafana 或 New Relic，以即時檢測和處理潛在的問題，確保系統的高可用性和穩定性。</li></ul><h3 id="版本更新與驗收流程"><a href="#版本更新與驗收流程" class="headerlink" title="版本更新與驗收流程"></a>版本更新與驗收流程</h3><p>版本更新的驗收流程是確保新版本軟體在推向生產環境之前達到預定標準與功能要求的關鍵步驟。這一流程包括：</p><ol><li><strong>需求收集</strong>：確定新版本所需的功能與改進，以滿足用戶需求，並明確版本目標和範圍。</li><li><strong>測試計劃</strong>：制定詳細的測試計劃，明確測試範圍與方法，確保測試的全面性和可控性，包括單元測試、集成測試和系統測試。</li><li><strong>執行測試</strong>：在各個環境中執行測試，確保新版本的穩定性和功能的正確性，並及時修復發現的問題。</li><li><strong>回饋收集</strong>：從使用者和測試團隊收集反饋，進行必要的調整和優化，確保產品符合預期目標。</li><li><strong>最終驗收</strong>：在所有測試通過後，進行最終的版本驗收，確保軟體達到質量標準，準備推向生產環境。</li></ol><p>透過這些步驟，可以有效降低在生產環境中出現問題的風險，確保軟體的質量與可靠性，並提升用戶滿意度。</p><h3 id="實際案例"><a href="#實際案例" class="headerlink" title="實際案例"></a>實際案例</h3><h4 id="多人協作中的版本控制與環境管理"><a href="#多人協作中的版本控制與環境管理" class="headerlink" title="多人協作中的版本控制與環境管理"></a>多人協作中的版本控制與環境管理</h4><p>在多人協作的專案中，有效的版本控制和環境管理能夠確保團隊成員之間的協作順暢。例如，開發人員在 DEV 環境中進行功能開發和初步測試，完成後將代碼推送至 SIT 環境進行整合測試。經過測試團隊的驗證後，將代碼移至 UAT 環境進行最終用戶驗收，確認無誤後再推向 PROD 環境。這樣的流程能夠確保每個階段的代碼都經過充分測試，降低生產環境出現問題的風險。</p><h4 id="使用自動化工具提升環境管理效率"><a href="#使用自動化工具提升環境管理效率" class="headerlink" title="使用自動化工具提升環境管理效率"></a>使用自動化工具提升環境管理效率</h4><p>引入自動化工具如 Terraform 或 Ansible，可以自動化環境的配置和部署，確保各個環境的一致性和可重複性。例如，使用 Terraform 定義基礎設施即代碼（Infrastructure as Code, IaC），可以快速搭建和管理 DEV、SIT、UAT 和 PROD 環境，減少手動配置帶來的錯誤和不一致性，提升部署效率和可靠性。</p><h4 id="版本回滾與災難恢復策略"><a href="#版本回滾與災難恢復策略" class="headerlink" title="版本回滾與災難恢復策略"></a>版本回滾與災難恢復策略</h4><p>即使經過嚴格的測試，生產環境中仍可能出現不可預期的問題。此時，版本回滾和災難恢復策略顯得尤為重要。例如，使用 Git 進行版本控制，可以快速回滾到穩定的版本；同時，實施數據備份和故障轉移機制，可以在發生重大故障時迅速恢復服務，減少對用戶的影響。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>本文全面解析了軟體發佈過程中的多環境管理策略，涵蓋了從開發到生產各個環境的配置與管理，並介紹了版本更新與驗收的關鍵流程。通過有效的多環境管理，不僅能提升開發效率，還能確保軟體的質量與穩定性，降低專案風險。未來，隨著 DevOps 和持續交付（Continuous Delivery, CD）理念的推廣，多環境管理將在軟體開發中扮演越來越重要的角色，幫助團隊更靈活地應對變化，快速交付高品質的產品。關於 CI&#x2F;CD 的詳細策略和工具，將在未來的文章中深入探討。</p><hr><h2 id="參考資源"><a href="#參考資源" class="headerlink" title="參考資源"></a>參考資源</h2><ul><li><a href="https://www.pintech.com.tw/article_page/379/how-to-build-a-software-release-plan-complete-guide">軟體發布計劃指南</a></li><li><a href="https://asana.com/zh-tw/resources/release-management">發佈管理</a></li><li><a href="https://glossary.cncf.io/zh-tw/canary-deployment/">金絲雀部署</a></li><li><a href="https://codelove.tw/%40tony/post/Zq42b3">部署策略簡介</a></li><li><a href="https://ruddyblog.wordpress.com/2022/01/21/%E6%B7%BA%E8%AB%87%E8%BB%9F%E9%AB%94%E7%9A%84%E9%96%8B%E7%99%BC%E7%AD%96%E7%95%A5%EF%BF%BC/">淺談軟體的開發策略</a></li><li><a href="https://hackmd.io/%40hbGOogHAThW1ccddykRiNA/SkPOGCRo7?type=view">應用程式的部署跟發布</a></li><li><a href="https://git-scm.com/doc">Git 官方文件</a></li><li><a href="https://git-scm.com/book/zh/v2">Pro Git 書籍</a></li><li><a href="https://www.terraform.io/">Terraform 官方網站</a></li><li><a href="https://docs.ansible.com/">Ansible 官方文件</a></li><li><a href="https://www.jenkins.io/doc/">Jenkins 持續整合指南</a></li><li><a href="https://docs.gitlab.com/ee/ci/">GitLab CI&#x2F;CD 文檔</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>devOps</category>
      
    </categories>
    
    
    <tags>
      
      <tag>environment</tag>
      
      <tag>devOps</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入淺出進階 Git 指令：分支管理、合併策略與版本還原全攻略</title>
    <link href="/git/20240913/1497149976/"/>
    <url>/git/20240913/1497149976/</url>
    
    <content type="html"><![CDATA[<h1 id="深入淺出進階-Git-指令：分支管理、合併策略與版本還原全攻略"><a href="#深入淺出進階-Git-指令：分支管理、合併策略與版本還原全攻略" class="headerlink" title="深入淺出進階 Git 指令：分支管理、合併策略與版本還原全攻略"></a>深入淺出進階 Git 指令：分支管理、合併策略與版本還原全攻略</h1><p><img src="/images/git/03-advanced-command.webp" alt="進階語法指南"></p><p>這篇文章將介紹一些常用的進階 Git 指令，主要涵蓋分支管理、合併衝突、版本回退等操作，這些指令在日常開發中非常實用，能夠幫助您更高效地管理版本控制，提升團隊協作效率。</p><hr><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="查看所有分支"><a href="#查看所有分支" class="headerlink" title="查看所有分支"></a>查看所有分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -a<br></code></pre></td></tr></table></figure><p>這條指令會列出所有本地和遠端的分支。</p><h4 id="顯示分支詳細信息"><a href="#顯示分支詳細信息" class="headerlink" title="顯示分支詳細信息"></a>顯示分支詳細信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -vv<br></code></pre></td></tr></table></figure><p>這會顯示每個分支的最新提交及其追蹤的遠端分支，便於了解分支的狀態。</p><hr><h3 id="創建並切換到新分支"><a href="#創建並切換到新分支" class="headerlink" title="創建並切換到新分支"></a>創建並切換到新分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b new-branch-name<br></code></pre></td></tr></table></figure><p>這條指令會創建一個新的分支並立即切換到該分支，方便快速開始新功能的開發。</p><hr><h3 id="刪除本地分支"><a href="#刪除本地分支" class="headerlink" title="刪除本地分支"></a>刪除本地分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -d branch-name<br></code></pre></td></tr></table></figure><p>若該分支有未合併的變更，可強制刪除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -D branch-name<br></code></pre></td></tr></table></figure><hr><h3 id="重命名分支"><a href="#重命名分支" class="headerlink" title="重命名分支"></a>重命名分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -m new-branch-name<br></code></pre></td></tr></table></figure><p>這會將當前分支重命名。</p><hr><h3 id="推送新分支到遠端"><a href="#推送新分支到遠端" class="headerlink" title="推送新分支到遠端"></a>推送新分支到遠端</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin new-branch-name<br></code></pre></td></tr></table></figure><p>將本地新分支推送到遠端倉庫，供團隊成員使用。</p><hr><h2 id="合併與衝突解決"><a href="#合併與衝突解決" class="headerlink" title="合併與衝突解決"></a>合併與衝突解決</h2><h3 id="合併分支"><a href="#合併分支" class="headerlink" title="合併分支"></a>合併分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge branch-name<br></code></pre></td></tr></table></figure><p>將指定分支合併到當前分支。</p><h4 id="使用-no-ff-保持合併歷史"><a href="#使用-no-ff-保持合併歷史" class="headerlink" title="使用 --no-ff 保持合併歷史"></a>使用 <code>--no-ff</code> 保持合併歷史</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge --no-ff branch-name<br></code></pre></td></tr></table></figure><p>這樣可以保留合併歷史，便於追蹤分支的合併情況。</p><hr><h3 id="解決合併衝突"><a href="#解決合併衝突" class="headerlink" title="解決合併衝突"></a>解決合併衝突</h3><p>當合併出現衝突時，Git 會標記出衝突部分，手動解決後再提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add conflicted-file<br>git commit<br></code></pre></td></tr></table></figure><h4 id="使用合併工具自動解決衝突"><a href="#使用合併工具自動解決衝突" class="headerlink" title="使用合併工具自動解決衝突"></a>使用合併工具自動解決衝突</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git mergetool<br></code></pre></td></tr></table></figure><p>這會啟動配置的合併工具，幫助自動解決衝突。</p><hr><h3 id="放棄合併"><a href="#放棄合併" class="headerlink" title="放棄合併"></a>放棄合併</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge --abort<br></code></pre></td></tr></table></figure><p>如果合併過程不如預期，您可以使用此指令放棄合併。</p><hr><h2 id="還原與重置"><a href="#還原與重置" class="headerlink" title="還原與重置"></a>還原與重置</h2><h3 id="還原單個文件"><a href="#還原單個文件" class="headerlink" title="還原單個文件"></a>還原單個文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -- filename<br></code></pre></td></tr></table></figure><p>這會將文件還原到上次提交的狀態。</p><hr><h3 id="回退提交"><a href="#回退提交" class="headerlink" title="回退提交"></a>回退提交</h3><p>如果您需要撤銷最近的提交，但保留變更，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --soft HEAD^<br></code></pre></td></tr></table></figure><p>如果要撤銷最近兩次提交，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --soft HEAD~2<br></code></pre></td></tr></table></figure><p>如果要徹底撤銷變更並回到提交前的狀態：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard HEAD^<br></code></pre></td></tr></table></figure><hr><h3 id="重置的影響"><a href="#重置的影響" class="headerlink" title="重置的影響"></a>重置的影響</h3><ul><li><code>--soft</code>: 只回退提交，保留暫存區和工作目錄的變更。</li><li><code>--mixed</code>（默認）：回退提交並重置暫存區，但保留工作目錄的變更。</li><li><code>--hard</code>: 回退提交並重置暫存區和工作目錄，所有未提交的變更將被刪除。</li></ul><hr><h3 id="還原遠端提交"><a href="#還原遠端提交" class="headerlink" title="還原遠端提交"></a>還原遠端提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git revert commit-hash<br></code></pre></td></tr></table></figure><p>這會生成一個新的提交來撤銷指定的提交，且不會影響提交歷史。</p><hr><h2 id="進階的-rebase-操作"><a href="#進階的-rebase-操作" class="headerlink" title="進階的 rebase 操作"></a>進階的 rebase 操作</h2><h3 id="交互式-rebase"><a href="#交互式-rebase" class="headerlink" title="交互式 rebase"></a>交互式 rebase</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rebase -i HEAD~3<br></code></pre></td></tr></table></figure><p>這可以讓您重新排序、修改或合併最近的提交，保持提交歷史的整潔。</p><h4 id="解決-rebase-衝突"><a href="#解決-rebase-衝突" class="headerlink" title="解決 rebase 衝突"></a>解決 rebase 衝突</h4><ol><li>當出現衝突時，手動編輯衝突文件以解決問題。</li><li>添加解決後的文件：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add conflicted-file<br></code></pre></td></tr></table></figure><ol start="3"><li>繼續 rebase：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rebase --<span class="hljs-built_in">continue</span><br></code></pre></td></tr></table></figure><hr><h3 id="rebase-vs-merge"><a href="#rebase-vs-merge" class="headerlink" title="rebase vs merge"></a>rebase vs merge</h3><ul><li><strong>Rebase</strong>：重寫提交歷史，使歷史更線性，適合在私有分支上使用。</li><li><strong>Merge</strong>：保留分支歷史，適合在公共分支上使用，能清楚看到分支的合併點。</li></ul><p>選擇合適的方法取決於團隊的工作流程和需求。</p><hr><h2 id="其他進階操作"><a href="#其他進階操作" class="headerlink" title="其他進階操作"></a>其他進階操作</h2><h3 id="cherry-pick-指定提交"><a href="#cherry-pick-指定提交" class="headerlink" title="cherry-pick 指定提交"></a><code>cherry-pick</code> 指定提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git cherry-pick commit-hash<br></code></pre></td></tr></table></figure><p>選擇一個提交並將其應用到當前分支。適用於需要從一個分支挑選特定變更到另一個分支的情況。</p><hr><h3 id="stash-暫存進階用法"><a href="#stash-暫存進階用法" class="headerlink" title="stash 暫存進階用法"></a><code>stash</code> 暫存進階用法</h3><h4 id="保存帶有訊息的-stash"><a href="#保存帶有訊息的-stash" class="headerlink" title="保存帶有訊息的 stash"></a>保存帶有訊息的 stash</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash save <span class="hljs-string">&quot;描述訊息&quot;</span><br></code></pre></td></tr></table></figure><h4 id="查看所有-stash-條目"><a href="#查看所有-stash-條目" class="headerlink" title="查看所有 stash 條目"></a>查看所有 stash 條目</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash list<br></code></pre></td></tr></table></figure><h4 id="應用特定-stash"><a href="#應用特定-stash" class="headerlink" title="應用特定 stash"></a>應用特定 stash</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash apply stash@&#123;index&#125;<br></code></pre></td></tr></table></figure><h4 id="彈出-stash（應用並刪除）"><a href="#彈出-stash（應用並刪除）" class="headerlink" title="彈出 stash（應用並刪除）"></a>彈出 stash（應用並刪除）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash pop<br></code></pre></td></tr></table></figure><h4 id="刪除特定-stash"><a href="#刪除特定-stash" class="headerlink" title="刪除特定 stash"></a>刪除特定 stash</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash drop stash@&#123;index&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="reflog-檢查所有-Git-操作"><a href="#reflog-檢查所有-Git-操作" class="headerlink" title="reflog 檢查所有 Git 操作"></a><code>reflog</code> 檢查所有 Git 操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reflog<br></code></pre></td></tr></table></figure><p>顯示您所有 Git 操作的歷史記錄，方便查找回退點。</p><hr><h3 id="log-graph-視覺化提交歷史"><a href="#log-graph-視覺化提交歷史" class="headerlink" title="log --graph 視覺化提交歷史"></a><code>log --graph</code> 視覺化提交歷史</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> --graph --oneline --all<br></code></pre></td></tr></table></figure><p>這會顯示一個圖形化的提交歷史，方便理解分支和合併的過程。</p><hr><h3 id="diff-staged-比較已暫存的文件變更"><a href="#diff-staged-比較已暫存的文件變更" class="headerlink" title="diff --staged 比較已暫存的文件變更"></a><code>diff --staged</code> 比較已暫存的文件變更</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff --staged<br></code></pre></td></tr></table></figure><p>比較已被添加到暫存區的變更，這在提交前檢查內容時非常有用。</p><hr><h3 id="tag-標記版本"><a href="#tag-標記版本" class="headerlink" title="tag 標記版本"></a><code>tag</code> 標記版本</h3><h4 id="創建輕量標籤"><a href="#創建輕量標籤" class="headerlink" title="創建輕量標籤"></a>創建輕量標籤</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag v1.0.0<br></code></pre></td></tr></table></figure><h4 id="創建註釋標籤"><a href="#創建註釋標籤" class="headerlink" title="創建註釋標籤"></a>創建註釋標籤</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag -a v1.0.0 -m <span class="hljs-string">&quot;Release version 1.0.0&quot;</span><br></code></pre></td></tr></table></figure><h4 id="推送標籤"><a href="#推送標籤" class="headerlink" title="推送標籤"></a>推送標籤</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin v1.0.0<br></code></pre></td></tr></table></figure><hr><h2 id="實際案例"><a href="#實際案例" class="headerlink" title="實際案例"></a>實際案例</h2><h3 id="多人協作中的-rebase-使用"><a href="#多人協作中的-rebase-使用" class="headerlink" title="多人協作中的 rebase 使用"></a>多人協作中的 rebase 使用</h3><p>在多人協作的專案中，使用 <code>rebase</code> 可以保持提交歷史的整潔。例如，當您在功能分支上工作，並且需要將最新的 <code>main</code> 分支變更整合過來，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout feature-branch<br>git rebase main<br></code></pre></td></tr></table></figure><p>這樣可以將 <code>feature-branch</code> 的提交基於最新的 <code>main</code> 分支，避免不必要的合併提交。</p><h3 id="使用-stash-管理臨時變更"><a href="#使用-stash-管理臨時變更" class="headerlink" title="使用 stash 管理臨時變更"></a>使用 <code>stash</code> 管理臨時變更</h3><p>當您正在處理一個功能，但需要切換到另一個分支修復緊急問題，可以使用 <code>stash</code> 暫存當前變更：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash save <span class="hljs-string">&quot;正在開發新功能&quot;</span><br>git checkout urgent-fix<br><span class="hljs-comment"># 修復問題並提交</span><br>git checkout feature-branch<br>git stash pop<br></code></pre></td></tr></table></figure><p>這樣可以方便地在不同任務間切換，而不會丟失未完成的工作。</p><hr><h2 id="參考資源"><a href="#參考資源" class="headerlink" title="參考資源"></a>參考資源</h2><ul><li><a href="https://terryyaowork.github.io/git/20240912/3203341186/">常用的 Git 指令</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>版本控制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用的 Git 指令：初學者必備的基本操作指南</title>
    <link href="/git/20240912/3203341186/"/>
    <url>/git/20240912/3203341186/</url>
    
    <content type="html"><![CDATA[<h1 id="常用的-Git-指令：初學者必備的基本操作指南"><a href="#常用的-Git-指令：初學者必備的基本操作指南" class="headerlink" title="常用的 Git 指令：初學者必備的基本操作指南"></a>常用的 Git 指令：初學者必備的基本操作指南</h1><p><img src="/images/git/02-basic-command.webp" alt="基本語法指南"></p><p>Git 是現代軟體開發中不可或缺的版本控制工具。無論您是單獨開發者還是團隊成員，Git 都能幫助您有效地管理代碼版本、協作開發以及追蹤變更。本文將介紹 Git 的基本操作，讓您能夠快速上手並掌握常用指令，這些指令將為您後續學習進階功能打下基礎。</p><hr><h2 id="初始化一個新的-Git-倉庫"><a href="#初始化一個新的-Git-倉庫" class="headerlink" title="初始化一個新的 Git 倉庫"></a>初始化一個新的 Git 倉庫</h2><p>當您需要在本地建立一個新的 Git 倉庫時，使用以下指令來初始化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure><p>這會在您的專案資料夾中創建一個 <code>.git</code> 目錄，Git 會在這裡跟蹤您的所有版本控制記錄。<strong>這是開始使用 Git 的第一步，確保在正確的資料夾中執行此命令。</strong></p><hr><h2 id="將檔案添加到-Git-中"><a href="#將檔案添加到-Git-中" class="headerlink" title="將檔案添加到 Git 中"></a>將檔案添加到 Git 中</h2><p>當您修改或新增檔案後，您需要將這些變更添加到 Git 的暫存區，這樣才能準備提交。使用以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br></code></pre></td></tr></table></figure><p>這個指令會將所有變更的檔案加入暫存區。如果您只想添加特定檔案，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add filename<br></code></pre></td></tr></table></figure><p><strong>這些操作為後續的提交打下基礎，確保您只提交您想要的變更。</strong></p><hr><h2 id="提交檔案變更"><a href="#提交檔案變更" class="headerlink" title="提交檔案變更"></a>提交檔案變更</h2><p>將檔案加入暫存區後，您可以提交變更。提交時，通常會附帶一條簡短的描述來說明這次變更的內容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;這次提交的描述訊息&quot;</span><br></code></pre></td></tr></table></figure><p>這條命令會將暫存區中的內容保存到倉庫中，成為一個歷史記錄點。</p><hr><h2 id="檢查當前狀態"><a href="#檢查當前狀態" class="headerlink" title="檢查當前狀態"></a>檢查當前狀態</h2><p>如果想知道哪些檔案發生了變更但尚未提交，您可以檢查專案的當前狀態：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status<br></code></pre></td></tr></table></figure><p>這條指令會列出已修改但未添加的檔案，或者已添加但未提交的檔案，幫助您了解當前專案的狀態。</p><hr><h2 id="檢查文件變更情況"><a href="#檢查文件變更情況" class="headerlink" title="檢查文件變更情況"></a>檢查文件變更情況</h2><p>這個指令用來查看文件的變更情況，是檢查具體修改內容的一個好工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff<br></code></pre></td></tr></table></figure><p>這個指令會顯示工作區和暫存區之間的差異。</p><hr><h2 id="查看提交歷史"><a href="#查看提交歷史" class="headerlink" title="查看提交歷史"></a>查看提交歷史</h2><p>當您想查看歷史提交記錄時，您可以使用以下指令來檢視所有的提交訊息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>這條指令會列出專案的所有提交歷史，按時間順序排列。</p><hr><h2 id="建立與切換分支"><a href="#建立與切換分支" class="headerlink" title="建立與切換分支"></a>建立與切換分支</h2><p>分支讓您可以在不影響主要代碼的情況下進行實驗或新功能的開發。以下是建立新分支並切換到該分支的指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch new-branch<br>git checkout new-branch<br></code></pre></td></tr></table></figure><p>或者您可以使用一個更簡單的指令來同時創建並切換到新分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b new-branch<br></code></pre></td></tr></table></figure><p>這樣您就可以在新的分支上進行開發，且不會影響到主分支。</p><hr><h2 id="將本地修改推送到遠端倉庫"><a href="#將本地修改推送到遠端倉庫" class="headerlink" title="將本地修改推送到遠端倉庫"></a>將本地修改推送到遠端倉庫</h2><p>當您在本地完成提交後，可以將修改推送到遠端 Git 倉庫（例如 GitHub、GitLab）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin branch-name<br></code></pre></td></tr></table></figure><p>這會將您當前分支的提交記錄推送到遠端倉庫。</p><hr><h2 id="將遠端倉庫的修改拉取到本地"><a href="#將遠端倉庫的修改拉取到本地" class="headerlink" title="將遠端倉庫的修改拉取到本地"></a>將遠端倉庫的修改拉取到本地</h2><p>當遠端倉庫有新變更時，您可以將它們拉取到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull<br></code></pre></td></tr></table></figure><p>這會從遠端拉取並合併最新的變更到您的當前分支中。</p><hr><h2 id="重置變更"><a href="#重置變更" class="headerlink" title="重置變更"></a>重置變更</h2><p>有時您可能會誤加檔案到暫存區。要移除暫存區中的檔案但保留工作目錄中的變更，您可以使用 <code>git reset</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset HEAD filename<br></code></pre></td></tr></table></figure><p>這條指令不會刪除或修改檔案內容，只是將檔案從暫存區移除。</p><hr><h2 id="合併分支"><a href="#合併分支" class="headerlink" title="合併分支"></a>合併分支</h2><p>當您需要將另一個分支的變更合併到當前分支時，可以使用以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge branch-name<br></code></pre></td></tr></table></figure><p>這條指令會將指定分支的內容合併到當前分支。如果出現衝突，您需要手動解決衝突並再次提交。</p><hr><h2 id="從遠端獲取更新（不合併）"><a href="#從遠端獲取更新（不合併）" class="headerlink" title="從遠端獲取更新（不合併）"></a>從遠端獲取更新（不合併）</h2><p>如果您只想從遠端獲取最新變更但不進行合併，您可以使用 <code>git fetch</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch<br></code></pre></td></tr></table></figure><p>這條指令會從遠端拉取所有更新，但不會自動將它們合併到您的當前分支中。</p><p><code>git fetch</code> 只是拉取遠端倉庫的更新，但不會自動合併，適合在查看遠端更新的情況下使用；而 <code>git pull</code> 則會自動合併更新，適合在您確定想要更新本地分支時使用。</p><hr><h2 id="暫存工作進度"><a href="#暫存工作進度" class="headerlink" title="暫存工作進度"></a>暫存工作進度</h2><p>如果您在進行一項工作，並且還不想提交，但又需要切換到其他分支或解決其他問題時，可以使用 <code>git stash</code> 將當前進度暫存：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash<br></code></pre></td></tr></table></figure><p>這條指令會將當前的變更暫存，之後可以通過 <code>git stash apply</code> 來取回。<code>git stash</code> 可以讓您暫存未完成的工作，以便快速切換分支或處理其他問題，而不會丟失當前的工作進度。</p><hr><h2 id="忽略檔案"><a href="#忽略檔案" class="headerlink" title="忽略檔案"></a>忽略檔案</h2><p>在專案開發中，您可能不希望所有檔案都被加入版本控制，例如編譯後的文件或敏感的設定檔。您可以使用 <code>.gitignore</code> 文件來指定哪些檔案應該被 Git 忽略。只需在專案根目錄下創建一個 <code>.gitignore</code> 文件，並在其中列出要忽略的檔案或目錄。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/node_modules<br>*.<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>當我需要 <code>.gitignore</code> 範例時，通常會去尋找「gitignore [語言&#x2F;框架] perfect」，這樣可以獲得針對特定開發環境的最佳實踐範例。</p><hr><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>本文介紹了 Git 的基本操作指令，這些指令將幫助您在日常開發中管理代碼。隨著您對 Git 的深入了解，您將發現更多強大的功能，例如合併請求、標籤管理和衝突解決等。建議您參考官方文檔或在線課程，進一步提升您的 Git 技能，並期待我們將來的進階內容，讓您更深入地掌握 Git 的強大功能。</p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>版本控制</tag>
      
      <tag>開發工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024 新 Mac 購買後必裝的應用程式</title>
    <link href="/macOS/20240908/2122020327/"/>
    <url>/macOS/20240908/2122020327/</url>
    
    <content type="html"><![CDATA[<h1 id="2024-新-Mac-購買後必裝的應用程式"><a href="#2024-新-Mac-購買後必裝的應用程式" class="headerlink" title="2024 新 Mac 購買後必裝的應用程式"></a>2024 新 Mac 購買後必裝的應用程式</h1><p><img src="/images/mac/2024-mac-app.webp" alt="2024 mac推薦app"><br>這篇文章將介紹新 Mac 購買後建議安裝的應用程式，幫助您快速上手，提升生產力與開發效率。</p><hr><h2 id="一般使用工具"><a href="#一般使用工具" class="headerlink" title="一般使用工具"></a>一般使用工具</h2><h3 id="生產力工具"><a href="#生產力工具" class="headerlink" title="生產力工具"></a>生產力工具</h3><ol><li><strong><a href="https://www.alfredapp.com/">Alfred 5</a></strong> - 快速啟動與搜索工具</li><li><strong><a href="https://apps.apple.com/us/app/amphetamine/id937984704">Amphetamine</a></strong> - 防止 Mac 進入睡眠</li><li><strong><a href="https://www.macbartender.com/">Bartender 5</a></strong> - 管理菜單欄圖標</li><li><strong><a href="https://obsidian.md/">Obsidian</a></strong> - 知識管理筆記應用</li><li><strong><a href="https://apps.apple.com/tw/app/session-%E7%95%AA%E8%8C%84%E9%90%98%E5%B0%88%E6%B3%A8%E8%A8%88%E6%99%82%E5%99%A8/id1521432881">Session</a></strong> - 番茄工作法計時器</li><li><strong><a href="https://sparkmailapp.com/help/general/how-to-download-spark">Spark</a></strong> - 電子郵件管理工具</li><li><strong><a href="https://theunarchiver.com/">The Unarchiver</a></strong> - 檔案解壓縮工具</li></ol><h3 id="瀏覽器"><a href="#瀏覽器" class="headerlink" title="瀏覽器"></a>瀏覽器</h3><ol><li><strong><a href="https://arc.net/">Arc</a></strong> - 新穎的瀏覽器</li><li><strong><a href="https://brave.com/">Brave Browser</a></strong> - 隱私保護瀏覽器</li><li><strong><a href="https://duckduckgo.com/app">DuckDuckGo</a></strong> - 隱私瀏覽器</li><li><strong><a href="https://www.google.com/chrome/">Google Chrome</a><strong>、</strong><a href="https://www.google.com/chrome/canary/">Google Chrome Canary</a></strong> - 網頁開發與測試</li><li><strong><a href="https://www.mozilla.org/firefox/new/">Firefox</a><strong>、</strong><a href="https://www.mozilla.org/firefox/developer/">Firefox Developer Edition</a></strong> - 網頁開發瀏覽器</li><li><strong><a href="https://www.microsoft.com/edge">Microsoft Edge</a></strong> - 微軟瀏覽器</li><li><strong><a href="https://vivaldi.com/">Vivaldi</a></strong> - 高度可自定義瀏覽器</li></ol><h3 id="設計與多媒體"><a href="#設計與多媒體" class="headerlink" title="設計與多媒體"></a>設計與多媒體</h3><ol><li><strong><a href="https://www.canva.com/">Canva</a></strong> - 簡單的圖像設計工具</li><li><strong><a href="https://www.figma.com/">Figma</a></strong> - 網頁設計與協作工具</li><li><strong><a href="https://www.spotify.com/">Spotify</a></strong> - 音樂串流服務</li><li><strong><a href="https://telegram.org/">Telegram</a></strong> - 即時通訊工具</li><li><strong><a href="https://line.me/">LINE</a></strong> - 通訊與社交工具</li><li><strong><a href="https://www.notion.so/">Notion</a></strong> - 筆記與任務管理</li></ol><hr><h2 id="開發工具"><a href="#開發工具" class="headerlink" title="開發工具"></a>開發工具</h2><h3 id="版本控制與資料庫"><a href="#版本控制與資料庫" class="headerlink" title="版本控制與資料庫"></a>版本控制與資料庫</h3><ol><li><strong><a href="https://dbeaver.io/">DBeaver</a></strong> - 資料庫管理工具</li><li><strong><a href="https://git-fork.com/">Fork</a></strong> - Git 圖形化管理工具</li><li><strong><a href="https://github.com/exelban/stats">Stats</a></strong> - 系統監控工具</li></ol><h3 id="開發者工具"><a href="#開發者工具" class="headerlink" title="開發者工具"></a>開發者工具</h3><ol><li><strong><a href="https://www.docker.com/">Docker</a></strong> - 容器管理工具</li><li><strong><a href="https://code.visualstudio.com/">Visual Studio Code</a></strong> - 輕量級開發編輯器</li><li><strong><a href="https://iterm2.com/">iTerm</a></strong> - 替代終端工具</li><li><strong><a href="https://www.warp.dev/">Warp</a></strong> - 現代化終端</li><li><strong><a href="https://app.diagrams.net/">draw.io</a></strong> - 圖表和流程圖工具</li><li><strong><a href="https://kapeli.com/dash">Dash</a></strong> - 開發文件查閱工具</li><li><strong><a href="https://devutils.app/">DevUtils</a></strong> - 多功能開發工具包</li><li><strong><a href="https://apphousekitchen.com/">AlDente</a></strong> - MacBook 充電控制工具</li></ol><hr><h2 id="使用-Homebrew-安裝的應用程式"><a href="#使用-Homebrew-安裝的應用程式" class="headerlink" title="使用 Homebrew 安裝的應用程式"></a>使用 Homebrew 安裝的應用程式</h2><p>這些應用程式可以透過 Homebrew 來安裝：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安裝 AppCleaner</span><br>brew install --cask appcleaner<br><br><span class="hljs-comment"># 安裝 CheatSheet</span><br>brew install --cask cheatsheet<br><br><span class="hljs-comment"># 安裝 Warp</span><br>brew install --cask warp<br></code></pre></td></tr></table></figure><h3 id="Formulae"><a href="#Formulae" class="headerlink" title="Formulae"></a>Formulae</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install ca-certificates<br>brew install fd<br>brew install htop<br>brew install libevent<br>brew install ncurses<br>brew install nvm<br>brew install openssl@3<br>brew install pcre2<br>brew install ripgrep<br>brew install tmux<br>brew install tree<br>brew install utf8proc<br></code></pre></td></tr></table></figure><h3 id="Casks"><a href="#Casks" class="headerlink" title="Casks"></a>Casks</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install --cask font-meslo-for-powerline<br>brew install --cask stats<br></code></pre></td></tr></table></figure><p>這些應用程式能夠提升您在 macOS 上的工作效率，特別是開發者會受益良多。</p><hr><h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><ul><li><a href="http://blog.jason.tools/2023/09/macos-opensource-apps.html">Jason.Tools Blog: macOS Open Source Apps</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>macOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新手必讀：為什麼要用 Git？</title>
    <link href="/git/20240908/3533452600/"/>
    <url>/git/20240908/3533452600/</url>
    
    <content type="html"><![CDATA[<h1 id="新手必讀：為什麼要用-Git？"><a href="#新手必讀：為什麼要用-Git？" class="headerlink" title="新手必讀：為什麼要用 Git？"></a>新手必讀：為什麼要用 Git？</h1><p><img src="/images/git/01-git-basic.webp" alt="基本語法指南"><br>如果你剛開始寫程式，可能聽說過 Git 這個東西，但不太確定它是什麼，為什麼要用它。別擔心，這篇文章就是為你準備的！我們來聊聊為什麼 Git 對你很重要，以及它如何讓你的程式開發生活變得更輕鬆。</p><h2 id="1-Git-到底是什麼？"><a href="#1-Git-到底是什麼？" class="headerlink" title="1. Git 到底是什麼？"></a>1. Git 到底是什麼？</h2><p>簡單來說，Git 是一個版本控制系統。聽起來很高深，對吧？其實它就像是一個超級強大的「復原」按鈕，可以幫你管理你的程式碼。</p><h2 id="2-為什麼新手要學-Git？"><a href="#2-為什麼新手要學-Git？" class="headerlink" title="2. 為什麼新手要學 Git？"></a>2. 為什麼新手要學 Git？</h2><h3 id="2-1-再也不怕搞砸你的程式了"><a href="#2-1-再也不怕搞砸你的程式了" class="headerlink" title="2.1 再也不怕搞砸你的程式了"></a>2.1 再也不怕搞砸你的程式了</h3><p>還記得你修改程式後，突然發現搞砸了，但又不記得改了哪裡嗎？有了 Git，你可以：</p><ul><li>隨時回到之前的版本</li><li>比較不同版本的差異</li><li>找出哪裡出了問題</li></ul><p>就像玩遊戲可以存檔一樣，Git 讓你在編程時也能「存檔」，怎麼改都不怕！</p><h3 id="2-2-輕鬆嘗試新想法"><a href="#2-2-輕鬆嘗試新想法" class="headerlink" title="2.2 輕鬆嘗試新想法"></a>2.2 輕鬆嘗試新想法</h3><p>有了 Git，你可以創建「分支」來測試新功能，而不會影響到主要的程式。這意味著：</p><ul><li>你可以大膽嘗試新想法</li><li>如果實驗成功，就合併回主程式</li><li>如果失敗，也不會影響原本的程式</li></ul><p>就像畫畫時可以先用鉛筆打稿一樣，Git 讓你可以安全地「打稿」你的程式。</p><h3 id="2-3-和他人合作變得超簡單"><a href="#2-3-和他人合作變得超簡單" class="headerlink" title="2.3 和他人合作變得超簡單"></a>2.3 和他人合作變得超簡單</h3><p>當你開始和他人一起寫程式時，Git 會是你最好的朋友：</p><ul><li>每個人可以同時修改不同的部分</li><li>Git 會幫你合併所有人的修改</li><li>你可以看到誰改了什麼，什麼時候改的</li></ul><p>就像是多人共筆寫作文一樣，Git 讓團隊合作變得超順暢。</p><h2 id="3-新手如何開始使用-Git？"><a href="#3-新手如何開始使用-Git？" class="headerlink" title="3. 新手如何開始使用 Git？"></a>3. 新手如何開始使用 Git？</h2><ol><li><strong>安裝 Git</strong>：在你的電腦上安裝 Git 軟體。</li><li><strong>學習基本指令</strong>：如 <code>git init</code>、<code>git add</code>、<code>git commit</code>。</li><li><strong>創建 GitHub 帳號</strong>：GitHub 是一個用 Git 的網站，可以存放你的程式。</li><li><strong>練習，練習，再練習</strong>：用 Git 管理你的小專案，慢慢就會熟悉了。</li></ol><h2 id="4-結論：為什麼你現在就該開始用-Git"><a href="#4-結論：為什麼你現在就該開始用-Git" class="headerlink" title="4. 結論：為什麼你現在就該開始用 Git"></a>4. 結論：為什麼你現在就該開始用 Git</h2><ol><li><strong>保護你的程式</strong>：不用擔心改錯程式，隨時可以回復。</li><li><strong>提升你的技能</strong>：Git 是業界標準，早點學對未來工作有幫助。</li><li><strong>為合作做準備</strong>：即使現在是自己寫程式，學會 Git 也能為將來的團隊合作做準備。</li></ol><p>記住，每個專業的程式開發者都會用 Git。現在開始學習和使用 Git，你就已經向專業程式設計師邁出了一大步！</p><p>別擔心一開始看不懂或用不習慣，這是正常的。慢慢來，持續使用，你會發現 Git 真的是個讓程式開發變得更簡單、更有趣的好工具！</p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>版本控制</tag>
      
      <tag>開發工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>提醒自己：如何寫出讓人一看就懂的技術文章</title>
    <link href="/blog/20240908/1267953438/"/>
    <url>/blog/20240908/1267953438/</url>
    
    <content type="html"><![CDATA[<h2 id="提醒自己：如何寫出讓人一看就懂的技術文章"><a href="#提醒自己：如何寫出讓人一看就懂的技術文章" class="headerlink" title="提醒自己：如何寫出讓人一看就懂的技術文章"></a>提醒自己：如何寫出讓人一看就懂的技術文章</h2><p><img src="/images/blog/way-to-wrighting.webp" alt="寫文章要注意的事"></p><p>寫出一篇清楚明白的技術文章能讓讀者快速掌握重點。這篇提醒是我寫作時應該遵循的原則，確保每次都能創作出高效且吸引人的內容。</p><hr><h2 id="1-文章結構要清晰"><a href="#1-文章結構要清晰" class="headerlink" title="1. 文章結構要清晰"></a>1. 文章結構要清晰</h2><h3 id="1-1-開頭要吸引人"><a href="#1-1-開頭要吸引人" class="headerlink" title="1.1 開頭要吸引人"></a>1.1 開頭要吸引人</h3><p>開頭應該引起讀者的注意，並迅速導入重點。避免過於正式或晦澀，可以這樣：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;你是否也遇到過這樣的問題：寫了一篇技術文章，卻發現沒人看得懂？這次，我們一起來看看如何改善這個問題！&quot;</span><br></code></pre></td></tr></table></figure><hr><h3 id="1-2-內容分段清晰"><a href="#1-2-內容分段清晰" class="headerlink" title="1.2 內容分段清晰"></a>1.2 內容分段清晰</h3><p>段落應簡潔有力，每段專注於一個主題，並使用具體範例來解釋概念。例如：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">### 將技術說明簡單化<br><br>使用簡單的詞彙表達技術內容。例如，與其寫<span class="hljs-string">&quot;提升系統效能&quot;</span>，不如寫<span class="hljs-string">&quot;讓系統運行得更快&quot;</span>。<br></code></pre></td></tr></table></figure><hr><h2 id="2-寫作風格要親和"><a href="#2-寫作風格要親和" class="headerlink" title="2. 寫作風格要親和"></a>2. 寫作風格要親和</h2><h3 id="2-1-保持一致的語氣"><a href="#2-1-保持一致的語氣" class="headerlink" title="2.1 保持一致的語氣"></a>2.1 保持一致的語氣</h3><p>文章語氣應該像與朋友聊天般親切，但保持專業性。想像自己在與一位有興趣但不熟悉技術的朋友交談：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">寫文章時，想像你在對一位感興趣的朋友解釋技術內容，這樣語氣會自然且易於理解。<br></code></pre></td></tr></table></figure><hr><h3 id="2-2-使用圖表增強說明"><a href="#2-2-使用圖表增強說明" class="headerlink" title="2.2 使用圖表增強說明"></a>2.2 使用圖表增強說明</h3><p>加入視覺元素（如圖表、流程圖）能使技術文章更生動有趣：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>想好內容 🤔<br><span class="hljs-bullet">- </span>開始撰寫 ✍️<br><span class="hljs-bullet">- </span>發布 🚀<br></code></pre></td></tr></table></figure><p>這樣不僅能使文章更具吸引力，還能幫助讀者更好地理解技術內容。</p><hr><h2 id="3-關鍵細節要清楚"><a href="#3-關鍵細節要清楚" class="headerlink" title="3. 關鍵細節要清楚"></a>3. 關鍵細節要清楚</h2><h3 id="3-1-解釋專業術語"><a href="#3-1-解釋專業術語" class="headerlink" title="3.1 解釋專業術語"></a>3.1 解釋專業術語</h3><p>遇到專業術語時，應簡單解釋，確保所有讀者能夠理解：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">CDN</span> 是<span class="hljs-string">&quot;內容分發網絡&quot;</span>的縮寫，主要作用是加快網站內容的傳輸速度。<br></code></pre></td></tr></table></figure><hr><h3 id="3-2-多用具體例子"><a href="#3-2-多用具體例子" class="headerlink" title="3.2 多用具體例子"></a>3.2 多用具體例子</h3><p>使用實際例子來幫助解釋技術概念，讓內容更具體且易懂：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">解釋版本控制時，我可以這樣說：<br><span class="hljs-string">&quot;想像你在編輯一篇報告，突然需要找回三天前刪除的內容，版本控制可以輕鬆幫你找回來。&quot;</span><br></code></pre></td></tr></table></figure><hr><h2 id="4-最後提醒自己"><a href="#4-最後提醒自己" class="headerlink" title="4. 最後提醒自己"></a>4. 最後提醒自己</h2><p>寫出讓人看得懂的技術文章不必過於複雜，關鍵是站在讀者的角度，用簡單的語言解釋技術內容，再加上一些有趣的例子和視覺元素。每次寫作時，記得回顧這些建議，不斷提升自己的寫作技巧。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部落格寫作</tag>
      
      <tag>寫作風格</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[hexo] 如何使用 Hexo 新增文章並進行 SEO 優化</title>
    <link href="/blog/20240908/1499619608/"/>
    <url>/blog/20240908/1499619608/</url>
    
    <content type="html"><![CDATA[<h1 id="如何使用-Hexo-新增文章並進行-SEO-優化"><a href="#如何使用-Hexo-新增文章並進行-SEO-優化" class="headerlink" title="如何使用 Hexo 新增文章並進行 SEO 優化"></a>如何使用 Hexo 新增文章並進行 SEO 優化</h1><p><img src="/images/hexo/04-hexo-new.webp" alt="hexo 新增文章"><br>Hexo 讓我們可以快速地新增、編寫、並部署文章。在這篇筆記中，我們將介紹使用 Hexo 新增文章的步驟，以及文章發佈後的 SEO 優化方式。</p><hr><h2 id="1-使用-hexo-new-指令建立新文章"><a href="#1-使用-hexo-new-指令建立新文章" class="headerlink" title="1. 使用 hexo new 指令建立新文章"></a>1. 使用 <code>hexo new</code> 指令建立新文章</h2><p>當您準備撰寫一篇新的文章時，首先需透過 Hexo 的指令 <code>hexo new</code> 來創建文章：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&quot;文章標題&quot;</span><br></code></pre></td></tr></table></figure><p>此指令會在 <code>source/_posts/</code> 目錄下自動生成一個新的 Markdown 檔案，檔名會自動按照文章標題命名。</p><hr><h2 id="2-新文章的文件結構"><a href="#2-新文章的文件結構" class="headerlink" title="2. 新文章的文件結構"></a>2. 新文章的文件結構</h2><p>執行 <code>hexo new</code> 後，生成的 Markdown 檔案通常會有以下結構：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: &quot;文章標題&quot;<br>date: YYYY-MM-DD HH:MM:SS<br>tags: []<br>categories: []<br>description: &quot;&quot;<br><span class="hljs-section">keywords: &quot;&quot;</span><br><span class="hljs-section">---</span><br><br><span class="hljs-section"># 文章標題</span><br><br>正文內容...<br></code></pre></td></tr></table></figure><h3 id="2-1-文章參數說明"><a href="#2-1-文章參數說明" class="headerlink" title="2.1 文章參數說明"></a>2.1 文章參數說明</h3><ul><li><strong>title</strong>: 文章的標題</li><li><strong>date</strong>: 文章創建的時間</li><li><strong>tags</strong>: 文章的標籤，可以用來分類和索引內容</li><li><strong>categories</strong>: 文章的類別，通常用來歸類文章的主題</li><li><strong>description</strong>: 簡短的文章介紹，對 SEO 友好</li><li><strong>keywords</strong>: 文章的關鍵字，有助於提升 SEO 排名</li></ul><h3 id="2-2-檢查-config-yml-設定"><a href="#2-2-檢查-config-yml-設定" class="headerlink" title="2.2 檢查 _config.yml 設定"></a>2.2 檢查 <code>_config.yml</code> 設定</h3><p>在新增文章時，別忘了檢查 <code>_config.yml</code> 中的 <code>category_map</code> 和 <code>tag_map</code> 設定，因為它們會影響文章分類和標籤的映射，避免網址中出現中文。例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">category_map:</span><br>    <span class="hljs-string">技術:</span> <span class="hljs-string">tech</span><br><br><span class="hljs-attr">tag_map:</span><br>    <span class="hljs-string">前端:</span> <span class="hljs-string">frontend</span><br></code></pre></td></tr></table></figure><hr><h2 id="3-常見的文章設置"><a href="#3-常見的文章設置" class="headerlink" title="3. 常見的文章設置"></a>3. 常見的文章設置</h2><h3 id="3-1-標籤（Tags）與分類（Categories）"><a href="#3-1-標籤（Tags）與分類（Categories）" class="headerlink" title="3.1 標籤（Tags）與分類（Categories）"></a>3.1 標籤（Tags）與分類（Categories）</h3><p>當撰寫新文章時，為了更好地管理內容，建議正確設定標籤與分類。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">tags:<br><span class="hljs-bullet">    -</span> hexo<br><span class="hljs-bullet">    -</span> 技術部落格<br><br>categories:<br><span class="hljs-bullet">    -</span> 技術<br><span class="hljs-bullet">    -</span> 開發筆記<br></code></pre></td></tr></table></figure><h3 id="3-2-設定-description-與-keywords"><a href="#3-2-設定-description-與-keywords" class="headerlink" title="3.2 設定 description 與 keywords"></a>3.2 設定 description 與 keywords</h3><p>描述與關鍵字對於 SEO 至關重要，能幫助搜尋引擎更好地理解您的文章內容。可以在文章開頭的 YAML 中加入：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">description: &quot;這篇文章講解如何使用 Hexo 新增文章，並優化文章結構和 SEO 設定。&quot;<br>keywords: &quot;Hexo, 新增文章, SEO, 部落格, Markdown&quot;<br></code></pre></td></tr></table></figure><hr><h2 id="4-發佈文章並部署"><a href="#4-發佈文章並部署" class="headerlink" title="4. 發佈文章並部署"></a>4. 發佈文章並部署</h2><h3 id="4-1-生成靜態檔案"><a href="#4-1-生成靜態檔案" class="headerlink" title="4.1 生成靜態檔案"></a>4.1 生成靜態檔案</h3><p>當您完成文章撰寫後，可以使用以下指令生成靜態檔案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate<br></code></pre></td></tr></table></figure><p>此指令會將您所有的文章轉換為靜態 HTML 檔案。</p><h3 id="4-2-部署到-GitHub-Pages"><a href="#4-2-部署到-GitHub-Pages" class="headerlink" title="4.2 部署到 GitHub Pages"></a>4.2 部署到 GitHub Pages</h3><p>如果您使用 GitHub Pages 部署網站，可以使用以下指令進行部署：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo deploy<br><span class="hljs-comment"># 或使用簡寫</span><br>hexo g -d<br></code></pre></td></tr></table></figure><hr><h2 id="5-發佈文章後的-SEO-優化"><a href="#5-發佈文章後的-SEO-優化" class="headerlink" title="5. 發佈文章後的 SEO 優化"></a>5. 發佈文章後的 SEO 優化</h2><p>發佈文章後，請檢查以下幾點以確保 SEO 優化效果：</p><ol><li><strong>確認標題、描述與關鍵字</strong>：這些資訊會直接影響搜尋引擎的索引結果。</li><li><strong>內部鏈接優化</strong>：如果有相關文章，請使用內部連結，增加網站結構的互動性。</li><li><strong>檢查 Sitemap</strong>：確保您的文章已包含在網站的 sitemap 中，這能幫助搜尋引擎更快地抓取內容。</li></ol><hr><p>這篇筆記提供了從建立文章到發佈和 SEO 優化的完整步驟，希望能幫助您更有效率地管理 Hexo 部落格文章。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部落格寫作</tag>
      
      <tag>hexo</tag>
      
      <tag>seo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[markdown] markdown 基本語法指南</title>
    <link href="/markdown/20240908/2445653678/"/>
    <url>/markdown/20240908/2445653678/</url>
    
    <content type="html"><![CDATA[<h1 id="markdown-基本語法指南"><a href="#markdown-基本語法指南" class="headerlink" title="markdown 基本語法指南"></a>markdown 基本語法指南</h1><p><img src="/images/blog/markdown.webp" alt="基本語法指南"><br>markdown 是一種輕量級的標記語言，廣泛應用於文件撰寫、部落格等平台。它簡單易學，能有效地格式化文字。本文將介紹最常用的 Markdown 語法，適合初學者快速上手。</p><hr><h2 id="1-標題"><a href="#1-標題" class="headerlink" title="1. 標題"></a>1. 標題</h2><p>在 Markdown 中，標題使用 <code>#</code> 符號來表示，<code>#</code> 的數量決定了標題的層級（H1 到 H6）。例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># H1 標題</span><br><span class="hljs-section">## H2 標題</span><br><span class="hljs-section">### H3 標題</span><br><span class="hljs-section">#### H4 標題</span><br><span class="hljs-section">##### H5 標題</span><br><span class="hljs-section">###### H6 標題</span><br></code></pre></td></tr></table></figure><h3 id="顯示效果："><a href="#顯示效果：" class="headerlink" title="顯示效果："></a>顯示效果：</h3><h1 id="這是一級標題"><a href="#這是一級標題" class="headerlink" title="這是一級標題"></a>這是一級標題</h1><h2 id="這是二級標題"><a href="#這是二級標題" class="headerlink" title="這是二級標題"></a>這是二級標題</h2><hr><h2 id="2-段落與換行"><a href="#2-段落與換行" class="headerlink" title="2. 段落與換行"></a>2. 段落與換行</h2><p>段落不需要特別的標記，只需在文字間空一行即可。在同一行內按兩次空格則可以換行。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">這是一個段落。<br><br>這是另一個段落。<br></code></pre></td></tr></table></figure><h3 id="顯示效果：-1"><a href="#顯示效果：-1" class="headerlink" title="顯示效果："></a>顯示效果：</h3><p>這是一個段落。<br>這是一段有兩個空格後的換行。<br>這是新段落。</p><hr><h2 id="3-強調與字體樣式"><a href="#3-強調與字體樣式" class="headerlink" title="3. 強調與字體樣式"></a>3. 強調與字體樣式</h2><p>使用 <code>*</code> 或 <code>_</code> 來表示斜體，使用 <code>**</code> 或 <code>__</code> 來表示粗體。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-emphasis">*斜體*</span> 或 <span class="hljs-emphasis">_斜體_</span><br><br><span class="hljs-strong">**粗體**</span> 或 <span class="hljs-strong">__粗體__</span><br></code></pre></td></tr></table></figure><h3 id="顯示效果：-2"><a href="#顯示效果：-2" class="headerlink" title="顯示效果："></a>顯示效果：</h3><p>這是 <strong>粗體文字</strong>，這是 <em>斜體文字</em>。</p><hr><h2 id="4-列表"><a href="#4-列表" class="headerlink" title="4. 列表"></a>4. 列表</h2><p>Markdown 支援無序和有序列表。無序列表使用 <code>-</code>、<code>*</code> 或 <code>+</code>。有序列表使用數字和點號。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 項目一<br><span class="hljs-bullet">-</span> 項目二<br><br><span class="hljs-bullet">1.</span> 項目一<br><span class="hljs-bullet">2.</span> 項目二<br></code></pre></td></tr></table></figure><h3 id="顯示效果：-3"><a href="#顯示效果：-3" class="headerlink" title="顯示效果："></a>顯示效果：</h3><ol><li>第一項</li><li>第二項<ul><li>子項目一</li><li>子項目二</li></ul></li></ol><ul><li>子項目三</li><li>子項目四</li></ul><hr><h2 id="5-連結與圖片"><a href="#5-連結與圖片" class="headerlink" title="5. 連結與圖片"></a>5. 連結與圖片</h2><p>連結使用 <code>[顯示文字](網址)</code> 格式。圖片的語法類似，但前面需要加上 <code>!</code>。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">Hexo 官方網站</span>](<span class="hljs-link">https://hexo.io</span>)<br><br>![<span class="hljs-string">示例圖片</span>](<span class="hljs-link">https://example.com/image.png</span>)<br></code></pre></td></tr></table></figure><h3 id="顯示效果：-4"><a href="#顯示效果：-4" class="headerlink" title="顯示效果："></a>顯示效果：</h3><p><img src="https://hexo.io/logo.png" alt="Logo"><br/><br><a href="https://hexo.io/">Hexo</a></p><hr><h2 id="6-程式碼區塊"><a href="#6-程式碼區塊" class="headerlink" title="6. 程式碼區塊"></a>6. 程式碼區塊</h2><p>行內程式碼使用反引號 <code>`</code> 括起來，多行程式碼區塊則使用三個反引號 <code> </code>。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">`行內程式碼`<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">多行程式碼區塊<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">```<br><br>### 顯示效果：<br>`行內程式碼`<br><br></code></pre></td></tr></table></figure></code></pre><p>多行程式碼區塊</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-comment">## 7. 引用與水平線</span><br><br><span class="hljs-string">引用文字使用</span> <span class="hljs-string">`&gt;`，水平線則使用</span> <span class="hljs-string">`---`、`***`</span> <span class="hljs-string">或</span> <span class="hljs-string">`___`。</span><br><br><span class="hljs-string">```markdown</span><br><span class="hljs-string">&gt;</span> <span class="hljs-string">這是一段引用。</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">&gt;</span> <span class="hljs-string">這是一段多行引用的範例，</span>  <br><span class="hljs-string">&gt;</span> <span class="hljs-string">它展示了如何處理超過一行的引用。</span>  <br><span class="hljs-string">&gt;</span> <span class="hljs-string">可以在每行結尾使用雙空格來進行換行。</span><br></code></pre></td></tr></table></figure><h3 id="顯示效果：-5"><a href="#顯示效果：-5" class="headerlink" title="顯示效果："></a>顯示效果：</h3><blockquote><p>這是一段引用。</p></blockquote><hr><blockquote><p>這是一段多行引用的範例，<br>它展示了如何處理超過一行的引用。<br>可以在每行結尾使用雙空格來進行換行。</p></blockquote><hr><h2 id="8-組合語法"><a href="#8-組合語法" class="headerlink" title="8. 組合語法"></a>8. 組合語法</h2><p>Markdown 支援將多個語法組合使用，例如在列表中加入引用或程式碼：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 第一項<br><span class="hljs-bullet">    -</span> 子項一<br><span class="hljs-bullet">    -</span> 子項二<br><span class="hljs-bullet">2.</span> 第二項<br><span class="hljs-code">    &gt; 引用文字</span><br><span class="hljs-code">    ```markdown</span><br><span class="hljs-code">    程式碼範例</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-section">### 顯示效果：</span><br><span class="hljs-bullet">1.</span> 第一項<br><span class="hljs-bullet">    -</span> 子項一<br><span class="hljs-bullet">    -</span> 子項二<br><span class="hljs-bullet">2.</span> 第二項<br><span class="hljs-code">    &gt; 引用文字</span><br><span class="hljs-code">    ```markdown</span><br><span class="hljs-code">    程式碼範例</span><br></code></pre></td></tr></table></figure><hr><h2 id="9-常見情境語法組合"><a href="#9-常見情境語法組合" class="headerlink" title="9. 常見情境語法組合"></a>9. 常見情境語法組合</h2><h3 id="9-1-引用與強調組合"><a href="#9-1-引用與強調組合" class="headerlink" title="9.1 引用與強調組合"></a>9.1 引用與強調組合</h3><p>引用和強調文字常用於強調重要信息：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; <span class="hljs-strong">**注意：**</span> 在安裝 Hexo 時，請確保 Node.js 已經更新到最新版本。</span><br></code></pre></td></tr></table></figure><h4 id="顯示效果：-6"><a href="#顯示效果：-6" class="headerlink" title="顯示效果："></a>顯示效果：</h4><blockquote><p><strong>注意：</strong> 在安裝 Hexo 時，請確保 Node.js 已經更新到最新版本。</p></blockquote><h3 id="9-2-列表與連結組合"><a href="#9-2-列表與連結組合" class="headerlink" title="9.2 列表與連結組合"></a>9.2 列表與連結組合</h3><p>列表中常會包含連結，以方便讀者進一步了解某個主題：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> [<span class="hljs-string">Markdown 官方網站</span>](<span class="hljs-link">https://daringfireball.net/projects/markdown/</span>)<br><span class="hljs-bullet">-</span> [<span class="hljs-string">Hexo 文件</span>](<span class="hljs-link">https://hexo.io/docs/</span>)<br></code></pre></td></tr></table></figure><h4 id="顯示效果：-7"><a href="#顯示效果：-7" class="headerlink" title="顯示效果："></a>顯示效果：</h4><ul><li><a href="https://daringfireball.net/projects/markdown/">Markdown 官方網站</a></li><li><a href="https://hexo.io/docs/">Hexo 文件</a></li></ul><hr><h2 id="10-額外進階語法"><a href="#10-額外進階語法" class="headerlink" title="10. 額外進階語法"></a>10. 額外進階語法</h2><h3 id="10-1-表格"><a href="#10-1-表格" class="headerlink" title="10.1 表格"></a>10.1 表格</h3><p>Markdown 也支援表格語法，用來展示結構化數據。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">| 表頭一 | 表頭二 | 表頭三 |<br>| ------ | ------ | ------ |<br>| 單元格一 | 單元格二 | 單元格三 |<br></code></pre></td></tr></table></figure><h4 id="顯示效果：-8"><a href="#顯示效果：-8" class="headerlink" title="顯示效果："></a>顯示效果：</h4><table><thead><tr><th>表頭一</th><th>表頭二</th><th>表頭三</th></tr></thead><tbody><tr><td>單元格一</td><td>單元格二</td><td>單元格三</td></tr></tbody></table><h3 id="10-2-勾選框列表"><a href="#10-2-勾選框列表" class="headerlink" title="10.2 勾選框列表"></a>10.2 勾選框列表</h3><p>可以使用 <code>[ ]</code> 或 <code>[x]</code> 來表示待辦事項列表。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> [ ] 待辦事項一<br><span class="hljs-bullet">-</span> [x] 已完成事項<br></code></pre></td></tr></table></figure><h4 id="顯示效果：-9"><a href="#顯示效果：-9" class="headerlink" title="顯示效果："></a>顯示效果：</h4><ul><li><input disabled="" type="checkbox"> 待辦事項一</li><li><input checked="" disabled="" type="checkbox"> 已完成事項</li></ul><hr><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>Markdown 是非常靈活且易學的標記語言，無論是寫作還是技術文件，都能夠幫助您快速生成格式化的內容。希望這份指南能幫助您更好地掌握 Markdown 的基礎語法。</p>]]></content>
    
    
    <categories>
      
      <category>markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
      <tag>部落格寫作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[hexo] 如何利用 Hexo 提升 SEO 與行銷效能</title>
    <link href="/blog/20240908/786391661/"/>
    <url>/blog/20240908/786391661/</url>
    
    <content type="html"><![CDATA[<h1 id="如何利用-Hexo-提升-SEO-與行銷效能"><a href="#如何利用-Hexo-提升-SEO-與行銷效能" class="headerlink" title="如何利用 Hexo 提升 SEO 與行銷效能"></a>如何利用 Hexo 提升 SEO 與行銷效能</h1><p><img src="/images/hexo/03-hexo-marketing.png" alt="hexo 行銷相關概念"><br>SEO 和行銷效能提升對於網站的曝光與可見性至關重要。在這篇文章中，我們將探討如何通過 Hexo 的進階設置提升 SEO 表現，讓您的部落格在搜尋引擎中更具優勢。</p><hr><h2 id="1-自訂模板與內容優化"><a href="#1-自訂模板與內容優化" class="headerlink" title="1. 自訂模板與內容優化"></a>1. 自訂模板與內容優化</h2><p>設置模板可以幫助統一內容風格，並確保每篇文章具備行銷與 SEO 的基礎要素。以下是如何通過 Hexo 的自訂模板，讓每篇文章都能提高其行銷價值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> &#123;&#123; <span class="hljs-string">title</span> &#125;&#125;<br><span class="hljs-attr">date:</span> &#123;&#123; <span class="hljs-string">date</span> &#125;&#125;<br><span class="hljs-attr">categories:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">行銷</span><br><span class="hljs-attr">tags:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">SEO</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-comment"># &#123;&#123; title &#125;&#125;</span><br><br><span class="hljs-string">這篇文章將分享如何透過行銷策略和</span> <span class="hljs-string">SEO</span> <span class="hljs-string">提升網站的可見性。</span><br></code></pre></td></tr></table></figure><hr><h2 id="2-加入-Google-Analytics-提升數據分析能力"><a href="#2-加入-Google-Analytics-提升數據分析能力" class="headerlink" title="2. 加入 Google Analytics 提升數據分析能力"></a>2. 加入 Google Analytics 提升數據分析能力</h2><p>Google Analytics 是行銷的利器，能幫助您追蹤網站流量、瞭解用戶行為。以下是將 Google Analytics 整合到 Hexo 中的方式，讓您的網站行銷策略更加精準。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;% if(theme.ga_track_id) &#123; %&gt;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://www.googletagmanager.com/gtag/js?id=&lt;%= theme.ga_track_id %&gt;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">dataLayer</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">dataLayer</span> || [];</span><br><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">gtag</span>(<span class="hljs-params"></span>)&#123;dataLayer.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">arguments</span>);&#125;</span><br><span class="language-javascript">        <span class="hljs-title function_">gtag</span>(<span class="hljs-string">&#x27;js&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());</span><br><span class="language-javascript">        <span class="hljs-title function_">gtag</span>(<span class="hljs-string">&#x27;config&#x27;</span>, <span class="hljs-string">&#x27;&lt;%= theme.ga_track_id %&gt;&#x27;</span>);</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>&lt;% &#125; %&gt;<br></code></pre></td></tr></table></figure><hr><h2 id="3-使用-abbrlink-優化-SEO-與行銷效能"><a href="#3-使用-abbrlink-優化-SEO-與行銷效能" class="headerlink" title="3. 使用 abbrlink 優化 SEO 與行銷效能"></a>3. 使用 <code>abbrlink</code> 優化 SEO 與行銷效能</h2><p><code>abbrlink</code> 讓網址簡潔易記，不僅提升使用者體驗，還能加強 SEO 排名，對行銷活動中的連結分享尤為有利。透過以下設定，您可以輕鬆優化網址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm install hexo-abbrlink --save<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">abbrlink:</span><br>    <span class="hljs-attr">alg:</span> <span class="hljs-string">crc32</span><br>    <span class="hljs-attr">rep:</span> <span class="hljs-string">dec</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:category/:abbrlink/</span><br></code></pre></td></tr></table></figure><hr><h2 id="4-404-頁面：挽回用戶的機會"><a href="#4-404-頁面：挽回用戶的機會" class="headerlink" title="4. 404 頁面：挽回用戶的機會"></a>4. 404 頁面：挽回用戶的機會</h2><p>404 頁面不應該只是告知用戶錯誤，它可以是重新吸引用戶的好機會。設計一個有效的 404 頁面能幫助減少跳出率，引導用戶到其他內容，提升網站的整體效益。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: 404<br>layout: page<br><span class="hljs-section">description: 找不到頁面</span><br><span class="hljs-section">---</span><br><br><span class="hljs-section"># 404 - 找不到頁面</span><br><br>抱歉，頁面不存在。請返回 [<span class="hljs-string">首頁</span>](<span class="hljs-link">/</span>) 或查看 [<span class="hljs-string">熱門文章</span>](<span class="hljs-link">/latest</span>)。<br></code></pre></td></tr></table></figure><hr><h2 id="5-圖片與性能優化：提升用戶體驗"><a href="#5-圖片與性能優化：提升用戶體驗" class="headerlink" title="5. 圖片與性能優化：提升用戶體驗"></a>5. 圖片與性能優化：提升用戶體驗</h2><p>網站加載速度直接影響 SEO 與行銷成效。透過壓縮圖片、優化 HTML、CSS 和 JavaScript，能大幅改善網站效能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm install hexo-neat --save<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">neat_enable:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">neat_html:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">remove_comments:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">neat_css:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">neat_js:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><hr><h2 id="6-Category-Tag-在-SEO-與行銷中的價值"><a href="#6-Category-Tag-在-SEO-與行銷中的價值" class="headerlink" title="6. Category&#x2F;Tag 在 SEO 與行銷中的價值"></a>6. Category&#x2F;Tag 在 SEO 與行銷中的價值</h2><p><strong>分類與標籤（Category&#x2F;Tag）</strong> 是結構化內容、提升搜尋引擎排名的重要工具。它們能讓網站內容清晰易懂，幫助用戶與搜尋引擎快速找到所需資料。</p><ul><li><strong>提升 SEO</strong>：清晰的分類與標籤讓搜尋引擎更容易理解網站的內容架構，進一步提高排名。</li><li><strong>優化用戶體驗</strong>：通過分類，讀者可以快速瀏覽相關主題，提升用戶互動與停留時間。</li><li><strong>內部連結的助力</strong>：分類頁面和標籤頁面能有效促進內部連結，進一步強化 SEO。</li></ul><hr><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>通過這篇文章，您學會了如何利用 Hexo 的進階設定來提升網站的 SEO 和行銷效能。善用 Google Analytics、簡短網址、404 頁面的優化，以及分類與標籤的結構化管理，將為您的網站帶來更多流量和行銷效果。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>seo</tag>
      
      <tag>行銷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[hexo] Hexo 進階設定指南</title>
    <link href="/blog/20240908/2034027213/"/>
    <url>/blog/20240908/2034027213/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo-進階設定指南"><a href="#Hexo-進階設定指南" class="headerlink" title="Hexo 進階設定指南"></a>Hexo 進階設定指南</h1><p><img src="/images/hexo/02-advantage-setting.png" alt="hexo進階設定"><br>在這篇文章中，我們將深入探討 Hexo 的進階設定，包括如何安裝主題、插件，設定 categories 與 tags 的映射，並優化 SEO 和搜尋功能。這些進階設定將幫助您打造一個更符合個人需求的靜態部落格。</p><h2 id="1-主題安裝"><a href="#1-主題安裝" class="headerlink" title="1. 主題安裝"></a>1. 主題安裝</h2><p>Hexo 提供了許多精美的主題，您可以根據需求選擇並安裝。以下是安裝 Hexo 主題的一般步驟。</p><h3 id="1-1-從-GitHub-安裝主題"><a href="#1-1-從-GitHub-安裝主題" class="headerlink" title="1.1 從 GitHub 安裝主題"></a>1.1 從 GitHub 安裝主題</h3><p>首先，您需要選擇一個主題，這裡以 Fluid 主題為例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># clone Fluid 主題到 themes 資料夾</span><br>git <span class="hljs-built_in">clone</span> git@github.com:fluid-dev/hexo-theme-fluid.git themes/fluid<br></code></pre></td></tr></table></figure><p>接著，更新您的 <code>_config.yml</code> 檔案來設定主題：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br></code></pre></td></tr></table></figure><h3 id="1-2-自定義主題設定"><a href="#1-2-自定義主題設定" class="headerlink" title="1.2 自定義主題設定"></a>1.2 自定義主題設定</h3><p>每個主題都有自己的 <code>_config.yml</code> 設定檔。安裝好主題後，您可以到 <code>themes/fluid/_config.yml</code> 檔案中進行自定義。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 在主題的 _config.yml 中，設定社交媒體連結</span><br><span class="hljs-attr">social_links:</span><br>    <span class="hljs-attr">github:</span> <span class="hljs-string">https://github.com/terryyaowork</span><br>    <span class="hljs-attr">twitter:</span> <span class="hljs-string">https://twitter.com/terryyaowork</span><br></code></pre></td></tr></table></figure><p>這裡可以配置社交媒體連結、頁面佈局、外觀等多種選項，具體可以參照主題官方文件。</p><p><strong>官方 Hexo 主題列表連結</strong>: <a href="https://hexo.io/themes/">Hexo Themes</a></p><hr><h2 id="2-插件安裝"><a href="#2-插件安裝" class="headerlink" title="2. 插件安裝"></a>2. 插件安裝</h2><p>在使用 Hexo 建立部落格的過程中，以下這些插件能夠幫助您提升網站功能和效能。這裡列出了您需要安裝的插件以及相應的設定方法。</p><h3 id="2-1-搜尋功能插件-hexo-generator-searchdb"><a href="#2-1-搜尋功能插件-hexo-generator-searchdb" class="headerlink" title="2.1 搜尋功能插件 hexo-generator-searchdb"></a>2.1 搜尋功能插件 <code>hexo-generator-searchdb</code></h3><p><code>hexo-generator-searchdb</code> 插件提供了本地搜尋功能，可以讓讀者更方便地在您的部落格中搜尋內容。這是必選的插件，因為它能提升用戶體驗，特別是當文章數量增加後，搜尋功能變得至關重要。</p><p>安裝方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm install hexo-generator-searchdb --save<br></code></pre></td></tr></table></figure><p>在 <code>_config.yml</code> 中添加以下配置來啟用搜尋功能：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">search:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">search.xml</span><br>    <span class="hljs-attr">field:</span> <span class="hljs-string">post</span><br>    <span class="hljs-attr">format:</span> <span class="hljs-string">html</span><br>    <span class="hljs-attr">limit:</span> <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><hr><h3 id="2-2-SEO-插件-hexo-generator-sitemap"><a href="#2-2-SEO-插件-hexo-generator-sitemap" class="headerlink" title="2.2 SEO 插件 hexo-generator-sitemap"></a>2.2 SEO 插件 <code>hexo-generator-sitemap</code></h3><p><code>hexo-generator-sitemap</code> 插件能幫助您的網站生成 sitemap.xml 檔案，這是對搜尋引擎友好的檔案，能幫助搜尋引擎更好地抓取您的網站內容，提升網站的可見性。這對於 SEO 非常重要，因為它能幫助搜尋引擎更快地索引您的網站，提升搜尋排名。</p><p>安裝方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm install hexo-generator-sitemap --save<br></code></pre></td></tr></table></figure><p>在 <code>_config.yml</code> 中添加以下配置來啟用 Sitemap：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">sitemap:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">sitemap.xml</span><br></code></pre></td></tr></table></figure><hr><h3 id="2-3-圖片與文件壓縮插件-hexo-neat"><a href="#2-3-圖片與文件壓縮插件-hexo-neat" class="headerlink" title="2.3 圖片與文件壓縮插件 hexo-neat"></a>2.3 圖片與文件壓縮插件 <code>hexo-neat</code></h3><p><code>hexo-neat</code> 插件幫助您壓縮網站的 HTML、CSS 和 JS 檔案，減少網站的檔案大小，提升加載速度。對於擁有大量內容或圖片的部落格來說，網站加載速度不僅影響用戶體驗，也對 SEO 有直接的影響，搜尋引擎通常會優先排名加載速度較快的網站。</p><p>安裝方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm install hexo-neat --save<br></code></pre></td></tr></table></figure><p>在 <code>_config.yml</code> 中添加以下配置來啟用壓縮功能：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">neat_enable:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">neat_html:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">remove_comments:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">neat_css:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">neat_js:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><hr><h3 id="2-4-Git-部署插件-hexo-deployer-git"><a href="#2-4-Git-部署插件-hexo-deployer-git" class="headerlink" title="2.4 Git 部署插件 hexo-deployer-git"></a>2.4 Git 部署插件 <code>hexo-deployer-git</code></h3><p><code>hexo-deployer-git</code> 插件能夠將您的 Hexo 部落格部署到 GitHub Pages。安裝方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>在 <code>_config.yml</code> 中設定 GitHub Pages 的部署信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>    <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:&lt;YOUR_USERNAME&gt;/&lt;YOUR_REPO&gt;.git</span><br>    <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure><hr><h3 id="2-5-分類與標籤插件"><a href="#2-5-分類與標籤插件" class="headerlink" title="2.5 分類與標籤插件"></a>2.5 分類與標籤插件</h3><p>Hexo 支援分類與標籤頁面的自動生成，您可以使用 <code>hexo-generator-category</code> 和 <code>hexo-generator-tag</code> 插件來實現這個功能：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm install hexo-generator-category --save<br>pnpm install hexo-generator-tag --save<br></code></pre></td></tr></table></figure><p>在 <code>_config.yml</code> 中不需要額外設定，這些插件會自動根據您的文章生成分類與標籤頁面。</p><hr><h3 id="2-6-其他必要的插件"><a href="#2-6-其他必要的插件" class="headerlink" title="2.6 其他必要的插件"></a>2.6 其他必要的插件</h3><p>除了上面提到的核心插件，這裡還有一些插件會幫助優化您的網站運行：</p><ul><li><strong>Hexo 渲染插件</strong>：</li><li><code>hexo-renderer-marked</code>：用於渲染 Markdown 文章。</li><li><code>hexo-renderer-ejs</code>、<code>hexo-renderer-pug</code>、<code>hexo-renderer-stylus</code>：用於支持 EJS、Pug 和 Stylus 模板語法。</li></ul><p>安裝方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm install hexo-renderer-marked hexo-renderer-ejs hexo-renderer-pug hexo-renderer-stylus --save<br></code></pre></td></tr></table></figure><hr><h2 id="3-Categories-Map-和-Tags-Map-設定"><a href="#3-Categories-Map-和-Tags-Map-設定" class="headerlink" title="3. Categories Map 和 Tags Map 設定"></a>3. Categories Map 和 Tags Map 設定</h2><p>Hexo 預設會依照文章的 <code>categories</code> 和 <code>tags</code> 生成對應的分類和標籤頁面。您可以透過設定 <code>_config.yml</code> 來自定義這些分類與標籤的映射。</p><h3 id="3-1-Categories-Map"><a href="#3-1-Categories-Map" class="headerlink" title="3.1 Categories Map"></a>3.1 Categories Map</h3><p>如果您的部落格文章使用了不同的分類名稱來表示類似的主題，您可以使用 category_map 來統一它們。例如，將「設計模式」和「設計」映射成同一個分類。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">category_map:</span><br>    <span class="hljs-attr">design_patterns:</span> <span class="hljs-string">design</span><br></code></pre></td></tr></table></figure><h3 id="3-2-Tags-Map"><a href="#3-2-Tags-Map" class="headerlink" title="3.2 Tags Map"></a>3.2 Tags Map</h3><p>同樣地，對於標籤，如果您有多個不同表達方式的標籤，您可以將它們映射為單一的標籤。這樣不僅讓網站結構更加清晰，也有助於搜尋引擎更好地理解您的內容分類。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tag_map:</span><br>    <span class="hljs-attr">front_end_development:</span> <span class="hljs-string">frontend</span><br></code></pre></td></tr></table></figure><hr><h2 id="4-部署選項"><a href="#4-部署選項" class="headerlink" title="4. 部署選項"></a>4. 部署選項</h2><p>在這篇指南中，我們主要聚焦於使用 GitHub Pages 來部署您的 Hexo 部落格。</p><h3 id="4-1-部署到-GitHub-Pages"><a href="#4-1-部署到-GitHub-Pages" class="headerlink" title="4.1 部署到 GitHub Pages"></a>4.1 部署到 GitHub Pages</h3><p>首先，您需要創建一個 GitHub Repository，將您的部落格部署到 GitHub Pages 上。接著，設定 GitHub 部署信息在 <code>_config.yml</code> 中。</p><p>GitHub Pages 的最佳實踐是使用 <code>gh-pages</code> 分支來部署靜態網站，這樣能保持主分支與部署分支的分離。使用以下指令來生成並部署網站：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate --deploy<br><span class="hljs-comment"># 或使用簡寫</span><br>hexo g -d<br></code></pre></td></tr></table></figure><p>這樣的設定會將網站的靜態檔案推送到您設定的 GitHub 倉庫中。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>為什麼我開始寫部落格</title>
    <link href="/personal-update/20240901/2738877605/"/>
    <url>/personal-update/20240901/2738877605/</url>
    
    <content type="html"><![CDATA[<h1 id="為什麼我開始寫部落格"><a href="#為什麼我開始寫部落格" class="headerlink" title="為什麼我開始寫部落格"></a>為什麼我開始寫部落格</h1><p><img src="/images/blog/2024-09-01-blog.png" alt="寫部落格的起點"></p><p>嗨大家好！我是 Terry。<br>最近有不少朋友問我：「Terry，你怎麼突然開始寫部落格了？」這個問題讓我覺得，是時候與大家分享我的心路歷程了。泡杯咖啡，來聊聊我為什麼開始這段寫作之旅，以及我希望透過這個部落格帶給大家什麼。</p><h2 id="分享讓我們有更多觀點"><a href="#分享讓我們有更多觀點" class="headerlink" title="分享讓我們有更多觀點"></a>分享讓我們有更多觀點</h2><p>這些年來，我在職場中經歷了不少事，學到了許多。不論是管理、創新還是數位轉型，都積累了一些心得。把這些經驗藏在腦中太可惜了，不如拿出來與大家一起討論分享。<br>這個部落格就是我的舞台，讓我能將腦中的點子和經驗整理後分享給大家。說不定你看了之後，還能給我一些新的想法呢！</p><h2 id="寫作-學習的另一種方式"><a href="#寫作-學習的另一種方式" class="headerlink" title="寫作 &#x3D; 學習的另一種方式"></a>寫作 &#x3D; 學習的另一種方式</h2><p>老實說，寫文章並不簡單。為了寫出有料的內容，我得不斷學習、思考、整理自己的想法。每次準備一篇文章，都感覺自己又成長了一點點。<br>這個過程就像在和自己對話：「你真的懂這個嗎？」、「這個觀點站得住腳嗎？」挑戰自己同時也是在學習。我認為這種活到老學到老的態度，在瞬息萬變的職場中非常重要。</p><h2 id="交朋友的新方式"><a href="#交朋友的新方式" class="headerlink" title="交朋友的新方式"></a>交朋友的新方式</h2><p>在這個被螢幕包圍的時代，人與人之間的連結變得有些虛無縹緲。通過這個部落格，我希望能和你們建立一種更真實的連結。不僅是分享知識，我還想聊聊我的想法，甚至是工作中的困惑和挑戰。<br>我希望這裡成為我們一起腦力激盪的地方。你的每一個留言、每一個想法，都可能成為我們下一個精彩對話的開始。很期待看到你們的反應呢！</p><h2 id="大聲嚷嚷以後會讓自己沒有退路"><a href="#大聲嚷嚷以後會讓自己沒有退路" class="headerlink" title="大聲嚷嚷以後會讓自己沒有退路"></a>大聲嚷嚷以後會讓自己沒有退路</h2><p>我的終極目標是希望能夠啟發大家，給予大家一些能量。希望通過我的文章，能帶給你們新的想法、實用的小技巧或有效的策略，希望我的文章都能給你一點啟發。<br>說真的我有點緊張，但我覺得這會是一段很酷的旅程。通過寫文章，我可以記錄這過程中的酸甜苦辣，也可以和大家分享我的心路歷程。<br>也許我的經歷會成為某個人的參考，也許我遇到的問題和解決方法，正好就是你需要的。通過我的分享，希望能讓更多人勇敢做想做的事情，就像我現在做的這樣。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>開始寫部落格對我來說是一個全新的挑戰，但我非常期待！我希望通過這個平台，與你們分享知識，交換想法，一起成長。<br>你的每一次點擊、每一個留言，都是支持我繼續寫下去的動力。讓我們一起在這個小天地裡，探索新知識，學點新東西，看看能不能擦出一些火花。<br>有什麼特別想看的主題嗎？或者有什麼經驗想和我分享？期待在留言區看到你的身影，也隨時歡迎你丟一些想法或建議給我。讓我們一起把這個部落格變得更有趣、更有料吧！<br>謝謝大家的支持！</p>]]></content>
    
    
    <categories>
      
      <category>個人成長</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部落格寫作</tag>
      
      <tag>職涯轉型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[design pattern] decorator pattern：為物件動態添加超能力</title>
    <link href="/designpattern/20240901/91682934/"/>
    <url>/designpattern/20240901/91682934/</url>
    
    <content type="html"><![CDATA[<h2 id="Decorator-模式：為物件裝上百變功能的神奇魔法"><a href="#Decorator-模式：為物件裝上百變功能的神奇魔法" class="headerlink" title="Decorator 模式：為物件裝上百變功能的神奇魔法"></a>Decorator 模式：為物件裝上百變功能的神奇魔法</h2><p>想像一下，如果你能像變形金剛一樣，隨時為自己添加新的功能和裝備，那該有多酷！在程式設計中，Decorator 模式就能實現這種神奇的效果。它讓我們能夠在不修改原有程式碼的情況下，動態地為物件添加新功能。讓我們一起來探索這個強大又靈活的設計模式吧！</p><h3 id="1-Decorator-模式是什麼？"><a href="#1-Decorator-模式是什麼？" class="headerlink" title="1. Decorator 模式是什麼？"></a>1. Decorator 模式是什麼？</h3><p>Decorator 模式就像給物件穿上不同的衣服：</p><ol><li><strong>基本物件</strong>：就像是一個簡單的機器人。</li><li><strong>裝飾器</strong>：各種功能模組，可以自由組合。</li><li><strong>靈活組合</strong>：可以隨時添加或移除功能，不影響基本物件。</li></ol><h3 id="2-為什麼要用-Decorator？"><a href="#2-為什麼要用-Decorator？" class="headerlink" title="2. 為什麼要用 Decorator？"></a>2. 為什麼要用 Decorator？</h3><p>Decorator 模式在許多場景下都能派上用場：</p><ol><li><strong>咖啡訂製系統</strong>：基本咖啡加上各種配料，每種配料都是一個裝飾器。</li><li><strong>遊戲角色系統</strong>：基本角色可以裝備各種道具，每種道具都是一個裝飾器。</li><li><strong>文件處理系統</strong>：對文件進行多重處理，如壓縮、加密等，每個處理步驟都是一個裝飾器。</li></ol><h3 id="3-Decorator-模式實戰：打造一個靈活的咖啡訂製系統"><a href="#3-Decorator-模式實戰：打造一個靈活的咖啡訂製系統" class="headerlink" title="3. Decorator 模式實戰：打造一個靈活的咖啡訂製系統"></a>3. Decorator 模式實戰：打造一個靈活的咖啡訂製系統</h3><p>接下來，我們來看看如何用 Decorator 模式實現一個炫酷的咖啡訂製系統：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicCoffee</span> &#123;<br>    <span class="hljs-title function_">cost</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>; <span class="hljs-comment">// 基本咖啡的價格</span><br>    &#125;<br><br>    <span class="hljs-title function_">description</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Basic Coffee&#x27;</span>; <span class="hljs-comment">// 基本咖啡的描述</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">coffee</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">coffee</span> = coffee;<br>    &#125;<br><br>    <span class="hljs-title function_">cost</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">coffee</span>.<span class="hljs-title function_">cost</span>();<br>    &#125;<br><br>    <span class="hljs-title function_">description</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">coffee</span>.<span class="hljs-title function_">description</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MilkDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Decorator</span> &#123;<br>    <span class="hljs-title function_">cost</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">cost</span>() + <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-title function_">description</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">super</span>.description()&#125;</span> + Milk`</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SugarDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Decorator</span> &#123;<br>    <span class="hljs-title function_">cost</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">cost</span>() + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-title function_">description</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">super</span>.description()&#125;</span> + Sugar`</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">let</span> coffee = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BasicCoffee</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(coffee.<span class="hljs-title function_">cost</span>()); <span class="hljs-comment">// 5</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(coffee.<span class="hljs-title function_">description</span>()); <span class="hljs-comment">// &#x27;Basic Coffee&#x27;</span><br><br>coffee = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MilkDecorator</span>(coffee);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(coffee.<span class="hljs-title function_">cost</span>()); <span class="hljs-comment">// 7</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(coffee.<span class="hljs-title function_">description</span>()); <span class="hljs-comment">// &#x27;Basic Coffee + Milk&#x27;</span><br><br>coffee = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SugarDecorator</span>(coffee);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(coffee.<span class="hljs-title function_">cost</span>()); <span class="hljs-comment">// 8</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(coffee.<span class="hljs-title function_">description</span>()); <span class="hljs-comment">// &#x27;Basic Coffee + Milk + Sugar&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="4-Decorator-模式的實際應用場景"><a href="#4-Decorator-模式的實際應用場景" class="headerlink" title="4. Decorator 模式的實際應用場景"></a>4. Decorator 模式的實際應用場景</h3><ol><li><p><strong>GUI 元件系統</strong>：</p><ul><li>為基本按鈕添加邊框、陰影、動畫效果等。例如，你可以用 Decorator 模式來組合這些效果，使按鈕更加吸引人。</li></ul></li><li><p><strong>遊戲開發</strong>：</p><ul><li>為遊戲角色添加各種技能和裝備，如加速、隱身或特殊攻擊。</li></ul></li><li><p><strong>網路請求處理</strong>：</p><ul><li>為 HTTP 請求添加身份驗證、日誌記錄、錯誤處理等功能，使請求處理更加全面和安全。</li></ul></li><li><p><strong>資料流處理</strong>：</p><ul><li>為資料流添加壓縮、加密、格式轉換等處理步驟，確保資料在傳輸過程中的安全性和完整性。</li></ul></li></ol><h3 id="5-Decorator-模式的注意事項"><a href="#5-Decorator-模式的注意事項" class="headerlink" title="5. Decorator 模式的注意事項"></a>5. Decorator 模式的注意事項</h3><ol><li><strong>複雜度管理</strong>：過多的裝飾器可能導致系統變得複雜，需要謹慎管理。</li><li><strong>順序敏感</strong>：某些情況下，裝飾器的應用順序可能會影響最終結果，需要注意順序的合理安排。</li><li><strong>透明性</strong>：確保裝飾後的物件與原物件保持一致的介面，這樣才能確保系統的可預測性和穩定性。</li><li><strong>效能考慮</strong>：在高效能要求的場景中，多層裝飾可能會帶來效能損耗，因此需權衡裝飾的層數與效能之間的平衡。</li></ol><h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>Decorator 模式就像給你的程式碼穿上了一件百變魔術服，讓你能夠靈活地為物件添加新功能，而不需要修改現有的程式碼。無論是在開發咖啡訂製系統、遊戲角色系統，還是複雜的資料處理流程中，Decorator 模式都能讓你的程式碼更加靈活和可擴展。下次當你需要為物件動態添加功能時，不妨試試這個神奇的設計模式吧！</p>]]></content>
    
    
    <categories>
      
      <category>design pattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>design pattern</tag>
      
      <tag>結構設計模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[design pattern] Observer 模式：讓你的系統具備超強感應力</title>
    <link href="/designpattern/20240901/65878994/"/>
    <url>/designpattern/20240901/65878994/</url>
    
    <content type="html"><![CDATA[<h2 id="Observer-模式：讓你的系統變身為超級偵探"><a href="#Observer-模式：讓你的系統變身為超級偵探" class="headerlink" title="Observer 模式：讓你的系統變身為超級偵探"></a>Observer 模式：讓你的系統變身為超級偵探</h2><p>想像一下，如果你的系統能夠像福爾摩斯一樣，對任何細微的變化都瞬間做出反應，那會是多麼酷的一件事！這就是 Observer 模式要帶給我們的超能力。它讓你的系統變得既敏感又靈活，能夠在關鍵時刻立即通知所有相關方。讓我們一起來探索這個神奇的設計模式吧！</p><h3 id="1-Observer-模式是什麼？"><a href="#1-Observer-模式是什麼？" class="headerlink" title="1. Observer 模式是什麼？"></a>1. Observer 模式是什麼？</h3><p>簡單來說，Observer 模式就像是一個訂閱系統：</p><ol><li><strong>被觀察者（明星）</strong>：就像是大明星，負責發布最新動態。</li><li><strong>觀察者（粉絲）</strong>：就是關注明星的粉絲，隨時準備接收最新消息。</li><li><strong>通知機制（社交媒體）</strong>：當明星有新動態時，社交媒體立即推送消息給所有粉絲。</li></ol><h3 id="2-為什麼要用-Observer？"><a href="#2-為什麼要用-Observer？" class="headerlink" title="2. 為什麼要用 Observer？"></a>2. 為什麼要用 Observer？</h3><p>Observer 模式在很多場景下都能大顯身手：</p><ol><li><strong>新聞訂閱系統</strong>：讓用戶即時收到最新新聞，再也不怕錯過重要資訊。</li><li><strong>股票交易平台</strong>：當股價變動時，立即通知所有關注該股票的投資者。</li><li><strong>遊戲開發</strong>：當遊戲狀態改變時，及時更新所有相關的遊戲元素。</li></ol><h3 id="3-Observer-模式實戰：打造一個超級新聞訂閱系統"><a href="#3-Observer-模式實戰：打造一個超級新聞訂閱系統" class="headerlink" title="3. Observer 模式實戰：打造一個超級新聞訂閱系統"></a>3. Observer 模式實戰：打造一個超級新聞訂閱系統</h3><p>來看看如何用 Observer 模式實現一個炫酷的新聞訂閱系統：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NewsCategory</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">categoryName</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">categoryName</span> = categoryName;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscribers</span> = [];<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">latestNews</span> = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">observer</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">subscribers</span>.<span class="hljs-title function_">includes</span>(observer)) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscribers</span>.<span class="hljs-title function_">push</span>(observer);<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;observer.username&#125;</span> 訂閱了 <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.categoryName&#125;</span> 類別的新聞`</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-title function_">unsubscribe</span>(<span class="hljs-params">observer</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscribers</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscribers</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">sub</span> =&gt;</span> sub !== observer);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;observer.username&#125;</span> 取消訂閱了 <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.categoryName&#125;</span> 類別的新聞`</span>);<br>    &#125;<br><br>    <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> subscriber <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscribers</span>) &#123;<br>            subscriber.<span class="hljs-title function_">update</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">latestNews</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-title function_">publish</span>(<span class="hljs-params">news</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">latestNews</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.categoryName&#125;</span>: <span class="hljs-subst">$&#123;news&#125;</span>`</span>;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`發布新聞：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.latestNews&#125;</span>`</span>);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">notify</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">username</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">username</span> = username;<br>    &#125;<br><br>    <span class="hljs-title function_">update</span>(<span class="hljs-params">news</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.username&#125;</span> 收到新聞: <span class="hljs-subst">$&#123;news&#125;</span>`</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> sportsNews = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NewsCategory</span>(<span class="hljs-string">&#x27;體育&#x27;</span>);<br><span class="hljs-keyword">const</span> user1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&#x27;小明&#x27;</span>);<br><span class="hljs-keyword">const</span> user2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&#x27;小華&#x27;</span>);<br><br>sportsNews.<span class="hljs-title function_">subscribe</span>(user1);<br>sportsNews.<span class="hljs-title function_">subscribe</span>(user2);<br><br>sportsNews.<span class="hljs-title function_">publish</span>(<span class="hljs-string">&#x27;台灣隊奧運奪金！&#x27;</span>);<br><br>sportsNews.<span class="hljs-title function_">unsubscribe</span>(user1);<br><br>sportsNews.<span class="hljs-title function_">publish</span>(<span class="hljs-string">&#x27;世界盃比賽結果出爐&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="4-Observer-模式的實際應用場景"><a href="#4-Observer-模式的實際應用場景" class="headerlink" title="4. Observer 模式的實際應用場景"></a>4. Observer 模式的實際應用場景</h3><ol><li><p><strong>即時通訊軟體</strong>：</p><ul><li>當有新消息時，立即通知所有在線用戶。</li><li>群組聊天中，一個人發消息，所有群成員都能收到通知。</li></ul></li><li><p><strong>物聯網設備監控</strong>：</p><ul><li>當智能家電狀態改變時（如溫度超標），立即通知家庭成員或維修系統。</li></ul></li><li><p><strong>社交媒體平台</strong>：</p><ul><li>當你關注的人發布新動態時，你會立即收到通知。</li></ul></li><li><p><strong>電子商務平台</strong>：</p><ul><li>當商品降價或庫存狀態改變時，通知關注該商品的用戶。</li></ul></li><li><p><strong>任務管理系統</strong>：</p><ul><li>當項目狀態更新時，自動通知所有相關團隊成員。</li></ul></li></ol><h3 id="5-Observer-模式的注意事項"><a href="#5-Observer-模式的注意事項" class="headerlink" title="5. Observer 模式的注意事項"></a>5. Observer 模式的注意事項</h3><ol><li><strong>性能考慮</strong>：當觀察者很多時，通知過程可能會耗時。考慮使用異步通知或批量處理。</li><li><strong>內存管理</strong>：記得在觀察者不再需要時取消訂閱，避免內存洩漏。</li><li><strong>循環依賴</strong>：小心處理觀察者和被觀察者之間可能的循環依賴問題。</li><li><strong>線程安全</strong>：在多線程環境中使用時，要確保通知過程的線程安全。</li></ol><h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>Observer 模式就像給你的系統裝上了一雙火眼金睛，讓它能夠敏銳地察覺任何變化並迅速做出反應。無論是在開發新聞訂閱系統、即時通訊軟體，還是物聯網應用中，Observer 模式都能讓你的系統變得更加靈活和及時。下次遇到需要建立一對多依賴關係的場景時，不妨試試這個超級實用的設計模式吧！</p>]]></content>
    
    
    <categories>
      
      <category>design pattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>design pattern</tag>
      
      <tag>行為設計模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[design pattern] Strategy pattern：讓你的系統更靈活的秘訣</title>
    <link href="/designpattern/20240901/4214942545/"/>
    <url>/designpattern/20240901/4214942545/</url>
    
    <content type="html"><![CDATA[<h2 id="Strategy-模式：讓你的系統隨時變身的魔法"><a href="#Strategy-模式：讓你的系統隨時變身的魔法" class="headerlink" title="Strategy 模式：讓你的系統隨時變身的魔法"></a>Strategy 模式：讓你的系統隨時變身的魔法</h2><p>想像一下，如果你的系統能像變形金剛一樣，隨時根據需求變換不同的能力，那該有多酷？這就是 Strategy 模式要帶給我們的魔法！這個模式讓你的系統可以在運行時輕鬆切換不同的行為，就像給你的程式裝上了百寶箱。讓我們一起來探索這個神奇的設計模式吧！</p><h3 id="1-Strategy-模式是什麼？"><a href="#1-Strategy-模式是什麼？" class="headerlink" title="1. Strategy 模式是什麼？"></a>1. Strategy 模式是什麼？</h3><p>簡單來說，Strategy 模式就是：</p><ol><li><strong>把不同的招式分開練</strong>：將不同的算法或行為包裝成獨立的”武功秘笈”（策略類）。</li><li><strong>隨時切換絕招</strong>：讓你的系統可以在需要的時候，立即換成不同的”武功”（策略）。</li><li><strong>輕鬆學習新招式</strong>：想要添加新的行為？直接寫個新的”秘笈”就行，不用改動原有的代碼。</li></ol><h3 id="2-為什麼要用-Strategy？"><a href="#2-為什麼要用-Strategy？" class="headerlink" title="2. 為什麼要用 Strategy？"></a>2. 為什麼要用 Strategy？</h3><p>Strategy 模式在很多場景下都能派上用場：</p><ol><li><strong>支付系統</strong>：今天用信用卡，明天用 LINE Pay，後天用 Apple Pay，系統都不怕！</li><li><strong>檔案壓縮</strong>：ZIP、RAR、7z，不同的壓縮方式隨你挑。</li><li><strong>路線規劃</strong>：開車、騎車、走路，不同的出行方式一鍵切換。</li></ol><h3 id="3-Strategy-在實際系統中的應用"><a href="#3-Strategy-在實際系統中的應用" class="headerlink" title="3. Strategy 在實際系統中的應用"></a>3. Strategy 在實際系統中的應用</h3><h4 id="3-1-電商平台的促銷系統"><a href="#3-1-電商平台的促銷系統" class="headerlink" title="3.1 電商平台的促銷系統"></a>3.1 電商平台的促銷系統</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PromotionContext</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">strategy</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">strategy</span> = strategy;<br>    &#125;<br><br>    <span class="hljs-title function_">setStrategy</span>(<span class="hljs-params">strategy</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">strategy</span> = strategy;<br>    &#125;<br><br>    <span class="hljs-title function_">calculateDiscount</span>(<span class="hljs-params">amount</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">strategy</span>.<span class="hljs-title function_">applyDiscount</span>(amount);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> blackFridayStrategy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlackFridayStrategy</span>();<br><span class="hljs-keyword">const</span> context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PromotionContext</span>(blackFridayStrategy);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(context.<span class="hljs-title function_">calculateDiscount</span>(<span class="hljs-number">1000</span>)); <span class="hljs-comment">// 輸出: 折扣後價格為 800 元</span><br></code></pre></td></tr></table></figure><h4 id="3-2-遊戲中的角色行為"><a href="#3-2-遊戲中的角色行為" class="headerlink" title="3.2 遊戲中的角色行為"></a>3.2 遊戲中的角色行為</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CharacterContext</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">strategy</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">strategy</span> = strategy;<br>    &#125;<br><br>    <span class="hljs-title function_">setStrategy</span>(<span class="hljs-params">strategy</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">strategy</span> = strategy;<br>    &#125;<br><br>    <span class="hljs-title function_">move</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">strategy</span>.<span class="hljs-title function_">move</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> walkStrategy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WalkStrategy</span>();<br><span class="hljs-keyword">const</span> character = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CharacterContext</span>(walkStrategy);<br>character.<span class="hljs-title function_">move</span>(); <span class="hljs-comment">// 輸出: 角色正在走路</span><br><br><span class="hljs-keyword">const</span> runStrategy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunStrategy</span>();<br>character.<span class="hljs-title function_">setStrategy</span>(runStrategy);<br>character.<span class="hljs-title function_">move</span>(); <span class="hljs-comment">// 輸出: 角色正在跑步</span><br></code></pre></td></tr></table></figure><h3 id="4-Strategy-模式的優缺點"><a href="#4-Strategy-模式的優缺點" class="headerlink" title="4. Strategy 模式的優缺點"></a>4. Strategy 模式的優缺點</h3><h4 id="好處"><a href="#好處" class="headerlink" title="好處"></a>好處</h4><ol><li><strong>超級靈活</strong>：想換就換，系統變得特別有彈性。</li><li><strong>擴展超Easy</strong>：要加新功能？小菜一碟！</li><li><strong>程式碼更整潔</strong>：告別冗長的 if-else，代碼看起來更舒服。</li></ol><h4 id="小缺點"><a href="#小缺點" class="headerlink" title="小缺點"></a>小缺點</h4><ol><li><strong>類別可能會變多</strong>：每個策略都是一個類，類的數量可能會增加。</li><li><strong>選擇策略需要小心</strong>：使用時要知道每個策略適合什麼場景。</li></ol><h3 id="5-你的系統哪裡可以用-Strategy？"><a href="#5-你的系統哪裡可以用-Strategy？" class="headerlink" title="5. 你的系統哪裡可以用 Strategy？"></a>5. 你的系統哪裡可以用 Strategy？</h3><ol><li><strong>訂單處理系統</strong>：根據不同的訂單類型（普通、加急、批發）使用不同的處理策略。</li><li><strong>日誌記錄系統</strong>：根據不同的日誌級別（debug、info、warning、error）選擇不同的記錄策略。</li><li><strong>數據分析系統</strong>：根據不同的數據類型和分析需求，選擇不同的分析算法。</li><li><strong>圖像處理軟件</strong>：根據不同的濾鏡效果，應用不同的圖像處理策略。</li><li><strong>客戶服務系統</strong>：根據客戶等級（VIP、普通會員、非會員）選擇不同的服務策略。</li></ol><h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>Strategy 模式就像是給你的系統安裝了一個百變開關，讓它能夠靈活應對各種場景。無論是在電商平台、遊戲開發，還是企業應用中，Strategy 模式都能讓你的系統變得更加靈活有趣。下次遇到需要根據不同情況切換行為的場景，不妨試試這個魔法般的設計模式吧！</p>]]></content>
    
    
    <categories>
      
      <category>design pattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>design pattern</tag>
      
      <tag>行為設計模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[design pattern] factory pattern：打造物件創建的萬能工具</title>
    <link href="/designpattern/20240827/2464715971/"/>
    <url>/designpattern/20240827/2464715971/</url>
    
    <content type="html"><![CDATA[<h2 id="工廠模式：物件創建的神奇魔法師"><a href="#工廠模式：物件創建的神奇魔法師" class="headerlink" title="工廠模式：物件創建的神奇魔法師"></a>工廠模式：物件創建的神奇魔法師</h2><p>在軟體開發的世界裡，工廠模式（Factory Pattern）就像是一位多才多藝的魔法師，能夠根據不同的需求變出各種類型的物件。這個設計模式通過包裝物件的創建過程，為我們提供了一種既簡單又高效的方式來處理複雜的物件實例化邏輯。讓我們一起來認識這個厲害的設計模式吧！</p><h3 id="1-工廠模式的核心理念"><a href="#1-工廠模式的核心理念" class="headerlink" title="1. 工廠模式的核心理念"></a>1. 工廠模式的核心理念</h3><p>工廠模式的核心思想其實很簡單，就像是：</p><ol><li><strong>把變化藏起來</strong>：將物件的創建過程藏在工廠類別中，讓使用者不需要知道太多細節。</li><li><strong>讓使用更簡單</strong>：使用者只需要知道要什麼，不需要知道怎麼做。</li><li><strong>集中管理</strong>：在一個地方統一管理物件的創建，方便修改和維護。</li><li><strong>容易添加新功能</strong>：可以輕鬆地添加新的物件類型，不需要大改現有的程式碼。</li></ol><h3 id="2-工廠模式的種類"><a href="#2-工廠模式的種類" class="headerlink" title="2. 工廠模式的種類"></a>2. 工廠模式的種類</h3><p>工廠模式主要有三種類型：</p><ol><li><strong>簡單工廠（Simple Factory）</strong>：就像是一個小型工作坊，用一個簡單的方法來創建物件。</li><li><strong>工廠方法（Factory Method）</strong>：像是一條生產線，可以生產不同類型的產品。</li><li><strong>抽象工廠（Abstract Factory）</strong>：像是一個大型工廠，可以同時生產多種相關的產品。</li></ol><h3 id="3-工廠模式的實際應用場景"><a href="#3-工廠模式的實際應用場景" class="headerlink" title="3. 工廠模式的實際應用場景"></a>3. 工廠模式的實際應用場景</h3><p>工廠模式在很多地方都能派上用場，例如：</p><ol><li><strong>支付系統</strong>：根據用戶選擇的支付方式（信用卡、PayPal、銀行轉帳等）創建對應的支付處理物件。</li><li><strong>資料庫連線</strong>：根據設定創建不同類型的資料庫連線（MySQL、PostgreSQL、MongoDB等）。</li><li><strong>使用者介面元件</strong>：根據使用者的主題設定創建不同風格的UI元件。</li><li><strong>日誌系統</strong>：根據設定創建不同類型的日誌記錄器（檔案日誌、資料庫日誌、網路日誌等）。</li><li><strong>跨平台應用開發</strong>：根據執行平台創建適合的系統服務物件。</li></ol><h3 id="4-實際範例：工廠模式的實作"><a href="#4-實際範例：工廠模式的實作" class="headerlink" title="4. 實際範例：工廠模式的實作"></a>4. 實際範例：工廠模式的實作</h3><p>讓我們通過一個支付系統的例子來看看工廠模式是如何運作的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 支付基礎類別</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Payment</span> &#123;<br>    <span class="hljs-title function_">process</span>(<span class="hljs-params">amount</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;process() 必須由子類別實作&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具體支付類別：信用卡支付</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CreditCardPayment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Payment</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">&#123; cardNumber, cardHolder, expirationDate &#125;</span>) &#123;<br>        <span class="hljs-variable language_">super</span>();<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cardNumber</span> = cardNumber;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cardHolder</span> = cardHolder;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">expirationDate</span> = expirationDate;<br>    &#125;<br><br>    <span class="hljs-title function_">process</span>(<span class="hljs-params">amount</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">`正在處理 <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.cardHolder&#125;</span> 的信用卡支付，金額為 <span class="hljs-subst">$&#123;amount&#125;</span>`</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具體支付類別：PayPal支付</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PayPalPayment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Payment</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">&#123; email &#125;</span>) &#123;<br>        <span class="hljs-variable language_">super</span>();<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">email</span> = email;<br>    &#125;<br><br>    <span class="hljs-title function_">process</span>(<span class="hljs-params">amount</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">`正在處理 <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.email&#125;</span> 的PayPal支付，金額為 <span class="hljs-subst">$&#123;amount&#125;</span>`</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 支付工廠類別</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentFactory</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">paymentMethods</span> = &#123;<br>            <span class="hljs-title class_">CreditCard</span>: <span class="hljs-title class_">CreditCardPayment</span>,<br>            <span class="hljs-title class_">PayPal</span>: <span class="hljs-title class_">PayPalPayment</span><br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-title function_">createPayment</span>(<span class="hljs-params">method, options</span>) &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-title class_">PaymentMethod</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">paymentMethods</span>[method];<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">PaymentMethod</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;未知的支付方式&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PaymentMethod</span>(options);<br>    &#125;<br><br>    <span class="hljs-comment">// 動態新增支付方式</span><br>    <span class="hljs-title function_">addPaymentMethod</span>(<span class="hljs-params">methodName, PaymentClass</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">paymentMethods</span>[methodName] = <span class="hljs-title class_">PaymentClass</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用範例</span><br><span class="hljs-keyword">const</span> factory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PaymentFactory</span>();<br><br><span class="hljs-keyword">const</span> creditCardPayment = factory.<span class="hljs-title function_">createPayment</span>(<span class="hljs-string">&#x27;CreditCard&#x27;</span>, &#123;<br>    <span class="hljs-attr">cardNumber</span>: <span class="hljs-string">&#x27;1234 5678 9012 3456&#x27;</span>,<br>    <span class="hljs-attr">cardHolder</span>: <span class="hljs-string">&#x27;王小明&#x27;</span>,<br>    <span class="hljs-attr">expirationDate</span>: <span class="hljs-string">&#x27;12/25&#x27;</span><br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(creditCardPayment.<span class="hljs-title function_">process</span>(<span class="hljs-number">100</span>)); <span class="hljs-comment">// 輸出: 正在處理 王小明 的信用卡支付，金額為 100</span><br><br><span class="hljs-keyword">const</span> paypalPayment = factory.<span class="hljs-title function_">createPayment</span>(<span class="hljs-string">&#x27;PayPal&#x27;</span>, &#123; <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;xiaoming@example.com&#x27;</span> &#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(paypalPayment.<span class="hljs-title function_">process</span>(<span class="hljs-number">50</span>)); <span class="hljs-comment">// 輸出: 正在處理 xiaoming@example.com 的PayPal支付，金額為 50</span><br><br><span class="hljs-comment">// 動態新增新的支付方式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BitcoinPayment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Payment</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">&#123; address &#125;</span>) &#123;<br>        <span class="hljs-variable language_">super</span>();<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">address</span> = address;<br>    &#125;<br><br>    <span class="hljs-title function_">process</span>(<span class="hljs-params">amount</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">`正在處理比特幣支付，金額為 <span class="hljs-subst">$&#123;amount&#125;</span>，支付地址：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.address&#125;</span>`</span>;<br>    &#125;<br>&#125;<br><br>factory.<span class="hljs-title function_">addPaymentMethod</span>(<span class="hljs-string">&#x27;Bitcoin&#x27;</span>, <span class="hljs-title class_">BitcoinPayment</span>);<br><br><span class="hljs-keyword">const</span> bitcoinPayment = factory.<span class="hljs-title function_">createPayment</span>(<span class="hljs-string">&#x27;Bitcoin&#x27;</span>, &#123; <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2&#x27;</span> &#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bitcoinPayment.<span class="hljs-title function_">process</span>(<span class="hljs-number">200</span>)); <span class="hljs-comment">// 輸出: 正在處理比特幣支付，金額為 200，支付地址：1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2</span><br></code></pre></td></tr></table></figure><p>這個例子展示了如何使用工廠模式創建不同類型的支付物件，以及如何動態新增支援新的支付方式。</p><h3 id="5-工廠模式的優缺點"><a href="#5-工廠模式的優缺點" class="headerlink" title="5. 工廠模式的優缺點"></a>5. 工廠模式的優缺點</h3><h4 id="優點"><a href="#優點" class="headerlink" title="優點"></a>優點</h4><ol><li><strong>降低耦合度</strong>：使用者的程式碼不需要和具體的產品類別綁定在一起，更容易修改和維護。</li><li><strong>容易擴展</strong>：可以輕鬆新增新的產品類別，不需要修改現有的使用者程式碼。</li><li><strong>集中管理</strong>：將物件的創建邏輯集中在一處，方便統一管理和修改。</li><li><strong>簡化使用</strong>：工廠封裝了複雜的創建邏輯，讓使用者的程式碼更簡單。</li></ol><h4 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h4><ol><li><strong>增加類別數量</strong>：引入工廠類別和產品層次結構，可能會讓系統變得更複雜。</li><li><strong>可能違反開閉原則</strong>：如果經常需要新增新產品，可能需要修改工廠類別。</li><li><strong>對簡單物件可能過度設計</strong>：如果只有一兩種簡單的物件，使用工廠模式可能有點小題大作。</li></ol><h3 id="6-工廠模式的最佳實踐"><a href="#6-工廠模式的最佳實踐" class="headerlink" title="6. 工廠模式的最佳實踐"></a>6. 工廠模式的最佳實踐</h3><ol><li><strong>使用設定檔</strong>：將產品類型和具體類別的對應關係存在設定檔中，這樣就可以在不修改程式碼的情況下新增新產品。</li><li><strong>搭配單例模式</strong>：工廠類別通常只需要一個實例，可以使用單例模式來實作。</li><li><strong>善用反射機制</strong>：在支援反射的程式語言中，可以使用反射來動態創建物件，讓系統更有彈性。</li><li><strong>考慮使用依賴注入</strong>：在某些情況下，依賴注入可能比工廠模式更適合，特別是在使用依賴注入框架的大型專案中。</li></ol><h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>工廠模式是一個既強大又靈活的設計模式，它通過包裝物件創建的過程，為我們提供了一種優雅的方式來處理複雜的實例化邏輯。在設計系統時，合理使用工廠模式可以大大提高程式碼的可維護性和擴展性。不過，也要注意不要過度使用，對於簡單的情況，直接使用建構函式可能更直接有效。</p><p>作為一個優秀的軟體工程師，掌握工廠模式及其變體，並能在適當的場景中靈活運用，將使你的程式碼更加健壯、靈活且易於維護。</p>]]></content>
    
    
    <categories>
      
      <category>design pattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>design pattern</tag>
      
      <tag>創建設計模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[design pattern] singleton 模式：確保單一實例的關鍵設計</title>
    <link href="/designpattern/20240825/1906628077/"/>
    <url>/designpattern/20240825/1906628077/</url>
    
    <content type="html"><![CDATA[<h2 id="Singleton-模式：單一實例的守護者"><a href="#Singleton-模式：單一實例的守護者" class="headerlink" title="Singleton 模式：單一實例的守護者"></a>Singleton 模式：單一實例的守護者</h2><p>在軟體開發的世界中，Singleton 模式就像是一個精明的管家，確保特定類別在整個應用程序中只存在一個實例。這種設計不僅節省了寶貴的系統資源，還為共享資源的管理提供了一致性保證。讓我們深入探討這個既簡單又強大的設計模式。</p><h3 id="1-Singleton-模式的核心理念"><a href="#1-Singleton-模式的核心理念" class="headerlink" title="1. Singleton 模式的核心理念"></a>1. Singleton 模式的核心理念</h3><p>Singleton 模式的核心思想是：</p><ol><li><strong>唯一性</strong>：確保一個類別只有一個實例。</li><li><strong>全局訪問</strong>：提供一個全局訪問點來獲取這個唯一實例。</li><li><strong>延遲初始化</strong>：通常採用延遲加載（lazy loading）策略，即在首次使用時才創建實例。</li></ol><h3 id="2-為什麼選擇-Singleton？"><a href="#2-為什麼選擇-Singleton？" class="headerlink" title="2. 為什麼選擇 Singleton？"></a>2. 為什麼選擇 Singleton？</h3><p>在許多場景中，Singleton 模式成為了開發者的首選：</p><ol><li><strong>資源共享</strong>：當多個組件需要訪問同一資源時，Singleton 可以確保資源的一致性。</li><li><strong>狀態管理</strong>：在需要維護全局狀態的應用中，Singleton 提供了一個集中管理的方案。</li><li><strong>性能優化</strong>：通過重用單一實例，可以顯著減少記憶體使用和提高性能。</li></ol><h3 id="3-Singleton-的實際應用場景"><a href="#3-Singleton-的實際應用場景" class="headerlink" title="3. Singleton 的實際應用場景"></a>3. Singleton 的實際應用場景</h3><p>讓我們看看 Singleton 在實際開發中的一些常見應用：</p><h4 id="3-1-配置管理"><a href="#3-1-配置管理" class="headerlink" title="3.1 配置管理"></a>3.1 配置管理</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigManager</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_config</span> = &#123;&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">getInstance</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">ConfigManager</span>.<span class="hljs-property">instance</span>) &#123;<br>            <span class="hljs-title class_">ConfigManager</span>.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfigManager</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ConfigManager</span>.<span class="hljs-property">instance</span>;<br>    &#125;<br><br>    <span class="hljs-title function_">getConfig</span>(<span class="hljs-params">key</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_config</span>[key];<br>    &#125;<br><br>    <span class="hljs-title function_">setConfig</span>(<span class="hljs-params">key, value</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_config</span>[key] = value;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> config = <span class="hljs-title class_">ConfigManager</span>.<span class="hljs-title function_">getInstance</span>();<br>config.<span class="hljs-title function_">setConfig</span>(<span class="hljs-string">&#x27;API_URL&#x27;</span>, <span class="hljs-string">&#x27;https://api.example.com&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(config.<span class="hljs-title function_">getConfig</span>(<span class="hljs-string">&#x27;API_URL&#x27;</span>)); <span class="hljs-comment">// 輸出: https://api.example.com</span><br></code></pre></td></tr></table></figure><h4 id="3-2-日誌系統"><a href="#3-2-日誌系統" class="headerlink" title="3.2 日誌系統"></a>3.2 日誌系統</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">logs</span> = [];<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">getInstance</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Logger</span>.<span class="hljs-property">instance</span>) &#123;<br>            <span class="hljs-title class_">Logger</span>.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Logger</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Logger</span>.<span class="hljs-property">instance</span>;<br>    &#125;<br><br>    <span class="hljs-title function_">log</span>(<span class="hljs-params">message</span>) &#123;<br>        <span class="hljs-keyword">const</span> timestamp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toISOString</span>();<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">logs</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;timestamp&#125;</span>: <span class="hljs-subst">$&#123;message&#125;</span>`</span>);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;timestamp&#125;</span>: <span class="hljs-subst">$&#123;message&#125;</span>`</span>);<br>    &#125;<br><br>    <span class="hljs-title function_">getLogs</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">logs</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> logger = <span class="hljs-title class_">Logger</span>.<span class="hljs-title function_">getInstance</span>();<br>logger.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;應用程序啟動&#x27;</span>);<br>logger.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;用戶登錄&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(logger.<span class="hljs-title function_">getLogs</span>());<br></code></pre></td></tr></table></figure><h3 id="4-Singleton-模式的進階實現"><a href="#4-Singleton-模式的進階實現" class="headerlink" title="4. Singleton 模式的進階實現"></a>4. Singleton 模式的進階實現</h3><p>除了基本實現，Singleton 還有一些進階技巧：</p><h4 id="4-1-線程安全的-Singleton（Java-示例）"><a href="#4-1-線程安全的-Singleton（Java-示例）" class="headerlink" title="4.1 線程安全的 Singleton（Java 示例）"></a>4.1 線程安全的 Singleton（Java 示例）</h4><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs smali">public class ThreadSafeSingleton &#123;<br>   <span class="hljs-keyword"> private</span><span class="hljs-keyword"> static</span> volatile ThreadSafeSingleton instance;<br><br>   <span class="hljs-keyword"> private</span> ThreadSafeSingleton() &#123;&#125;<br><br>   <span class="hljs-keyword"> public</span><span class="hljs-keyword"> static</span> ThreadSafeSingleton getInstance() &#123;<br>       <span class="hljs-built_in"> if </span>(instance == null) &#123;<br>            synchronized (ThreadSafeSingleton.class) &#123;<br>               <span class="hljs-built_in"> if </span>(instance == null) &#123;<br>                   <span class="hljs-built_in"> instance </span>=<span class="hljs-built_in"> new </span>ThreadSafeSingleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>       <span class="hljs-built_in"> return </span>instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-模塊模式實現（JavaScript）"><a href="#4-2-模塊模式實現（JavaScript）" class="headerlink" title="4.2 模塊模式實現（JavaScript）"></a>4.2 模塊模式實現（JavaScript）</h4><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">const</span> DatabaseConnection = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> instance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createInstance</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-comment">// 私有變量和方法</span><br>        <span class="hljs-keyword">let</span> connection = <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">connect</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-comment">// 模擬數據庫連接</span><br>            connection = &#123; <span class="hljs-attribute">id:</span><span class="hljs-string"> Math.random</span>() &#125;;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;建立新的數據庫連接&#x27;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attribute">getConnection</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>                <span class="hljs-keyword">if</span> (!connection) &#123;<br>                    connect();<br>                &#125;<br>                <span class="hljs-keyword">return</span> connection;<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attribute">getInstance</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">if</span> (!instance) &#123;<br>                instance = createInstance();<br>            &#125;<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br>    &#125;;<br>&#125;)();<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> connection1 = DatabaseConnection.getInstance().getConnection();<br><span class="hljs-keyword">const</span> connection2 = DatabaseConnection.getInstance().getConnection();<br><br><span class="hljs-built_in">console</span>.log(connection1 === connection2); <span class="hljs-comment">// 輸出: true</span><br></code></pre></td></tr></table></figure><h3 id="5-Singleton-模式的優缺點"><a href="#5-Singleton-模式的優缺點" class="headerlink" title="5. Singleton 模式的優缺點"></a>5. Singleton 模式的優缺點</h3><h4 id="優點"><a href="#優點" class="headerlink" title="優點"></a>優點</h4><ol><li><strong>資源節約</strong>：避免重複創建對象，節省系統資源。</li><li><strong>全局狀態管理</strong>：提供了一個統一的全局狀態管理方案。</li><li><strong>協調行為</strong>：確保在系統中只有一個實例在運行，協調各個組件的行為。</li></ol><h4 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h4><ol><li><strong>單元測試困難</strong>：全局狀態使得單元測試變得複雜。</li><li><strong>違反單一職責原則</strong>：Singleton 類別同時負責業務邏輯和自身的實例化控制。</li><li><strong>依賴問題</strong>：使用 Singleton 可能導致代碼間的高耦合。</li></ol><h3 id="6-最佳實踐與注意事項"><a href="#6-最佳實踐與注意事項" class="headerlink" title="6. 最佳實踐與注意事項"></a>6. 最佳實踐與注意事項</h3><ol><li><strong>慎用 Singleton</strong>：雖然 Singleton 模式強大，但不應濫用。評估是否真的需要全局唯一實例。</li><li><strong>考慮替代方案</strong>：在某些情況下，依賴注入可能是更好的選擇。</li><li><strong>線程安全</strong>：在多線程環境中，確保 Singleton 的線程安全實現。</li><li><strong>序列化問題</strong>：如果 Singleton 類別需要序列化，要特別注意避免反序列化時創建新實例。</li></ol><h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>Singleton 模式是一把雙刃劍 —— 使用得當可以簡化設計、優化資源使用；使用不當則可能導致代碼難以維護。作為開發者，我們需要權衡利弊，在適當的場景中靈活運用這一模式，以創造出高效、可靠的軟件系統。</p>]]></content>
    
    
    <categories>
      
      <category>design pattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>design pattern</tag>
      
      <tag>創建設計模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[hexo] Hexo 基本設置</title>
    <link href="/blog/20240805/3937366855/"/>
    <url>/blog/20240805/3937366855/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo-基本設定指南"><a href="#Hexo-基本設定指南" class="headerlink" title="Hexo 基本設定指南"></a>Hexo 基本設定指南</h1><p><img src="/images/hexo/01-hexo-basic.png" alt="hexo基本設定"><br>這份指南將帶您了解如何在本機環境中安裝和設定 Hexo，以便開始建立您的靜態部落格網站。本篇文章適合初學者，也包含一些實用的指令與維護方式。</p><h2 id="Hexo-的優勢"><a href="#Hexo-的優勢" class="headerlink" title="Hexo 的優勢"></a>Hexo 的優勢</h2><p>在深入學習之前，讓我們先了解 Hexo 的幾個主要優勢：</p><ol><li><strong>快速與高效</strong>：Hexo 使用靜態檔案，能夠快速生成並部署網站，運行時無需伺服器處理請求，速度快且安全。</li><li><strong>靈活性強</strong>：支援高度自定義的主題和插件，讓您能打造出符合自己需求的部落格。</li><li><strong>社群活躍</strong>：擁有豐富的主題和插件，社群資源豐富，可以輕鬆擴展網站功能。</li><li><strong>適合 SEO</strong>：靜態網站天然適合搜尋引擎收錄，結合 Hexo 的 SEO 插件，能進一步提升網站可見性。</li></ol><h2 id="總覽"><a href="#總覽" class="headerlink" title="總覽"></a>總覽</h2><p>本文將涵蓋以下內容：</p><ol><li>先決條件：必須安裝的軟體</li><li>安裝與初始化 Hexo</li><li>基本配置與網站部署</li><li>常用指令</li><li>基本維護邏輯</li></ol><h2 id="先決條件"><a href="#先決條件" class="headerlink" title="先決條件"></a>先決條件</h2><p>在開始之前，請確認您已安裝以下軟體：</p><ul><li><a href="https://nodejs.org/">Node.js</a>（建議使用最新的 LTS 版本）</li><li><a href="https://pnpm.io/">pnpm</a>（Node.js 套件管理工具）</li></ul><h2 id="安裝-Hexo"><a href="#安裝-Hexo" class="headerlink" title="安裝 Hexo"></a>安裝 Hexo</h2><h3 id="1-安裝-Node-js-和-pnpm"><a href="#1-安裝-Node-js-和-pnpm" class="headerlink" title="1. 安裝 Node.js 和 pnpm"></a>1. 安裝 Node.js 和 pnpm</h3><p>如果您還未安裝 Node.js 和 pnpm，請使用以下指令安裝：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用 Homebrew 安裝 Node.js</span><br>brew install node<br><br><span class="hljs-comment"># 安裝 pnpm</span><br>brew install pnpm<br></code></pre></td></tr></table></figure><h3 id="2-全域安裝-Hexo-CLI"><a href="#2-全域安裝-Hexo-CLI" class="headerlink" title="2. 全域安裝 Hexo CLI"></a>2. 全域安裝 Hexo CLI</h3><p>使用 pnpm 全域安裝 Hexo CLI：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm add -g hexo-cli<br></code></pre></td></tr></table></figure><h3 id="3-初始化-Hexo-專案"><a href="#3-初始化-Hexo-專案" class="headerlink" title="3. 初始化 Hexo 專案"></a>3. 初始化 Hexo 專案</h3><p>選擇一個目錄來存放您的部落格專案，然後使用以下指令初始化 Hexo 專案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> my-blog<br><span class="hljs-built_in">cd</span> my-blog<br>hexo init<br></code></pre></td></tr></table></figure><p>接下來，安裝專案所需的依賴：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm install<br></code></pre></td></tr></table></figure><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>Hexo 的基本配置檔案是根目錄下的 <code>_config.yml</code>，以下是一些常見的設定：</p><h3 id="網站基本信息"><a href="#網站基本信息" class="headerlink" title="網站基本信息"></a>網站基本信息</h3><p>在 <code>_config.yml</code> 中設定網站的基本信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-string">My</span> <span class="hljs-string">Blog</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">Welcome</span> <span class="hljs-string">to</span> <span class="hljs-string">my</span> <span class="hljs-string">blog</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">這是一個使用</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">建立的部落格</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">您的名稱</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-TW</span><br></code></pre></td></tr></table></figure><h3 id="設定網址"><a href="#設定網址" class="headerlink" title="設定網址"></a>設定網址</h3><p>設定部落格的 URL：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">url:</span> <span class="hljs-string">https://您的域名.com</span><br><span class="hljs-attr">root:</span> <span class="hljs-string">/</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span><br></code></pre></td></tr></table></figure><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><p>以下是一些常用的 Hexo 指令，幫助您在開發過程中更有效率：</p><ul><li><strong>清理檔案</strong></li></ul><p>清除暫存檔和生成的檔案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br><span class="hljs-comment"># 或使用簡寫</span><br>hexo c<br></code></pre></td></tr></table></figure><ul><li><strong>生成靜態檔案</strong></li></ul><p>生成網站的靜態檔案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate<br><span class="hljs-comment"># 或使用簡寫</span><br>hexo g<br></code></pre></td></tr></table></figure><ul><li><strong>啟動本地開發伺服器</strong></li></ul><p>啟動本地伺服器以預覽網站：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo server<br><span class="hljs-comment"># 或使用簡寫</span><br>hexo s<br></code></pre></td></tr></table></figure><p>現在，您可以在瀏覽器中造訪 <code>http://localhost:4000</code>。</p><ul><li><strong>部署網站</strong></li></ul><p>部署網站到遠端伺服器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo deploy<br><span class="hljs-comment"># 或使用簡寫</span><br>hexo d<br></code></pre></td></tr></table></figure><ul><li><strong>新增文章</strong></li></ul><p>新增一篇新文章：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&quot;文章標題&quot;</span><br><span class="hljs-comment"># 或使用簡寫</span><br>hexo n <span class="hljs-string">&quot;文章標題&quot;</span><br></code></pre></td></tr></table></figure><h2 id="部署網站"><a href="#部署網站" class="headerlink" title="部署網站"></a>部署網站</h2><p>Hexo 支援多種部署方式，這裡以 <strong>GitHub Pages</strong> 為例，詳細介紹如何將您的 Hexo 部落格部署到 GitHub Pages。</p><h3 id="1-創建-GitHub-Repository"><a href="#1-創建-GitHub-Repository" class="headerlink" title="1. 創建 GitHub Repository"></a>1. 創建 GitHub Repository</h3><p>首先，登入您的 GitHub 帳號，創建一個新的倉庫（repository）。倉庫名稱可以是：</p><ul><li><strong>用戶名.github.io</strong>：如果您希望使用 GitHub 提供的個人主頁功能，倉庫名稱必須與您的 GitHub 用戶名一致，後面加上 <code>.github.io</code>。</li><li><strong>自定義名稱</strong>：如果您想要部署在自定義的路徑下，可以使用任意倉庫名稱。</li></ul><h3 id="2-安裝部署插件"><a href="#2-安裝部署插件" class="headerlink" title="2. 安裝部署插件"></a>2. 安裝部署插件</h3><p>安裝 <code>hexo-deployer-git</code> 插件，這個插件可以將生成的靜態檔案推送到 GitHub：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm add hexo-deployer-git<br></code></pre></td></tr></table></figure><h3 id="3-配置-config-yml"><a href="#3-配置-config-yml" class="headerlink" title="3. 配置 _config.yml"></a>3. 配置 <code>_config.yml</code></h3><p>在 Hexo 根目錄下的 <code>_config.yml</code> 中，找到或添加 <code>deploy</code> 配置，並進行如下設定：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>    <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:&lt;YOUR_USERNAME&gt;/&lt;YOUR_REPO&gt;.git</span><br>    <span class="hljs-attr">branch:</span> <span class="hljs-string">gh-pages</span><br></code></pre></td></tr></table></figure><ul><li><code>&lt;YOUR_USERNAME&gt;</code>：替換為您的 GitHub 使用者名稱。</li><li><code>&lt;YOUR_REPO&gt;</code>：替換為您的倉庫名稱。</li></ul><p><strong>注意：</strong></p><ul><li>如果您的倉庫名稱是 <code>&lt;YOUR_USERNAME&gt;.github.io</code>，那麼部署分支應該是 <code>main</code> 或 <code>master</code>，具體取決於您的默認分支名稱。</li><li>如果使用自定義倉庫名稱，建議將部署分支設為 <code>gh-pages</code>，這是 GitHub Pages 的專用分支。</li></ul><h3 id="4-生成-SSH-金鑰（可選）"><a href="#4-生成-SSH-金鑰（可選）" class="headerlink" title="4. 生成 SSH 金鑰（可選）"></a>4. 生成 SSH 金鑰（可選）</h3><p>如果您還未在本機生成 SSH 金鑰，或者未將其添加到 GitHub，請執行以下步驟：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成新的 SSH 金鑰</span><br>ssh-keygen -t rsa -b 4096 -C <span class="hljs-string">&quot;your_email@example.com&quot;</span><br><br><span class="hljs-comment"># 啟動 ssh-agent 並添加金鑰</span><br><span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(ssh-agent -s)</span>&quot;</span><br>ssh-add ~/.ssh/id_rsa<br></code></pre></td></tr></table></figure><p>然後，將生成的公鑰內容（<code>~/.ssh/id_rsa.pub</code>）添加到 GitHub 的 SSH Keys 中。</p><h3 id="5-部署網站"><a href="#5-部署網站" class="headerlink" title="5. 部署網站"></a>5. 部署網站</h3><p>執行以下指令以生成並部署網站：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo generate<br>hexo deploy<br><span class="hljs-comment"># 或者簡寫為</span><br>hexo clean &amp;&amp; hexo g -d<br></code></pre></td></tr></table></figure><p>這將執行以下操作：</p><ol><li><strong>清理</strong>：刪除之前生成的靜態檔案，避免舊檔案干擾。</li><li><strong>生成</strong>：根據您的內容和配置，重新生成最新的靜態網站。</li><li><strong>部署</strong>：將生成的靜態檔案推送到您在 <code>_config.yml</code> 中設定的 GitHub 倉庫和分支。</li></ol><h3 id="6-驗證部署結果"><a href="#6-驗證部署結果" class="headerlink" title="6. 驗證部署結果"></a>6. 驗證部署結果</h3><p>部署完成後，您可以在瀏覽器中訪問：</p><ul><li><p>如果倉庫名稱是 <code>&lt;YOUR_USERNAME&gt;.github.io</code>，那麼您的網站地址為：</p>  <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//&lt;YOUR_USERNAME&gt;.github.io/</span><br></code></pre></td></tr></table></figure></li><li><p>如果倉庫名稱是自定義的，並且部署在 <code>gh-pages</code> 分支，則訪問地址為：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">https://<span class="hljs-tag">&lt;<span class="hljs-name">YOUR_USERNAME</span>&gt;</span>.github.io/<span class="hljs-tag">&lt;<span class="hljs-name">YOUR_REPO</span>&gt;</span>/<br></code></pre></td></tr></table></figure></li></ul><p><strong>注意：</strong> GitHub Pages 部署可能需要幾分鐘的時間才能生效。如果在訪問時看不到更新，請稍等片刻並刷新頁面。</p><h3 id="7-常見問題排查"><a href="#7-常見問題排查" class="headerlink" title="7. 常見問題排查"></a>7. 常見問題排查</h3><ul><li><p><strong>部署後網站顯示空白或 404 錯誤</strong>：</p><ul><li>確認您的部署分支和路徑是否正確。</li><li>檢查 <code>_config.yml</code> 中的 <code>url</code> 和 <code>root</code> 設置是否匹配。</li></ul></li><li><p><strong>無法推送到 GitHub，提示權限錯誤</strong>：</p><ul><li>確認您的 SSH 金鑰已正確添加到 GitHub。</li><li>檢查 <code>repo</code> 地址是否正確，可以嘗試使用 HTTPS 方式：</li></ul>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/&lt;YOUR_USERNAME&gt;/&lt;YOUR_REPO&gt;.git</span><br></code></pre></td></tr></table></figure></li><li><p><strong>部署命令失敗，提示缺少插件</strong>：</p><ul><li>確認已安裝 <code>hexo-deployer-git</code> 插件，並且在 <code>package.json</code> 的依賴中。</li></ul></li></ul><h3 id="8-自動化部署（可選）"><a href="#8-自動化部署（可選）" class="headerlink" title="8. 自動化部署（可選）"></a>8. 自動化部署（可選）</h3><p>如果您希望在每次提交內容更新後自動部署，可以考慮使用 GitHub Actions、自建 CI&#x2F;CD 流水線，或在本機腳本中添加部署命令。</p><h2 id="基本維護邏輯"><a href="#基本維護邏輯" class="headerlink" title="基本維護邏輯"></a>基本維護邏輯</h2><p>Hexo 的維護過程相對簡單，這是它作為靜態網站生成器的其中一個優勢。以下是一些日常維護的步驟與注意事項：</p><ul><li><strong>清理與重新生成</strong>：在每次修改完配置或安裝新的插件後，建議使用 <code>hexo clean</code> 清理舊的暫存檔，再執行 <code>hexo generate</code> 重新生成靜態網站。</li><li><strong>檔案同步</strong>：Hexo 的內容基於檔案管理，您只需要確保源碼版本控制（如 Git）一致，並定期備份 <code>_config.yml</code> 及其他重要配置檔案。</li><li><strong>定期檢查插件更新</strong>：通過 <code>pnpm update</code> 可以檢查並更新 Hexo 及其相關插件，保持部落格穩定性。</li></ul><h2 id="總結與下一步行動"><a href="#總結與下一步行動" class="headerlink" title="總結與下一步行動"></a>總結與下一步行動</h2><p>這篇文章介紹了 Hexo 的安裝、基本設定、部署方法、常用指令以及基本維護邏輯。Hexo 的操作簡單，特別適合想要建立個人部落格的開發者。</p><p>接下來，我們將在[第二篇進階設定指南]深入探討如何進一步自定義您的 Hexo 部落格，包括主題設定、插件安裝、以及 SEO 優化等。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[jekyll] 01 設定 Jekyll 所需要的 Ruby 環境</title>
    <link href="/blog/20240623/720391083/"/>
    <url>/blog/20240623/720391083/</url>
    
    <content type="html"><![CDATA[<p>要安裝並使用 Jekyll，您需要先設置好您的 Ruby 環境。以下是步驟：</p><ol><li><p><strong>安裝 Ruby</strong>：<br> 在 macOS 上，您可以使用 Homebrew 來安裝 Ruby：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install ruby<br></code></pre></td></tr></table></figure></li><li><p><strong>安裝 Bundler</strong>：<br> Bundler 是 Ruby 的包管理器，您可以使用以下命令來安裝：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gem install bundler<br></code></pre></td></tr></table></figure></li><li><p><strong>檢查 Ruby 版本</strong>：<br> 確保您安裝了正確的 Ruby 版本：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ruby -v<br></code></pre></td></tr></table></figure></li><li><p><strong>設定 PATH</strong>：<br> 在您的 <code>.bash_profile</code> 或 <code>.zshrc</code> 中添加以下內容，讓系統找到正確的 Ruby 路徑：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;/usr/local/opt/ruby/bin:<span class="hljs-variable">$PATH</span>&quot;</span><br></code></pre></td></tr></table></figure></li></ol><p>完成以上步驟後，您就已經成功設定了 Jekyll 所需要的 Ruby 環境！</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jekyll</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[jekyll] 02 設定 /posts/ 頁面的內容</title>
    <link href="/blog/20240623/166608104/"/>
    <url>/blog/20240623/166608104/</url>
    
    <content type="html"><![CDATA[<p>以下是設定 Jekyll <code>/posts/</code> 頁面內容的步驟：</p><ol><li><p><strong>創建 posts 頁面</strong>：<br> 在 <code>_pages</code> 目錄中創建一個 <code>posts.md</code> 文件，並添加以下內容：</p> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>layout: page<br>title: &quot;所有文章&quot;<br><span class="hljs-section">permalink: /posts/</span><br><span class="hljs-section">---</span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;posts&quot;</span>&gt;</span></span><br><span class="hljs-code">    &lt;h1&gt;&#123;&#123; page.title &#125;&#125;&lt;/h1&gt;</span><br><span class="hljs-code">    &lt;ul class=&quot;post-list&quot;&gt;</span><br><span class="hljs-code">    &#123;% for post in site.posts %&#125;</span><br><span class="hljs-code">        &lt;li&gt;</span><br><span class="hljs-code">        &lt;span class=&quot;post-meta&quot;&gt;&#123;&#123; post.date | date: &quot;%b %-d, %Y&quot; &#125;&#125;&lt;/span&gt;</span><br><span class="hljs-code">        &lt;h2&gt;</span><br><span class="hljs-code">            &lt;a class=&quot;post-link&quot; href=&quot;&#123;&#123; post.url | relative_url &#125;&#125;&quot;&gt;&#123;&#123; post.title | escape &#125;&#125;&lt;/a&gt;</span><br><span class="hljs-code">        &lt;/h2&gt;</span><br><span class="hljs-code">        &lt;/li&gt;</span><br><span class="hljs-code">    &#123;% endfor %&#125;</span><br><span class="hljs-code">    &lt;/ul&gt;</span><br><span class="hljs-code">&lt;/div&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>**更新 <code>_config.yml</code>**：<br> 確保您的 <code>_config.yml</code> 文件中有以下設置：</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">header_pages:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">about.md</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">index.md</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">posts.md</span><br></code></pre></td></tr></table></figure></li></ol><p>完成以上步驟後，您的 <code>/posts/</code> 頁面就會顯示所有的文章列表。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jekyll</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[jekyll] 03 設定首頁的內容</title>
    <link href="/blog/20240623/2077178930/"/>
    <url>/blog/20240623/2077178930/</url>
    
    <content type="html"><![CDATA[<p>以下是設定 Jekyll 首頁內容的步驟：</p><ol><li><p>**修改 <code>_config.yml</code>**：<br> 確保您的 <code>_config.yml</code> 中有以下設置：</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">paginate:</span> <span class="hljs-number">5</span><br><span class="hljs-attr">paginate_path:</span> <span class="hljs-string">&quot;/page:num/&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>創建首頁模板</strong>：<br> 在 <code>_layouts</code> 目錄中創建一個 <code>home.html</code> 文件，並添加以下內容：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html">---<br>layout: default<br>---<br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;home&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-heading&quot;</span>&gt;</span>&#123;&#123; page.title | escape &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;post-list&quot;</span>&gt;</span><br>    &#123;% for post in paginator.posts %&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;post-meta&quot;</span>&gt;</span>&#123;&#123; post.date | date: &quot;%b %-d, %Y&quot; &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;post-link&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;&#123; post.url | relative_url &#125;&#125;&quot;</span>&gt;</span>&#123;&#123; post.title | escape &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    &#123;% endfor %&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pagination&quot;</span>&gt;</span><br>    &#123;% if paginator.previous_page %&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pagination-item older&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;&#123; paginator.previous_page_path | relative_url &#125;&#125;&quot;</span>&gt;</span><span class="hljs-symbol">&amp;larr;</span> Older<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    &#123;% endif %&#125;<br>    &#123;% if paginator.next_page %&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pagination-item newer&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;&#123; paginator.next_page_path | relative_url &#125;&#125;&quot;</span>&gt;</span>Newer <span class="hljs-symbol">&amp;rarr;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    &#123;% endif %&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>更新首頁文件</strong>：<br> 確保您的 <code>index.md</code> 文件中有以下內容：</p> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>layout: home<br>title: &quot;首頁&quot;<br><span class="hljs-section">permalink: /</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure></li></ol><p>完成以上步驟後，您的 Jekyll 首頁就會顯示最新的文章列表！</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jekyll</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[jekyll] 04 設定分類和 Tags 頁面的內容</title>
    <link href="/blog/20240623/3302600295/"/>
    <url>/blog/20240623/3302600295/</url>
    
    <content type="html"><![CDATA[<p>以下是設定 Jekyll 分類和 Tags 頁面內容的步驟：</p><ol><li><p><strong>創建分類頁面</strong>：<br> 在 <code>_pages</code> 目錄中創建一個 <code>categories.md</code> 文件，並添加以下內容：</p> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>layout: page<br>title: &quot;分類&quot;<br><span class="hljs-section">permalink: /categories/</span><br><span class="hljs-section">---</span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;categories&quot;</span>&gt;</span></span><br><span class="hljs-code">    &lt;h1&gt;&#123;&#123; page.title &#125;&#125;&lt;/h1&gt;</span><br><span class="hljs-code">    &lt;ul class=&quot;category-list&quot;&gt;</span><br><span class="hljs-code">    &#123;% for category in site.categories %&#125;</span><br><span class="hljs-code">        &lt;li&gt;</span><br><span class="hljs-code">        &lt;a href=&quot;&#123;&#123; site.baseurl &#125;&#125;/categories/&#123;&#123; category | first &#125;&#125;&quot;&gt;&#123;&#123; category | first &#125;&#125;&lt;/a&gt; (&#123;&#123; category | last | size &#125;&#125;)</span><br><span class="hljs-code">        &lt;/li&gt;</span><br><span class="hljs-code">    &#123;% endfor %&#125;</span><br><span class="hljs-code">    &lt;/ul&gt;</span><br><span class="hljs-code">&lt;/div&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>創建 Tags 頁面</strong>：<br> 在 <code>_pages</code> 目錄中創建一個 <code>tags.md</code> 文件，並添加以下內容：</p> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>layout: page<br>title: &quot;Tags&quot;<br><span class="hljs-section">permalink: /tags/</span><br><span class="hljs-section">---</span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tags&quot;</span>&gt;</span></span><br><span class="hljs-code">    &lt;h1&gt;&#123;&#123; page.title &#125;&#125;&lt;/h1&gt;</span><br><span class="hljs-code">    &lt;ul class=&quot;tag-list&quot;&gt;</span><br><span class="hljs-code">    &#123;% for tag in site.tags %&#125;</span><br><span class="hljs-code">        &lt;li&gt;</span><br><span class="hljs-code">        &lt;a href=&quot;&#123;&#123; site.baseurl &#125;&#125;/tags/&#123;&#123; tag | first &#125;&#125;&quot;&gt;&#123;&#123; tag | first &#125;&#125;&lt;/a&gt; (&#123;&#123; tag | last | size &#125;&#125;)</span><br><span class="hljs-code">        &lt;/li&gt;</span><br><span class="hljs-code">    &#123;% endfor %&#125;</span><br><span class="hljs-code">    &lt;/ul&gt;</span><br><span class="hljs-code">&lt;/div&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>**更新 <code>_config.yml</code>**：<br> 確保您的 <code>_config.yml</code> 文件中有以下設置：</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">header_pages:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">about.md</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">index.md</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">posts.md</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">categories.md</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">tags.md</span><br></code></pre></td></tr></table></figure></li></ol><p>完成以上步驟後，您的 Jekyll 站點就會顯示分類和 Tags 頁面。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jekyll</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[jekyll] 05 基本安裝 Jekyll 的流程及啟動</title>
    <link href="/blog/20240623/303548041/"/>
    <url>/blog/20240623/303548041/</url>
    
    <content type="html"><![CDATA[<p>以下是安裝 Jekyll 的基本步驟：</p><ol><li><p><strong>安裝 Jekyll 和 Bundler</strong>：<br> 在命令行中運行以下命令來安裝 Jekyll 和 Bundler：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gem install jekyll bundler<br></code></pre></td></tr></table></figure></li><li><p><strong>創建新的 Jekyll 站點</strong>：<br> 運行以下命令來創建一個新的 Jekyll 站點：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">jekyll new myblog<br><span class="hljs-built_in">cd</span> myblog<br></code></pre></td></tr></table></figure></li><li><p><strong>安裝依賴項</strong>：<br> 在新的站點目錄中運行以下命令來安裝所需的依賴項：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bundle install<br></code></pre></td></tr></table></figure></li><li><p><strong>啟動本地服務器</strong>：<br> 運行以下命令來啟動 Jekyll 本地服務器：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bundle <span class="hljs-built_in">exec</span> jekyll serve<br></code></pre></td></tr></table></figure></li><li><p><strong>訪問本地站點</strong>：<br> 打開瀏覽器，訪問 <code>http://localhost:4000</code> 來查看您的新 Jekyll 站點。</p></li></ol><p>按照以上步驟，您就能夠成功安裝並啟動 Jekyll 站點！</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jekyll</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
